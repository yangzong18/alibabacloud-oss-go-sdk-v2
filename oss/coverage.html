
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>oss: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/api_op_bucket.go (78.9%)</option>
				
				<option value="file1">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/api_op_common.go (66.7%)</option>
				
				<option value="file2">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/api_op_object.go (78.8%)</option>
				
				<option value="file3">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/api_op_select_object.go (88.4%)</option>
				
				<option value="file4">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/api_op_service.go (84.6%)</option>
				
				<option value="file5">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/client.go (85.2%)</option>
				
				<option value="file6">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/client_extension.go (93.0%)</option>
				
				<option value="file7">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/client_filelike.go (96.8%)</option>
				
				<option value="file8">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/client_paginators.go (84.4%)</option>
				
				<option value="file9">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/client_presign.go (98.9%)</option>
				
				<option value="file10">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/config.go (38.5%)</option>
				
				<option value="file11">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/enums.go (0.0%)</option>
				
				<option value="file12">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/errors.go (53.1%)</option>
				
				<option value="file13">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/from_ptr.go (41.7%)</option>
				
				<option value="file14">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/io_utils.go (93.8%)</option>
				
				<option value="file15">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/limiter.go (0.0%)</option>
				
				<option value="file16">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/to_ptr.go (100.0%)</option>
				
				<option value="file17">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/types.go (52.9%)</option>
				
				<option value="file18">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/utils.go (76.9%)</option>
				
				<option value="file19">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/utils_copy.go (60.8%)</option>
				
				<option value="file20">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/utils_crc.go (86.0%)</option>
				
				<option value="file21">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/utils_mime.go (94.1%)</option>
				
				<option value="file22">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/utils_pool.go (70.6%)</option>
				
				<option value="file23">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/validation.go (85.7%)</option>
				
				<option value="file24">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/version.go (88.9%)</option>
				
				<option value="file25">github.com/aliyun/aliyun-oss-go-sdk/v3/oss/xml_utils.go (90.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package oss

import (
        "context"
        "encoding/xml"
        "net/url"
        "strings"
        "time"
)

type PutBucketRequest struct {
        // The name of the bucket to create.
        Bucket *string `input:"host,bucket,required"`

        // The access control list (ACL) of the bucket.
        Acl BucketACLType `input:"header,x-oss-acl"`

        // The ID of the resource group.
        ResourceGroupId *string `input:"header,x-oss-resource-group-id"`

        // The configuration information for the bucket.
        CreateBucketConfiguration *CreateBucketConfiguration `input:"body,CreateBucketConfiguration,xml"`

        RequestCommon
}

type CreateBucketConfiguration struct {
        XMLName xml.Name `xml:"CreateBucketConfiguration"`

        // The storage class of the bucket.
        StorageClass StorageClassType `xml:"StorageClass"`

        // The redundancy type of the bucket.
        DataRedundancyType DataRedundancyType `xml:"DataRedundancyType"`
}

type PutBucketResult struct {
        ResultCommon
}

// PutBucket Creates a bucket.
func (c *Client) PutBucket(ctx context.Context, request *PutBucketRequest, optFns ...func(*Options)) (*PutBucketResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;PutBucketRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "PutBucket",
                Method: "PUT",
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeXML,
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;PutBucketResult{}

        if err = c.unmarshalOutput(result, output, discardBody); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type DeleteBucketRequest struct {
        // The name of the bucket to delete.
        Bucket *string `input:"host,bucket,required"`

        RequestCommon
}

type DeleteBucketResult struct {
        ResultCommon
}

// DeleteBucket Deletes a bucket.
func (c *Client) DeleteBucket(ctx context.Context, request *DeleteBucketRequest, optFns ...func(*Options)) (*DeleteBucketResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;DeleteBucketRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "DeleteBucket",
                Method: "DELETE",
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeDefault,
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;DeleteBucketResult{}
        if err = c.unmarshalOutput(result, output, discardBody); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type ListObjectsRequest struct {
        // The name of the bucket containing the objects
        Bucket *string `input:"host,bucket,required"`

        // The character that is used to group objects by name. If you specify the delimiter parameter in the request,
        // the response contains the CommonPrefixes parameter. The objects whose names contain the same string from
        // the prefix to the next occurrence of the delimiter are grouped as a single result element in CommonPrefixes.
        Delimiter *string `input:"query,delimiter"`

        // The encoding type of the content in the response. Valid value: url
        EncodingType *string `input:"query,encoding-type"`

        // The name of the object after which the ListObjects (GetBucket) operation starts.
        // If this parameter is specified, objects whose names are alphabetically greater than the marker value are returned.
        Marker *string `input:"query,marker"`

        // The maximum number of objects that you want to return. If the list operation cannot be complete at a time
        // because the max-keys parameter is specified, the NextMarker element is included in the response as the marker
        // for the next list operation.
        MaxKeys int32 `input:"query,max-keys"`

        // The prefix that the names of the returned objects must contain.
        Prefix *string `input:"query,prefix"`

        RequestCommon
}

type ListObjectsResult struct {
        // The name of the bucket.
        Name *string `xml:"Name"`

        // The prefix contained in the returned object names.
        Prefix *string `xml:"Prefix"`

        // The name of the object after which the list operation begins.
        Marker *string `xml:"Marker"`

        // The maximum number of returned objects in the response.
        MaxKeys int32 `xml:"MaxKeys"`

        // The character that is used to group objects by name.
        Delimiter *string `xml:"Delimiter"`

        // Indicates whether the returned results are truncated.
        // true indicates that not all results are returned this time.
        // false indicates that all results are returned this time.
        IsTruncated bool `xml:"IsTruncated"`

        // The position from which the next list operation starts.
        NextMarker *string `xml:"NextMarker"`

        // The encoding type of the content in the response.
        EncodingType *string `xml:"EncodingType"`

        // The container that stores the metadata of the returned objects.
        Contents []ObjectProperties `xml:"Contents"`

        // If the Delimiter parameter is specified in the request, the response contains the CommonPrefixes element.
        CommonPrefixes []CommonPrefix `xml:"CommonPrefixes"`

        ResultCommon
}

type ObjectProperties struct {
        // The name of the object.
        Key *string `xml:"Key"`

        // The type of the object. Valid values: Normal, Multipart and Appendable
        Type *string `xml:"Type"`

        // The size of the returned object. Unit: bytes.
        Size int64 `xml:"Size"`

        // The entity tag (ETag). An ETag is created when an object is created to identify the content of the object.
        ETag *string `xml:"ETag"`

        // The time when the returned objects were last modified.
        LastModified *time.Time `xml:"LastModified"`

        // The storage class of the object.
        StorageClass *string `xml:"StorageClass"`

        // The container that stores information about the bucket owner.
        Owner *Owner `xml:"Owner"`

        // The restoration status of the object.
        RestoreInfo *string `xml:"RestoreInfo"`
}

type Owner struct {
        // The ID of the bucket owner.
        ID *string `xml:"ID"`

        // The name of the object owner.
        DisplayName *string `xml:"DisplayName"`
}

type CommonPrefix struct {
        // The prefix contained in the returned object names.
        Prefix *string `xml:"Prefix"`
}

// ListObjects Lists the information about all objects in a bucket.
func (c *Client) ListObjects(ctx context.Context, request *ListObjectsRequest, optFns ...func(*Options)) (*ListObjectsResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;ListObjectsRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "ListObjects",
                Method: "GET",
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeDefault,
                },
                Parameters: map[string]string{
                        "encoding-type": "url",
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;ListObjectsResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml, unmarshalEncodeType); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

func unmarshalEncodeType(result any, output *OperationOutput) error <span class="cov8" title="1">{
        switch r := result.(type) </span>{
        case *ListObjectsResult:<span class="cov8" title="1">
                if r.EncodingType != nil &amp;&amp; strings.EqualFold(*r.EncodingType, "url") </span><span class="cov8" title="1">{
                        fields := []**string{&amp;r.Prefix, &amp;r.Marker, &amp;r.Delimiter, &amp;r.NextMarker}
                        var s string
                        var err error
                        for _, pp := range fields </span><span class="cov8" title="1">{
                                if pp != nil &amp;&amp; *pp != nil </span><span class="cov8" title="1">{
                                        if s, err = url.QueryUnescape(**pp); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">*pp = Ptr(s)</span>
                                }
                        }
                        <span class="cov8" title="1">for i := 0; i &lt; len(r.Contents); i++ </span><span class="cov8" title="1">{
                                if *r.Contents[i].Key, err = url.QueryUnescape(*r.Contents[i].Key); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">for i := 0; i &lt; len(r.CommonPrefixes); i++ </span><span class="cov0" title="0">{
                                if *r.CommonPrefixes[i].Prefix, err = url.QueryUnescape(*r.CommonPrefixes[i].Prefix); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        case *ListObjectsResultV2:<span class="cov8" title="1">
                if r.EncodingType != nil &amp;&amp; strings.EqualFold(*r.EncodingType, "url") </span><span class="cov8" title="1">{
                        fields := []**string{&amp;r.Prefix, &amp;r.StartAfter, &amp;r.Delimiter, &amp;r.ContinuationToken, &amp;r.NextContinuationToken}
                        var s string
                        var err error
                        for _, pp := range fields </span><span class="cov8" title="1">{
                                if pp != nil &amp;&amp; *pp != nil </span><span class="cov8" title="1">{
                                        if s, err = url.QueryUnescape(**pp); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">*pp = Ptr(s)</span>
                                }
                        }
                        <span class="cov8" title="1">for i := 0; i &lt; len(r.Contents); i++ </span><span class="cov8" title="1">{
                                if *r.Contents[i].Key, err = url.QueryUnescape(*r.Contents[i].Key); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">for i := 0; i &lt; len(r.CommonPrefixes); i++ </span><span class="cov8" title="1">{
                                if *r.CommonPrefixes[i].Prefix, err = url.QueryUnescape(*r.CommonPrefixes[i].Prefix); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        case *DeleteMultipleObjectsResult:<span class="cov8" title="1">
                if r.EncodingType != nil &amp;&amp; strings.EqualFold(*r.EncodingType, "url") </span><span class="cov8" title="1">{
                        var err error
                        for i := 0; i &lt; len(r.DeletedObjects); i++ </span><span class="cov8" title="1">{
                                if *r.DeletedObjects[i].Key, err = url.QueryUnescape(*r.DeletedObjects[i].Key); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        case *InitiateMultipartUploadResult:<span class="cov8" title="1">
                if r.EncodingType != nil &amp;&amp; strings.EqualFold(*r.EncodingType, "url") </span><span class="cov8" title="1">{
                        var err error
                        if *r.Key, err = url.QueryUnescape(*r.Key); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case *CompleteMultipartUploadResult:<span class="cov8" title="1">
                if r.EncodingType != nil &amp;&amp; strings.EqualFold(*r.EncodingType, "url") </span><span class="cov8" title="1">{
                        var err error
                        if *r.Key, err = url.QueryUnescape(*r.Key); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case *ListMultipartUploadsResult:<span class="cov8" title="1">
                if r.EncodingType != nil &amp;&amp; strings.EqualFold(*r.EncodingType, "url") </span><span class="cov8" title="1">{
                        fields := []**string{&amp;r.KeyMarker, &amp;r.NextKeyMarker, &amp;r.Prefix, &amp;r.Delimiter}
                        var s string
                        var err error
                        for _, pp := range fields </span><span class="cov8" title="1">{
                                if pp != nil &amp;&amp; *pp != nil </span><span class="cov8" title="1">{
                                        if s, err = url.QueryUnescape(**pp); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">*pp = Ptr(s)</span>
                                }
                        }
                        <span class="cov8" title="1">for i := 0; i &lt; len(r.Uploads); i++ </span><span class="cov8" title="1">{
                                if *r.Uploads[i].Key, err = url.QueryUnescape(*r.Uploads[i].Key); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        case *ListPartsResult:<span class="cov8" title="1">
                if r.EncodingType != nil &amp;&amp; strings.EqualFold(*r.EncodingType, "url") </span><span class="cov8" title="1">{
                        fields := []**string{&amp;r.Key}
                        var s string
                        var err error
                        for _, pp := range fields </span><span class="cov8" title="1">{
                                if pp != nil &amp;&amp; *pp != nil </span><span class="cov8" title="1">{
                                        if s, err = url.QueryUnescape(**pp); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">*pp = Ptr(s)</span>
                                }
                        }
                }
        case *ListObjectVersionsResult:<span class="cov8" title="1">
                if r.EncodingType != nil &amp;&amp; strings.EqualFold(*r.EncodingType, "url") </span><span class="cov8" title="1">{
                        fields := []**string{&amp;r.Prefix, &amp;r.KeyMarker, &amp;r.Delimiter, &amp;r.NextKeyMarker}
                        var s string
                        var err error
                        for _, pp := range fields </span><span class="cov8" title="1">{
                                if pp != nil &amp;&amp; *pp != nil </span><span class="cov8" title="1">{
                                        if s, err = url.QueryUnescape(**pp); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">*pp = Ptr(s)</span>
                                }
                        }
                        <span class="cov8" title="1">for i := 0; i &lt; len(r.ObjectVersions); i++ </span><span class="cov8" title="1">{
                                if *r.ObjectVersions[i].Key, err = url.QueryUnescape(*r.ObjectVersions[i].Key); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">for i := 0; i &lt; len(r.ObjectDeleteMarkers); i++ </span><span class="cov8" title="1">{
                                if *r.ObjectDeleteMarkers[i].Key, err = url.QueryUnescape(*r.ObjectDeleteMarkers[i].Key); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">for i := 0; i &lt; len(r.CommonPrefixes); i++ </span><span class="cov8" title="1">{
                                if *r.CommonPrefixes[i].Prefix, err = url.QueryUnescape(*r.CommonPrefixes[i].Prefix); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

type ListObjectsRequestV2 struct {
        // The name of the bucket containing the objects
        Bucket *string `input:"host,bucket,required"`

        // The character that is used to group objects by name. If you specify the delimiter parameter in the request,
        // the response contains the CommonPrefixes parameter. The objects whose names contain the same string from
        // the prefix to the next occurrence of the delimiter are grouped as a single result element in CommonPrefixes.
        Delimiter *string `input:"query,delimiter"`

        // The name of the object after which the ListObjectsV2 (GetBucketV2) operation starts.
        // The objects are returned in alphabetical order of their names. The start-after parameter
        // is used to list the returned objects by page.
        // The value of the parameter must be less than 1,024 bytes in length.
        // Even if the specified start-after value does not exist during a conditional query,
        // the ListObjectsV2 (GetBucketV2) operation starts from the object whose name is alphabetically greater than the start-after value.
        // By default, this parameter is left empty.
        StartAfter *string `input:"query,start-after"`

        // The token from which the ListObjectsV2 (GetBucketV2) operation must start.
        // You can obtain the token from the NextContinuationToken parameter in the ListObjectsV2 (GetBucketV2) response.
        ContinuationToken *string `input:"query,continuation-token"`

        // The maximum number of objects that you want to return. If the list operation cannot be complete at a time
        // because the max-keys parameter is specified, the NextMarker element is included in the response as the marker
        // for the next list operation.
        MaxKeys int32 `input:"query,max-keys"`

        // The prefix that the names of the returned objects must contain.
        Prefix *string `input:"query,prefix"`

        // The encoding type of the content in the response. Valid value: url
        EncodingType *string `input:"query,encoding-type"`

        // Specifies whether to include information about the object owner in the response.
        FetchOwner bool `input:"query,fetch-owner"`

        RequestCommon
}

type ListObjectsResultV2 struct {
        // The name of the bucket.
        Name *string `xml:"Name"`

        // The prefix contained in the returned object names.
        Prefix *string `xml:"Prefix"`

        // If the StartAfter parameter is specified in the request, the response contains the StartAfter parameter.
        StartAfter *string `xml:"StartAfter"`

        // The maximum number of returned objects in the response.
        MaxKeys int32 `xml:"MaxKeys"`

        // The character that is used to group objects by name.
        Delimiter *string `xml:"Delimiter"`

        // Indicates whether the returned results are truncated.
        // true indicates that not all results are returned this time.
        // false indicates that all results are returned this time.
        IsTruncated bool `xml:"IsTruncated"`

        // If the ContinuationToken parameter is specified in the request, the response contains the ContinuationToken parameter.
        ContinuationToken *string `xml:"ContinuationToken"`

        // The name of the object from which the next ListObjectsV2 (GetBucketV2) operation starts.
        // The NextContinuationToken value is used as the ContinuationToken value to query subsequent results.
        NextContinuationToken *string `xml:"NextContinuationToken"`

        // The encoding type of the content in the response.
        EncodingType *string `xml:"EncodingType"`

        // The container that stores the metadata of the returned objects.
        Contents []ObjectProperties `xml:"Contents"`

        // If the Delimiter parameter is specified in the request, the response contains the CommonPrefixes element.
        CommonPrefixes []CommonPrefix `xml:"CommonPrefixes"`

        // The number of objects returned for this request. If Delimiter is specified, KeyCount is the sum of the values of Key and CommonPrefixes.
        KeyCount int `xml:"KeyCount"`

        ResultCommon
}

// ListObjectsV2 Queries information about all objects in a bucket.
func (c *Client) ListObjectsV2(ctx context.Context, request *ListObjectsRequestV2, optFns ...func(*Options)) (*ListObjectsResultV2, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;ListObjectsRequestV2{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "ListObjectsV2",
                Method: "GET",
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeDefault,
                },
                Parameters: map[string]string{
                        "list-type":     "2",
                        "encoding-type": "url",
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;ListObjectsResultV2{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml, unmarshalEncodeType); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type GetBucketInfoRequest struct {
        // The name of the bucket containing the objects
        Bucket *string `input:"host,bucket,required"`
        RequestCommon
}

type GetBucketInfoResult struct {
        // The container that stores the bucket information.
        BucketInfo BucketInfo `xml:"Bucket"`
        ResultCommon
}

// BucketInfo defines Bucket information
type BucketInfo struct {
        // The name of the bucket.
        Name *string `xml:"Name"`

        // Indicates whether access tracking is enabled for the bucket.
        AccessMonitor *string `xml:"AccessMonitor"`

        // The region in which the bucket is located.
        Location *string `xml:"Location"`

        // The time when the bucket is created. The time is in UTC.
        CreationDate *time.Time `xml:"CreationDate"`

        // The public endpoint that is used to access the bucket over the Internet.
        ExtranetEndpoint *string `xml:"ExtranetEndpoint"`

        // The internal endpoint that is used to access the bucket from Elastic
        IntranetEndpoint *string `xml:"IntranetEndpoint"`

        // The container that stores the access control list (ACL) information about the bucket.
        ACL *string `xml:"AccessControlList&gt;Grant"`

        // The disaster recovery type of the bucket.
        RedundancyType *string `xml:"DataRedundancyType"`

        // The container that stores the information about the bucket owner.
        Owner *Owner `xml:"Owner"`

        // The storage class of the bucket.
        StorageClass *string `xml:"StorageClass"`

        // The ID of the resource group to which the bucket belongs.
        ResourceGroupId *string `xml:"ResourceGroupId"`

        // The container that stores the server-side encryption method.
        SseRule SSERule `xml:"ServerSideEncryptionRule"`

        // Indicates whether versioning is enabled for the bucket.
        Versioning *string `xml:"Versioning"`

        // Indicates whether transfer acceleration is enabled for the bucket.
        TransferAcceleration *string `xml:"TransferAcceleration"`

        // Indicates whether cross-region replication (CRR) is enabled for the bucket.
        CrossRegionReplication *string `xml:"CrossRegionReplication"`

        // The container that stores the logs.
        BucketPolicy BucketPolicy `xml:"BucketPolicy"`
}

type SSERule struct {
        // The customer master key (CMK) ID in use. A valid value is returned only if you set SSEAlgorithm to KMS
        // and specify the CMK ID. In other cases, an empty value is returned.
        KMSMasterKeyID *string `xml:"KMSMasterKeyID"`

        // The server-side encryption method that is used by default.
        SSEAlgorithm *string `xml:"SSEAlgorithm"`

        // Object's encryption algorithm. If this element is not included in the response,
        // it indicates that the object is using the AES256 encryption algorithm.
        // This option is only valid if the SSEAlgorithm value is KMS.
        KMSDataEncryption *string `xml:"KMSDataEncryption"`
}

type BucketPolicy struct {
        // The name of the bucket that stores the logs.
        LogBucket *string `xml:"LogBucket"`

        // The directory in which logs are stored.
        LogPrefix *string `xml:"LogPrefix"`
}

// GetBucketInfo Queries information about a bucket.
func (c *Client) GetBucketInfo(ctx context.Context, request *GetBucketInfoRequest, optFns ...func(*Options)) (*GetBucketInfoResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;GetBucketInfoRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "GetBucketInfo",
                Method: "GET",
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeDefault,
                },
                Parameters: map[string]string{
                        "bucketInfo": "",
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;GetBucketInfoResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml, unmarshalSseRule); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

func unmarshalSseRule(result any, output *OperationOutput) error <span class="cov8" title="1">{
        switch r := result.(type) </span>{
        case *GetBucketInfoResult:<span class="cov8" title="1">
                fields := []*string{r.BucketInfo.SseRule.KMSMasterKeyID, r.BucketInfo.SseRule.SSEAlgorithm, r.BucketInfo.SseRule.KMSDataEncryption}
                for _, pp := range fields </span><span class="cov8" title="1">{
                        if pp != nil &amp;&amp; *pp == "None" </span><span class="cov8" title="1">{
                                *pp = ""
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

type GetBucketLocationRequest struct {
        // The name of the bucket containing the objects
        Bucket *string `input:"host,bucket,required"`
        RequestCommon
}

type GetBucketLocationResult struct {
        // The region in which the bucket is located.
        LocationConstraint *string `xml:",chardata"`
        ResultCommon
}

// GetBucketLocation Queries the region of an Object Storage Service (OSS) bucket.
func (c *Client) GetBucketLocation(ctx context.Context, request *GetBucketLocationRequest, optFns ...func(*Options)) (*GetBucketLocationResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;GetBucketLocationRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "GetBucketLocation",
                Method: "GET",
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeDefault,
                },
                Parameters: map[string]string{
                        "location": "",
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;GetBucketLocationResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

type GetBucketStatRequest struct {
        // The name of the bucket containing the objects
        Bucket *string `input:"host,bucket,required"`
        RequestCommon
}

type GetBucketStatResult struct {
        // The storage capacity of the bucket. Unit: bytes.
        Storage int64 `xml:"Storage"`

        // The total number of objects that are stored in the bucket.
        ObjectCount int64 `xml:"ObjectCount"`

        // The number of multipart upload tasks that have been initiated but are not completed or canceled.
        MultipartUploadCount int64 `xml:"MultipartUploadCount"`

        // The number of LiveChannels in the bucket.
        LiveChannelCount int64 `xml:"LiveChannelCount"`

        // The time when the obtained information is last modified. The value of this element is a UNIX timestamp. Unit: seconds.
        LastModifiedTime int64 `xml:"LastModifiedTime"`

        // The storage usage of Standard objects in the bucket. Unit: bytes.
        StandardStorage int64 `xml:"StandardStorage"`

        // The number of Standard objects in the bucket.
        StandardObjectCount int64 `xml:"StandardObjectCount"`

        // The billed storage usage of Infrequent Access (IA) objects in the bucket. Unit: bytes.
        InfrequentAccessStorage int64 `xml:"InfrequentAccessStorage"`

        // The actual storage usage of IA objects in the bucket. Unit: bytes.
        InfrequentAccessRealStorage int64 `xml:"InfrequentAccessRealStorage"`

        // The number of IA objects in the bucket.
        InfrequentAccessObjectCount int64 `xml:"InfrequentAccessObjectCount"`

        // The billed storage usage of Archive objects in the bucket. Unit: bytes.
        ArchiveStorage int64 `xml:"ArchiveStorage"`

        // The actual storage usage of Archive objects in the bucket. Unit: bytes.
        ArchiveRealStorage int64 `xml:"ArchiveRealStorage"`

        // The number of Archive objects in the bucket.
        ArchiveObjectCount int64 `xml:"ArchiveObjectCount"`

        // The billed storage usage of Cold Archive objects in the bucket. Unit: bytes.
        ColdArchiveStorage int64 `xml:"ColdArchiveStorage"`

        // The actual storage usage of Cold Archive objects in the bucket. Unit: bytes.
        ColdArchiveRealStorage int64 `xml:"ColdArchiveRealStorage"`

        // The number of Cold Archive objects in the bucket.
        ColdArchiveObjectCount int64 `xml:"ColdArchiveObjectCount"`
        ResultCommon
}

// GetBucketStat Queries the storage capacity of a specified bucket and the number of objects that are stored in the bucket.
func (c *Client) GetBucketStat(ctx context.Context, request *GetBucketStatRequest, optFns ...func(*Options)) (*GetBucketStatResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;GetBucketStatRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "GetBucketStat",
                Method: "GET",
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeDefault,
                },
                Parameters: map[string]string{
                        "stat": "",
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;GetBucketStatResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

type PutBucketAclRequest struct {
        // The name of the bucket containing the objects
        Bucket *string `input:"host,bucket,required"`

        // The access control list (ACL) of the object.
        Acl BucketACLType `input:"header,x-oss-acl,required"`
        RequestCommon
}

type PutBucketAclResult struct {
        ResultCommon
}

// PutBucketAcl You can call this operation to configure or modify the ACL of a bucket.
func (c *Client) PutBucketAcl(ctx context.Context, request *PutBucketAclRequest, optFns ...func(*Options)) (*PutBucketAclResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;PutBucketAclRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "PutBucketAcl",
                Method: "PUT",
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeDefault,
                },
                Parameters: map[string]string{
                        "acl": "",
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;PutBucketAclResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

type GetBucketAclRequest struct {
        // The name of the bucket containing the objects
        Bucket *string `input:"host,bucket,required"`

        RequestCommon
}

type GetBucketAclResult struct {
        // The container that stores the access control list (ACL) information about the bucket.
        ACL *string `xml:"AccessControlList&gt;Grant"`

        // The container that stores information about the bucket owner.
        Owner *Owner `xml:"Owner"`

        ResultCommon
}

// GetBucketAcl You can call this operation to query the ACL of a bucket.
func (c *Client) GetBucketAcl(ctx context.Context, request *GetBucketAclRequest, optFns ...func(*Options)) (*GetBucketAclResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;GetBucketAclRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "GetBucketAcl",
                Method: "GET",
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeDefault,
                },
                Parameters: map[string]string{
                        "acl": "",
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;GetBucketAclResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

type PutBucketVersioningRequest struct {
        // The name of the bucket containing the objects
        Bucket *string `input:"host,bucket,required"`

        VersioningConfiguration *VersioningConfiguration `input:"body,VersioningConfiguration,xml,required"`

        RequestCommon
}

type VersioningConfiguration struct {
        // The versioning state of the bucket. Valid values: Enabled,Suspended
        Status VersioningStatusType `xml:"Status"`
}

type PutBucketVersioningResult struct {
        ResultCommon
}

// PutBucketVersioning Configures the versioning state for a bucket.
func (c *Client) PutBucketVersioning(ctx context.Context, request *PutBucketVersioningRequest, optFns ...func(*Options)) (*PutBucketVersioningResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;PutBucketVersioningRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "PutBucketVersioning",
                Method: "PUT",
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeXML,
                },
                Parameters: map[string]string{
                        "versioning": "",
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;PutBucketVersioningResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

type GetBucketVersioningRequest struct {
        // The name of the bucket containing the objects
        Bucket *string `input:"host,bucket,required"`

        RequestCommon
}

type GetBucketVersioningResult struct {
        // The versioning state of the bucket. Valid values: Enabled,Suspended
        VersionStatus *string `xml:"Status"`

        ResultCommon
}

// GetBucketVersioning You can call this operation to query the versioning state of a bucket.
func (c *Client) GetBucketVersioning(ctx context.Context, request *GetBucketVersioningRequest, optFns ...func(*Options)) (*GetBucketVersioningResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;GetBucketVersioningRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "GetBucketVersioning",
                Method: "GET",
                Parameters: map[string]string{
                        "versioning": "",
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;GetBucketVersioningResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

type ListObjectVersionsRequest struct {
        // The name of the bucket containing the objects
        Bucket *string `input:"host,bucket,required"`

        // The character that is used to group objects by name. If you specify the delimiter parameter in the request,
        // the response contains the CommonPrefixes parameter. The objects whose names contain the same string from
        // the prefix to the next occurrence of the delimiter are grouped as a single result element in CommonPrefixes.
        Delimiter *string `input:"query,delimiter"`

        // Specifies that objects whose names are alphabetically after the value of the key-marker parameter are returned.
        // This parameter can be specified together with version-id-marker.
        // By default, this parameter is left empty.
        KeyMarker *string `input:"query,key-marker"`

        // Specifies that the versions created before the version specified by version-id-marker for the object
        // whose name is specified by key-marker are returned by creation time in descending order.
        // By default, if this parameter is not specified, the results are returned from the latest
        // version of the object whose name is alphabetically after the value of key-marker.
        VersionIdMarker *string `input:"query,version-id-marker"`

        // The maximum number of objects that you want to return. If the list operation cannot be complete at a time
        // because the max-keys parameter is specified, the NextMarker element is included in the response as the marker
        // for the next list operation.
        MaxKeys int32 `input:"query,max-keys"`

        // The prefix that the names of the returned objects must contain.
        Prefix *string `input:"query,prefix"`

        // The encoding type of the content in the response. Valid value: url
        EncodingType *string `input:"query,encoding-type"`

        RequestCommon
}

type ListObjectVersionsResult struct {
        // The name of the bucket.
        Name *string `xml:"Name"`

        // Indicates the object from which the ListObjectVersions (GetBucketVersions) operation starts.
        KeyMarker *string `xml:"KeyMarker"`

        // The version from which the ListObjectVersions (GetBucketVersions) operation starts.
        // This parameter is used together with KeyMarker.
        VersionIdMarker *string `xml:"VersionIdMarker"`

        // If not all results are returned for the request, the NextKeyMarker parameter is included
        // in the response to indicate the key-marker value of the next ListObjectVersions (GetBucketVersions) request.
        NextKeyMarker *string `xml:"NextKeyMarker"`

        // If not all results are returned for the request, the NextVersionIdMarker parameter is included in
        // the response to indicate the version-id-marker value of the next ListObjectVersions (GetBucketVersions) request.
        NextVersionIdMarker *string `xml:"NextVersionIdMarker"`

        // The container that stores delete markers.
        ObjectDeleteMarkers []ObjectDeleteMarkerProperties `xml:"DeleteMarker"`

        // The container that stores the versions of objects, excluding delete markers.
        ObjectVersions []ObjectVersionProperties `xml:"Version"`

        // The prefix contained in the returned object names.
        Prefix *string `xml:"Prefix"`

        // The maximum number of returned objects in the response.
        MaxKeys int32 `xml:"MaxKeys"`

        // The character that is used to group objects by name.
        Delimiter *string `xml:"Delimiter"`

        // Indicates whether the returned results are truncated.
        // true indicates that not all results are returned this time.
        // false indicates that all results are returned this time.
        IsTruncated bool `xml:"IsTruncated"`

        // The encoding type of the content in the response.
        EncodingType *string `xml:"EncodingType"`

        // If the Delimiter parameter is specified in the request, the response contains the CommonPrefixes element.
        CommonPrefixes []CommonPrefix `xml:"CommonPrefixes"`

        ResultCommon
}

type ObjectDeleteMarkerProperties struct {
        // The name of the object.
        Key *string `xml:"Key"`

        // The version ID of the object.
        VersionId *string `xml:"VersionId"`

        // Indicates whether the version is the current version.
        IsLatest bool `xml:"IsLatest"`

        // The time when the returned objects were last modified.
        LastModified *time.Time `xml:"LastModified"`

        // The container that stores information about the bucket owner.
        Owner Owner `xml:"Owner"`
}

type ObjectVersionProperties struct {
        // The name of the object.
        Key *string `xml:"Key"`

        // The version ID of the object.
        VersionId *string `xml:"VersionId"`

        // Indicates whether the version is the current version.
        IsLatest bool `xml:"IsLatest"`

        // The time when the returned objects were last modified.
        LastModified *time.Time `xml:"LastModified"`

        // The type of the returned object.
        Type *string `xml:"Type"`

        // The size of the returned object. Unit: bytes.
        Size int64 `xml:"Size"`

        // The entity tag (ETag) that is generated when an object is created. ETags are used to identify the content of objects.
        ETag *string `xml:"ETag"`

        // The storage class of the object.
        StorageClass *string `xml:"StorageClass"`

        // The container that stores information about the bucket owner.
        Owner *Owner `xml:"Owner"`

        // The restoration status of the object.
        RestoreInfo *string `xml:"RestoreInfo"`
}

// ListObjectVersions Lists the versions of all objects in a bucket, including delete markers.
func (c *Client) ListObjectVersions(ctx context.Context, request *ListObjectVersionsRequest, optFns ...func(*Options)) (*ListObjectVersionsResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;ListObjectVersionsRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "ListObjectVersions",
                Method: "GET",
                Parameters: map[string]string{
                        "versions":      "",
                        "encoding-type": "url",
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;ListObjectVersionsResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml, unmarshalEncodeType); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package oss

import (
        "context"
)

func (c *Client) InvokeOperation(ctx context.Context, input *OperationInput, optFns ...func(*Options)) (*OperationOutput, error) <span class="cov8" title="1">{
        if err := validateInput(input); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return c.invokeOperation(ctx, input, optFns)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package oss

import (
        "context"
        "fmt"
        "io"
        "sort"
        "strconv"
        "time"
)

type PutObjectRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The caching behavior of the web page when the object is downloaded.
        CacheControl *string `input:"header,Cache-Control"`

        // The method that is used to access the object.
        ContentDisposition *string `input:"header,Content-Disposition"`

        // The method that is used to encode the object.
        ContentEncoding *string `input:"header,Content-Encoding"`

        // The size of the data in the HTTP message body. Unit: bytes.
        ContentLength *int64 `input:"header,Content-Length"`

        // The MD5 hash of the object that you want to upload.
        ContentMD5 *string `input:"header,Content-MD5"`

        // A standard MIME type describing the format of the contents.
        ContentType *string `input:"header,Content-Type"`

        // The expiration time of the cache in UTC.
        Expires *string `input:"header,Expires"`

        // Specifies whether the object that is uploaded by calling the PutObject operation
        // overwrites an existing object that has the same name. Valid values: true and false
        ForbidOverwrite *string `input:"header,x-oss-forbid-overwrite"`

        // The encryption method on the server side when an object is created.
        // Valid values: AES256 and KMS
        ServerSideEncryption *string `input:"header,x-oss-server-side-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        // This header is valid only when the x-oss-server-side-encryption header is set to KMS.
        ServerSideDataEncryption *string `input:"header,x-oss-server-side-data-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        SSEKMSKeyId *string `input:"header,x-oss-server-side-encryption-key-id"`

        // The access control list (ACL) of the object.
        Acl ObjectACLType `input:"header,x-oss-object-acl"`

        // The storage class of the object.
        StorageClass StorageClassType `input:"header,x-oss-storage-class"`

        // The metadata of the object that you want to upload.
        Metadata map[string]string `input:"header,x-oss-meta-,usermeta"`

        // The tags that are specified for the object by using a key-value pair.
        // You can specify multiple tags for an object. Example: TagA=A&amp;TagB=B.
        Tagging *string `input:"header,x-oss-tagging"`

        // A callback parameter is a Base64-encoded string that contains multiple fields in the JSON format.
        Callback *string `input:"header,x-oss-callback"`

        // Configure custom parameters by using the callback-var parameter.
        CallbackVar *string `input:"header,x-oss-callback-var"`

        // Specify the speed limit value. The speed limit value ranges from 245760 to 838860800, with a unit of bit/s.
        TrafficLimit int64 `input:"header,x-oss-traffic-limit"`

        RequestCommon
}

type PutObjectResult struct {
        // Content-Md5 for the uploaded object.
        ContentMD5 *string `output:"header,Content-MD5"`

        // Entity tag for the uploaded object.
        ETag *string `output:"header,ETag"`

        // The 64-bit CRC value of the object.
        // This value is calculated based on the ECMA-182 standard.
        HashCRC64 *string `output:"header,x-oss-hash-crc64ecma"`

        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        CallbackResult map[string]any

        ResultCommon
}

// PutObject Uploads a object.
func (c *Client) PutObject(ctx context.Context, request *PutObjectRequest, optFns ...func(*Options)) (*PutObjectResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;PutObjectRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "PutObject",
                Method: "PUT",
                Bucket: request.Bucket,
                Key:    request.Key,
        }
        if err = c.marshalInput(request, input); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if request.Callback != nil </span><span class="cov8" title="1">{
                optFns = append(optFns, callbackResponseHandler)
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;PutObjectResult{}
        var unmarshalFns []func(result any, output *OperationOutput) error
        unmarshalFns = append(unmarshalFns, unmarshalHeader)
        if request.Callback != nil </span><span class="cov8" title="1">{
                unmarshalFns = append(unmarshalFns, unmarshalCallbackBody)
        }</span> else<span class="cov8" title="1"> {
                unmarshalFns = append(unmarshalFns, discardBody)
        }</span>
        <span class="cov8" title="1">if err = c.unmarshalOutput(result, output, unmarshalFns...); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type HTTPRange struct {
        Offset int64
        Count  int64
}

func (r HTTPRange) FormatHTTPRange() *string <span class="cov8" title="1">{
        if r.Offset == 0 &amp;&amp; r.Count == 0 </span><span class="cov0" title="0">{
                return nil // No specified range
        }</span>
        <span class="cov8" title="1">endOffset := "" // if count == CountToEnd (0)
        if r.Count &gt; 0 </span><span class="cov8" title="1">{
                endOffset = strconv.FormatInt((r.Offset+r.Count)-1, 10)
        }</span>
        <span class="cov8" title="1">dataRange := fmt.Sprintf("bytes=%v-%s", r.Offset, endOffset)
        return &amp;dataRange</span>
}

type GetObjectRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // If the ETag specified in the request matches the ETag value of the object,
        // the object and 200 OK are returned. Otherwise, 412 Precondition Failed is returned.
        IfMatch *string `input:"header,If-Match"`

        // If the ETag specified in the request does not match the ETag value of the object,
        // the object and 200 OK are returned. Otherwise, 304 Not Modified is returned.
        IfNoneMatch *string `input:"header,If-None-Match"`

        // If the time specified in this header is earlier than the object modified time or is invalid,
        // the object and 200 OK are returned. Otherwise, 304 Not Modified is returned.
        // The time must be in GMT. Example: Fri, 13 Nov 2015 14:47:53 GMT.
        IfModifiedSince *string `input:"header,If-Modified-Since"`

        // If the time specified in this header is the same as or later than the object modified time,
        // the object and 200 OK are returned. Otherwise, 412 Precondition Failed is returned.
        // The time must be in GMT. Example: Fri, 13 Nov 2015 14:47:53 GMT.
        IfUnmodifiedSince *string `input:"header,If-Unmodified-Since"`

        // The content range of the object to be returned.
        // If the value of Range is valid, the total size of the object and the content range are returned.
        // For example, Content-Range: bytes 0~9/44 indicates that the total size of the object is 44 bytes,
        // and the range of data returned is the first 10 bytes.
        // However, if the value of Range is invalid, the entire object is returned,
        // and the response does not include the Content-Range parameter.
        Range *string `input:"header,Range"`

        // Specify standard behaviors to download data by range
        // If the value is "standard", the download behavior is modified when the specified range is not within the valid range.
        // For an object whose size is 1,000 bytes:
        // 1) If you set Range: bytes to 500-2000, the value at the end of the range is invalid.
        // In this case, OSS returns HTTP status code 206 and the data that is within the range of byte 500 to byte 999.
        // 2) If you set Range: bytes to 1000-2000, the value at the start of the range is invalid.
        // In this case, OSS returns HTTP status code 416 and the InvalidRange error code.
        RangeBehavior *string `input:"header,x-oss-range-behavior"`

        // The cache-control header to be returned in the response.
        ResponseCacheControl *string `input:"query,response-cache-control"`

        // The content-disposition header to be returned in the response.
        ResponseContentDisposition *string `input:"query,response-content-disposition"`

        // The content-encoding header to be returned in the response.
        ResponseContentEncoding *string `input:"query,response-content-encoding"`

        // The content-language header to be returned in the response.
        ResponseContentLanguage *string `input:"query,response-content-language"`

        // The content-type header to be returned in the response.
        ResponseContentType *string `input:"query,response-content-type"`

        // The expires header to be returned in the response.
        ResponseExpires *string `input:"query,response-expires"`

        // VersionId used to reference a specific version of the object.
        VersionId *string `input:"query,versionId"`

        // Specify the speed limit value. The speed limit value ranges from 245760 to 838860800, with a unit of bit/s.
        TrafficLimit int64 `input:"header,x-oss-traffic-limit"`

        RequestCommon
}

type GetObjectResult struct {
        // Size of the body in bytes. -1 indicates that the Content-Length dose not exist.
        ContentLength int64 `output:"header,Content-Length"`

        // The portion of the object returned in the response.
        ContentRange *string `output:"header,Content-Range"`

        // A standard MIME type describing the format of the object data.
        ContentType *string `output:"header,Content-Type"`

        // The entity tag (ETag). An ETag is created when an object is created to identify the content of the object.
        ETag *string `output:"header,ETag"`

        // The time when the returned objects were last modified.
        LastModified *time.Time `output:"header,Last-Modified,time"`

        // The storage class of the object.
        StorageClass *string `output:"header,x-oss-storage-class"`

        // Content-Md5 for the uploaded object.
        ContentMD5 *string `output:"header,Content-MD5"`

        // A map of metadata to store with the object.
        Metadata map[string]string `output:"header,x-oss-meta-,usermeta"`

        // If the requested object is encrypted by using a server-side encryption algorithm based on entropy encoding,
        // OSS automatically decrypts the object and returns the decrypted object after OSS receives the GetObject request.
        // The x-oss-server-side-encryption header is included in the response to indicate
        // the encryption algorithm used to encrypt the object on the server.
        ServerSideEncryption *string `output:"header,x-oss-server-side-encryption"`

        //The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        ServerSideDataEncryption *string `output:"header,x-oss-server-side-data-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        SSEKMSKeyId *string `output:"header,x-oss-server-side-encryption-key-id"`

        // The type of the object.
        ObjectType *string `output:"header,x-oss-object-type"`

        // The position for the next append operation.
        // If the type of the object is Appendable, this header is included in the response.
        NextAppendPosition *string `output:"header,x-oss-next-append-position"`

        // The 64-bit CRC value of the object.
        // This value is calculated based on the ECMA-182 standard.
        HashCRC64 *string `output:"header,x-oss-hash-crc64ecma"`

        // The lifecycle information about the object.
        // If lifecycle rules are configured for the object, this header is included in the response.
        // This header contains the following parameters: expiry-date that indicates the expiration time of the object,
        // and rule-id that indicates the ID of the matched lifecycle rule.
        Expiration *string `output:"header,x-oss-expiration"`

        // The status of the object when you restore an object.
        // If the storage class of the bucket is Archive and a RestoreObject request is submitted,
        Restore *string `output:"header,x-oss-restore"`

        // The result of an event notification that is triggered for the object.
        ProcessStatus *string `output:"header,x-oss-process-status"`

        // The number of tags added to the object.
        // This header is included in the response only when you have read permissions on tags.
        TaggingCount int32 `output:"header,x-oss-tagging-count"`

        // Specifies whether the object retrieved was (true) or was not (false) a Delete  Marker.
        DeleteMarker bool `output:"header,x-oss-delete-marker"`

        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        // Object data.
        Body io.ReadCloser

        ResultCommon
}

func (c *Client) GetObject(ctx context.Context, request *GetObjectRequest, optFns ...func(*Options)) (*GetObjectResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;GetObjectRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "GetObject",
                Method: "GET",
                Bucket: request.Bucket,
                Key:    request.Key,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;GetObjectResult{
                Body: output.Body,
        }
        if err = c.unmarshalOutput(result, output, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type CopyObjectRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The name of the source bucket.
        SourceBucket *string `input:"nop,bucket"`

        // The path of the source object.
        SourceKey *string `input:"nop,key,required"`

        // The version ID of the source object.
        SourceVersionId *string `input:"nop,versionId"`

        // Specifies whether the object that is uploaded by calling the CopyObject operation
        // overwrites an existing object that has the same name. Valid values: true and false
        ForbidOverwrite *string `input:"header,x-oss-forbid-overwrite"`

        // If the ETag specified in the request matches the ETag value of the object,
        // the object and 200 OK are returned. Otherwise, 412 Precondition Failed is returned.
        IfMatch *string `input:"header,x-oss-copy-source-if-match"`

        // If the ETag specified in the request does not match the ETag value of the object,
        // the object and 200 OK are returned. Otherwise, 304 Not Modified is returned.
        IfNoneMatch *string `input:"header,x-oss-copy-source-if-none-match"`

        // If the time specified in this header is earlier than the object modified time or is invalid,
        // the object and 200 OK are returned. Otherwise, 304 Not Modified is returned.
        // The time must be in GMT. Example: Fri, 13 Nov 2015 14:47:53 GMT.
        IfModifiedSince *string `input:"header,x-oss-copy-source-if-modified-since"`

        // If the time specified in this header is the same as or later than the object modified time,
        // the object and 200 OK are returned. Otherwise, 412 Precondition Failed is returned.
        // The time must be in GMT. Example: Fri, 13 Nov 2015 14:47:53 GMT.
        IfUnmodifiedSince *string `input:"header,x-oss-copy-source-if-unmodified-since"`

        // The method that is used to configure the metadata of the destination object.
        // COPY (default): The metadata of the source object is copied to the destination object.
        // The configurations of the x-oss-server-side-encryption
        // header of the source object are not copied to the destination object.
        // The x-oss-server-side-encryption header in the CopyObject request specifies
        // the method used to encrypt the destination object.
        // REPLACE: The metadata specified in the request is used as the metadata of the destination object.
        MetadataDirective *string `input:"header,x-oss-metadata-directive"`

        // The encryption method on the server side when an object is created.
        // Valid values: AES256 and KMS
        ServerSideEncryption *string `input:"header,x-oss-server-side-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        // This header is valid only when the x-oss-server-side-encryption header is set to KMS.
        ServerSideDataEncryption *string `input:"header,x-oss-server-side-data-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        SSEKMSKeyId *string `input:"header,x-oss-server-side-encryption-key-id"`

        // The access control list (ACL) of the object.
        Acl ObjectACLType `input:"header,x-oss-object-acl"`

        // The storage class of the object.
        StorageClass StorageClassType `input:"header,x-oss-storage-class"`

        // The metadata of the object that you want to upload.
        Metadata map[string]string `input:"header,x-oss-meta-,usermeta"`

        // The tags that are specified for the object by using a key-value pair.
        // You can specify multiple tags for an object. Example: TagA=A&amp;TagB=B.
        Tagging *string `input:"header,x-oss-tagging"`

        // The method that is used to configure tags for the destination object.
        // Valid values: Copy (default): The tags of the source object are copied to the destination object.
        // Replace: The tags specified in the request are configured for the destination object.
        TaggingDirective *string `input:"header,x-oss-tagging-directive"`

        // Specify the speed limit value. The speed limit value ranges from  245760 to 838860800, with a unit of bit/s.
        TrafficLimit int64 `input:"header,x-oss-traffic-limit"`

        RequestCommon
}

type CopyObjectResult struct {
        // The 64-bit CRC value of the object.
        // This value is calculated based on the ECMA-182 standard.
        HashCRC64 *string `output:"header,x-oss-hash-crc64ecma"`

        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        // The version ID of the source object.
        SourceVersionId *string `output:"header,x-oss-copy-source-version-id"`

        // If the requested object is encrypted by using a server-side encryption algorithm based on entropy encoding,
        // OSS automatically decrypts the object and returns the decrypted object after OSS receives the GetObject request.
        // The x-oss-server-side-encryption header is included in the response to indicate
        // the encryption algorithm used to encrypt the object on the server.
        ServerSideEncryption *string `output:"header,x-oss-server-side-encryption"`

        //The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        ServerSideDataEncryption *string `output:"header,x-oss-server-side-data-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        SSEKMSKeyId *string `output:"header,x-oss-server-side-encryption-key-id"`

        // The time when the returned objects were last modified.
        LastModified *time.Time `xml:"LastModified"`

        // The entity tag (ETag). An ETag is created when an object is created to identify the content of the object.
        ETag *string `xml:"ETag"`

        ResultCommon
}

// CopyObject Copies objects within a bucket or between buckets in the same region
func (c *Client) CopyObject(ctx context.Context, request *CopyObjectRequest, optFns ...func(*Options)) (*CopyObjectResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;CopyObjectRequest{}
        }</span>

        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "CopyObject",
                Method: "PUT",
                Bucket: request.Bucket,
                Key:    request.Key,
                Headers: map[string]string{
                        "x-oss-copy-source": encodeSourceObject(request),
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;CopyObjectResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type AppendObjectRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The position from which the AppendObject operation starts.
        // Each time an AppendObject operation succeeds, the x-oss-next-append-position header is included in
        // the response to specify the position from which the next AppendObject operation starts.
        Position *int64 `input:"query,position,required"`

        // The caching behavior of the web page when the object is downloaded.
        CacheControl *string `input:"header,Cache-Control"`

        // The method that is used to access the object.
        ContentDisposition *string `input:"header,Content-Disposition"`

        // The method that is used to encode the object.
        ContentEncoding *string `input:"header,Content-Encoding"`

        // The size of the data in the HTTP message body. Unit: bytes.
        ContentLength *int64 `input:"header,Content-Length"`

        // The MD5 hash of the object that you want to upload.
        ContentMD5 *string `input:"header,Content-MD5"`

        // The expiration time of the cache in UTC.
        Expires *string `input:"header,Expires"`

        // Specifies whether the object that is uploaded by calling the PutObject operation
        // overwrites an existing object that has the same name. Valid values: true and false
        ForbidOverwrite *string `input:"header,x-oss-forbid-overwrite"`

        // The encryption method on the server side when an object is created.
        // Valid values: AES256 and KMS
        ServerSideEncryption *string `input:"header,x-oss-server-side-encryption"`

        //The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        //This header is valid only when the x-oss-server-side-encryption header is set to KMS.
        ServerSideDataEncryption *string `input:"header,x-oss-server-side-data-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        SSEKMSKeyId *string `input:"header,x-oss-server-side-encryption-key-id"`

        // The access control list (ACL) of the object.
        Acl ObjectACLType `input:"header,x-oss-object-acl"`

        // The storage class of the object.
        StorageClass StorageClassType `input:"header,x-oss-storage-class"`

        // The metadata of the object that you want to upload.
        Metadata map[string]string `input:"header,x-oss-meta-,usermeta"`

        // The tags that are specified for the object by using a key-value pair.
        // You can specify multiple tags for an object. Example: TagA=A&amp;TagB=B.
        Tagging *string `input:"header,x-oss-tagging"`

        // Specify the speed limit value. The speed limit value ranges from  245760 to 838860800, with a unit of bit/s.
        TrafficLimit int64 `input:"header,x-oss-traffic-limit"`

        RequestCommon
}

type AppendObjectResult struct {
        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        // The 64-bit CRC value of the object.
        // This value is calculated based on the ECMA-182 standard.
        HashCRC64 *string `output:"header,x-oss-hash-crc64ecma"`

        // The position that must be provided in the next request, which is the current length of the object.
        NextPosition int64 `output:"header,x-oss-next-append-position"`

        // The encryption method on the server side when an object is created.
        // Valid values: AES256 and KMS
        ServerSideEncryption *string `output:"header,x-oss-server-side-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        // This header is valid only when the x-oss-server-side-encryption header is set to KMS.
        ServerSideDataEncryption *string `output:"header,x-oss-server-side-data-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        SSEKMSKeyId *string `output:"header,x-oss-server-side-encryption-key-id"`

        // A map of metadata to store with the object.
        Metadata map[string]string `output:"header,x-oss-meta-,usermeta"`

        ResultCommon
}

// AppendObject Uploads an object by appending the object to an existing object.
// Objects created by using the AppendObject operation are appendable objects.
func (c *Client) AppendObject(ctx context.Context, request *AppendObjectRequest, optFns ...func(*Options)) (*AppendObjectResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;AppendObjectRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName:     "AppendObject",
                Method:     "POST",
                Parameters: map[string]string{"append": ""},
                Bucket:     request.Bucket,
                Key:        request.Key,
        }
        if err = c.marshalInput(request, input); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;AppendObjectResult{}
        if err = c.unmarshalOutput(result, output, discardBody, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type DeleteObjectRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The version ID of the source object.
        VersionId *string `input:"query,versionId"`

        RequestCommon
}

type DeleteObjectResult struct {
        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        // Specifies whether the object retrieved was (true) or was not (false) a Delete  Marker.
        DeleteMarker bool `output:"header,x-oss-delete-marker"`

        ResultCommon
}

// DeleteObject Deletes an object.
func (c *Client) DeleteObject(ctx context.Context, request *DeleteObjectRequest, optFns ...func(*Options)) (*DeleteObjectResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;DeleteObjectRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "DeleteObject",
                Method: "DELETE",
                Bucket: request.Bucket,
                Key:    request.Key,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;DeleteObjectResult{}
        if err = c.unmarshalOutput(result, output, discardBody, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type DeleteMultipleObjectsRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The encoding type of the object names in the response. Valid value: url
        EncodingType *string `input:"query,encoding-type"`

        // The size of the data in the HTTP message body. Unit: bytes.
        ContentLength int64 `input:"header,Content-Length"`

        // The container that stores information about you want to delete objects.
        Objects []DeleteObject `input:"nop,objects,required"`

        // Specifies whether to enable the Quiet return mode.
        // The DeleteMultipleObjects operation provides the following return modes: Valid value: true,false
        Quiet bool

        RequestCommon
}

type DeleteObject struct {
        // The name of the object that you want to delete.
        Key *string `xml:"Key"`

        // The version ID of the object that you want to delete.
        VersionId *string `xml:"VersionId"`
}

type DeleteMultipleObjectsResult struct {
        // The container that stores information about the deleted objects.
        DeletedObjects []DeletedInfo `xml:"Deleted"`

        // The encoding type of the name of the deleted object in the response.
        // If encoding-type is specified in the request, the object name is encoded in the returned result.
        EncodingType *string `xml:"EncodingType"`

        ResultCommon
}

type DeletedInfo struct {
        // The name of the deleted object.
        Key *string `xml:"Key"`

        // The version ID of the object that you deleted.
        VersionId *string `xml:"VersionId"`

        // Indicates whether the deleted version is a delete marker.
        DeleteMarker bool `xml:"DeleteMarker"`

        // The version ID of the delete marker.
        DeleteMarkerVersionId *string `xml:"DeleteMarkerVersionId"`
}

// DeleteMultipleObjects Deletes multiple objects from a bucket.
func (c *Client) DeleteMultipleObjects(ctx context.Context, request *DeleteMultipleObjectsRequest, optFns ...func(*Options)) (*DeleteMultipleObjectsResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;DeleteMultipleObjectsRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "DeleteMultipleObjects",
                Method: "POST",
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeXML,
                },
                Parameters: map[string]string{
                        "delete":        "",
                        "encoding-type": "url",
                },
                Bucket: request.Bucket,
        }
        if err = c.marshalInput(request, input, marshalDeleteObjects, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;DeleteMultipleObjectsResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml, unmarshalHeader, unmarshalEncodeType); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

type HeadObjectRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The version ID of the source object.
        VersionId *string `input:"query,versionId"`

        // If the ETag specified in the request matches the ETag value of the object,
        // the object and 200 OK are returned. Otherwise, 412 Precondition Failed is returned.
        IfMatch *string `input:"header,If-Match"`

        // If the ETag specified in the request does not match the ETag value of the object,
        // the object and 200 OK are returned. Otherwise, 304 Not Modified is returned.
        IfNoneMatch *string `input:"header,If-None-Match"`

        // If the time specified in this header is earlier than the object modified time or is invalid,
        // the object and 200 OK are returned. Otherwise, 304 Not Modified is returned.
        // The time must be in GMT. Example: Fri, 13 Nov 2015 14:47:53 GMT.
        IfModifiedSince *string `input:"header,If-Modified-Since"`

        // If the time specified in this header is the same as or later than the object modified time,
        // the object and 200 OK are returned. Otherwise, 412 Precondition Failed is returned.
        // The time must be in GMT. Example: Fri, 13 Nov 2015 14:47:53 GMT.
        IfUnmodifiedSince *string `input:"header,If-Unmodified-Since"`

        RequestCommon
}

type HeadObjectResult struct {
        // Size of the body in bytes. -1 indicates that the Content-Length dose not exist.
        ContentLength int64 `output:"header,Content-Length"`

        // A standard MIME type describing the format of the object data.
        ContentType *string `output:"header,Content-Type"`

        // The entity tag (ETag). An ETag is created when an object is created to identify the content of the object.
        ETag *string `output:"header,ETag"`

        // The time when the returned objects were last modified.
        LastModified *time.Time `output:"header,Last-Modified,time"`

        // The storage class of the object.
        StorageClass *string `output:"header,x-oss-storage-class"`

        // Content-Md5 for the uploaded object.
        ContentMD5 *string `output:"header,Content-MD5"`

        // A map of metadata to store with the object.
        Metadata map[string]string `output:"header,x-oss-meta-,usermeta"`

        // If the requested object is encrypted by using a server-side encryption algorithm based on entropy encoding,
        // OSS automatically decrypts the object and returns the decrypted object after OSS receives the GetObject request.
        // The x-oss-server-side-encryption header is included in the response to indicate
        // the encryption algorithm used to encrypt the object on the server.
        ServerSideEncryption *string `output:"header,x-oss-server-side-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        ServerSideDataEncryption *string `output:"header,x-oss-server-side-data-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        SSEKMSKeyId *string `output:"header,x-oss-server-side-encryption-key-id"`

        // The type of the object.
        ObjectType *string `output:"header,x-oss-object-type"`

        // The position for the next append operation.
        // If the type of the object is Appendable, this header is included in the response.
        NextAppendPosition *string `output:"header,x-oss-next-append-position"`

        // The 64-bit CRC value of the object.
        // This value is calculated based on the ECMA-182 standard.
        HashCRC64 *string `output:"header,x-oss-hash-crc64ecma"`

        // The lifecycle information about the object.
        // If lifecycle rules are configured for the object, this header is included in the response.
        // This header contains the following parameters: expiry-date that indicates the expiration time of the object,
        // and rule-id that indicates the ID of the matched lifecycle rule.
        Expiration *string `output:"header,x-oss-expiration"`

        // The status of the object when you restore an object.
        // If the storage class of the bucket is Archive and a RestoreObject request is submitted,
        Restore *string `output:"header,x-oss-restore"`

        // The result of an event notification that is triggered for the object.
        ProcessStatus *string `output:"header,x-oss-process-status"`

        // The requester. This header is included in the response if the pay-by-requester mode
        // is enabled for the bucket and the requester is not the bucket owner. The value of this header is requester
        RequestCharged *string `output:"header,x-oss-request-charged"`

        // The number of tags added to the object.
        // This header is included in the response only when you have read permissions on tags.
        TaggingCount int32 `output:"header,x-oss-tagging-count"`

        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        // The origins allowed for cross-origin resource sharing (CORS).
        // If a CORS rule is configured for the bucket that stores the object and the Origin header
        // in the request meets the CORS rule, this header is included in the response.
        AllowOrigin *string `output:"header,Access-Control-Allow-Origin"`

        // The methods allowed for CORS. If a CORS rule is configured for the bucket that stores the object
        // and the Access-Control-Request-Method header in the request meets the CORS rule, this header is included in the response.
        AllowMethods *string `output:"header,Access-Control-Allow-Methods"`

        // The maximum caching period for CORS. If a CORS rule is configured for the bucket that stores
        // the object and the request meets the CORS rule, this header is included in the response.
        AllowAge *string `output:"header,Access-Control-Allow-Age"`

        // The headers allowed for CORS. If a CORS rule is configured for the bucket that stores
        // the object and the request meets the CORS rule, this header is included in the response
        AllowHeaders *string `output:"header,Access-Control-Allow-Headers"`

        // The headers that can be accessed by JavaScript applications on the client.
        // If a CORS rule is configured for the bucket that stores the object and the request meets
        // the CORS rule, this header is included in the response
        ExposeHeaders *string `output:"header,Access-Control-Expose-Headers"`

        ResultCommon
}

// HeadObject Queries information about all objects in a bucket.
func (c *Client) HeadObject(ctx context.Context, request *HeadObjectRequest, optFns ...func(*Options)) (*HeadObjectResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;HeadObjectRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "HeadObject",
                Method: "HEAD",
                Bucket: request.Bucket,
                Key:    request.Key,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;HeadObjectResult{}
        if err = c.unmarshalOutput(result, output, discardBody, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type GetObjectMetaRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The version ID of the source object.
        VersionId *string `input:"query,versionId"`

        RequestCommon
}

type GetObjectMetaResult struct {
        // Size of the body in bytes. -1 indicates that the Content-Length dose not exist.
        ContentLength int64 `output:"header,Content-Length"`

        // The entity tag (ETag). An ETag is created when an object is created to identify the content of the object.
        ETag *string `output:"header,ETag"`

        // The time when the returned objects were last modified.
        LastModified *time.Time `output:"header,Last-Modified,time"`

        // The time when the object was last accessed.
        LastAccessTime *time.Time `output:"header,x-oss-last-access-time,time"`

        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        // The 64-bit CRC value of the object.
        // This value is calculated based on the ECMA-182 standard.
        HashCRC64 *string `output:"header,x-oss-hash-crc64ecma"`

        ResultCommon
}

// GetObjectMeta Queries the metadata of an object, including ETag, Size, and LastModified.
// The content of the object is not returned.
func (c *Client) GetObjectMeta(ctx context.Context, request *GetObjectMetaRequest, optFns ...func(*Options)) (*GetObjectMetaResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;GetObjectMetaRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "GetObjectMeta",
                Method: "HEAD",
                Bucket: request.Bucket,
                Key:    request.Key,
                Parameters: map[string]string{
                        "objectMeta": "",
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;GetObjectMetaResult{}
        if err = c.unmarshalOutput(result, output, discardBody, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type RestoreObjectRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The version ID of the source object.
        VersionId *string `input:"query,versionId"`

        // The container that stores information about the RestoreObject request.
        RestoreRequest *RestoreRequest `input:"body,RestoreRequest,xml"`

        RequestCommon
}

type RestoreRequest struct {
        // The duration within which the restored object remains in the restored state.
        Days int32 `xml:"Days"`

        // The restoration priority of Cold Archive or Deep Cold Archive objects. Valid values:Expedited,Standard,Bulk
        Tier *string `xml:"JobParameters&gt;Tier"`
}

type RestoreObjectResult struct {
        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        // The restoration priority.
        // This header is displayed only for the Cold Archive or Deep Cold Archive object in the restored state.
        RestorePriority *string `output:"header,x-oss-object-restore-priority"`

        ResultCommon
}

// RestoreObject Restores Archive, Cold Archive, or Deep Cold Archive objects.
func (c *Client) RestoreObject(ctx context.Context, request *RestoreObjectRequest, optFns ...func(*Options)) (*RestoreObjectResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;RestoreObjectRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "RestoreObject",
                Method: "POST",
                Bucket: request.Bucket,
                Key:    request.Key,
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeXML,
                },
                Parameters: map[string]string{
                        "restore": "",
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;RestoreObjectResult{}
        if err = c.unmarshalOutput(result, output, discardBody, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type PutObjectAclRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The access control list (ACL) of the object.
        Acl ObjectACLType `input:"header,x-oss-object-acl,required"`

        // The version ID of the source object.
        VersionId *string `input:"query,versionId"`

        RequestCommon
}

type PutObjectAclResult struct {
        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        ResultCommon
}

// PutObjectAcl You can call this operation to modify the access control list (ACL) of an object.
func (c *Client) PutObjectAcl(ctx context.Context, request *PutObjectAclRequest, optFns ...func(*Options)) (*PutObjectAclResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;PutObjectAclRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "PutObjectAcl",
                Method: "PUT",
                Bucket: request.Bucket,
                Key:    request.Key,
                Parameters: map[string]string{
                        "acl": "",
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;PutObjectAclResult{}
        if err = c.unmarshalOutput(result, output, discardBody, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type GetObjectAclRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The version ID of the source object.
        VersionId *string `input:"query,versionId"`

        RequestCommon
}

type GetObjectAclResult struct {
        // The ACL of the object. Default value: default.
        ACL *string `xml:"AccessControlList&gt;Grant"`

        // The container that stores information about the object owner.
        Owner *Owner `xml:"Owner"`

        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        ResultCommon
}

// GetObjectAcl Queries the access control list (ACL) of an object in a bucket.
func (c *Client) GetObjectAcl(ctx context.Context, request *GetObjectAclRequest, optFns ...func(*Options)) (*GetObjectAclResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;GetObjectAclRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "GetObjectAcl",
                Method: "GET",
                Bucket: request.Bucket,
                Key:    request.Key,
                Parameters: map[string]string{
                        "acl": "",
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;GetObjectAclResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type InitiateMultipartUploadRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The encoding type of the object names in the response. Valid value: url
        EncodingType *string `input:"query,encoding-type"`

        // The caching behavior of the web page when the object is downloaded.
        CacheControl *string `input:"header,Cache-Control"`

        // The method that is used to access the object.
        ContentDisposition *string `input:"header,Content-Disposition"`

        // The method that is used to encode the object.
        ContentEncoding *string `input:"header,Content-Encoding"`

        // A standard MIME type describing the format of the contents.
        ContentType *string `input:"header,Content-Type"`

        // The expiration time of the cache in UTC.
        Expires *string `input:"header,Expires"`

        // Specifies whether the InitiateMultipartUpload operation overwrites
        // the existing object that has the same name as the object that you want to upload.
        // Valid values: true and false
        ForbidOverwrite *string `input:"header,x-oss-forbid-overwrite"`

        // The encryption method on the server side when an object is created.
        // Valid values: AES256 and KMS
        ServerSideEncryption *string `input:"header,x-oss-server-side-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        // This header is valid only when the x-oss-server-side-encryption header is set to KMS.
        ServerSideDataEncryption *string `input:"header,x-oss-server-side-data-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        SSEKMSKeyId *string `input:"header,x-oss-server-side-encryption-key-id"`

        // The storage class of the object.
        StorageClass StorageClassType `input:"header,x-oss-storage-class"`

        // The metadata of the object that you want to upload.
        Metadata map[string]string `input:"header,x-oss-meta-,usermeta"`

        // The tags that are specified for the object by using a key-value pair.
        // You can specify multiple tags for an object. Example: TagA=A&amp;TagB=B.
        Tagging *string `input:"header,x-oss-tagging"`

        RequestCommon
}

type InitiateMultipartUploadResult struct {
        // The name of the bucket to which the object is uploaded by the multipart upload task.
        Bucket *string `xml:"Bucket"`

        // The name of the object that is uploaded by the multipart upload task.
        Key *string `xml:"Key"`

        // The upload ID that uniquely identifies the multipart upload task.
        UploadId *string `xml:"UploadId"`

        // The encoding type of the object names in the response. Valid value: url
        EncodingType *string `xml:"EncodingType"`

        ResultCommon
}

// InitiateMultipartUpload Initiates a multipart upload task before you can upload data in parts to Object Storage Service (OSS).
func (c *Client) InitiateMultipartUpload(ctx context.Context, request *InitiateMultipartUploadRequest, optFns ...func(*Options)) (*InitiateMultipartUploadResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;InitiateMultipartUploadRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "InitiateMultipartUpload",
                Method: "POST",
                Bucket: request.Bucket,
                Key:    request.Key,
                Parameters: map[string]string{
                        "uploads":       "",
                        "encoding-type": "url",
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;InitiateMultipartUploadResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml, unmarshalEncodeType); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type UploadPartRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,uploadId,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // Each uploaded part is identified by a number.
        // Value: 1-10000
        //The size limit of a single part is between 100 KB and 5 GB.
        PartNumber int32 `input:"query,partNumber,required"`

        // The ID of the multipart upload task.
        UploadId *string `input:"query,uploadId,required"`

        // The MD5 hash of the object that you want to upload.
        ContentMD5 *string `input:"header,Content-MD5"`

        // Specify the speed limit value. The speed limit value ranges from  245760 to 838860800, with a unit of bit/s.
        TrafficLimit int64 `input:"header,x-oss-traffic-limit"`

        RequestCommon
}

type UploadPartResult struct {
        // Entity tag for the uploaded part.
        ETag *string `output:"header,ETag"`

        // The MD5 hash of the part that you want to upload.
        ContentMD5 *string `output:"header,Content-MD5"`

        // The 64-bit CRC value of the part.
        // This value is calculated based on the ECMA-182 standard.
        HashCRC64 *string `output:"header,x-oss-hash-crc64ecma"`

        ResultCommon
}

// UploadPart Call the UploadPart interface to upload data in blocks (parts) based on the specified Object name and uploadId.
func (c *Client) UploadPart(ctx context.Context, request *UploadPartRequest, optFns ...func(*Options)) (*UploadPartResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;UploadPartRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "UploadPart",
                Method: "PUT",
                Bucket: request.Bucket,
                Key:    request.Key,
        }
        if err = c.marshalInput(request, input); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;UploadPartResult{}
        if err = c.unmarshalOutput(result, output, discardBody, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type UploadPartCopyRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,uploadId,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // Each uploaded part is identified by a number.
        // Value: 1-10000
        //The size limit of a single part is between 100 KB and 5 GB.
        PartNumber int32 `input:"query,partNumber,required"`

        // The ID of the multipart upload task.
        UploadId *string `input:"query,uploadId,required"`

        // The name of the source bucket.
        SourceBucket *string `input:"nop,bucket"`

        // The path of the source object.
        SourceKey *string `input:"nop,key,required"`

        // The version ID of the source object.
        SourceVersionId *string `input:"nop,versionId"`

        // The range of bytes to copy data from the source object.
        Range *string `input:"header,x-oss-copy-source-range"`

        // The copy operation condition. If the ETag value of the source object is
        // the same as the ETag value provided by the user, OSS copies data. Otherwise,
        // OSS returns 412 Precondition Failed.
        IfMatch *string `input:"header,x-oss-copy-source-if-match"`

        // The object transfer condition. If the input ETag value does not match the ETag value of the object
        // the system transfers the object normally and returns 200 OK. Otherwise, OSS returns 304 Not Modified.
        IfNoneMatch *string `input:"header,x-oss-copy-source-if-none-match"`

        // The object transfer condition. If the specified time is earlier than the actual modified time of the object,
        // the system transfers the object normally and returns 200 OK. Otherwise, OSS returns 304 Not Modified.
        // The time must be in GMT. Example: Fri, 13 Nov 2015 14:47:53 GMT.
        IfModifiedSince *string `input:"header,x-oss-copy-source-if-modified-since"`

        // The object transfer condition. If the specified time is the same as or later than the actual modified time of the object,
        // OSS transfers the object normally and returns 200 OK. Otherwise, OSS returns 412 Precondition Failed.
        // The time must be in GMT. Example: Fri, 13 Nov 2015 14:47:53 GMT.
        IfUnmodifiedSince *string `input:"header,x-oss-copy-source-if-unmodified-since"`

        // Specify the speed limit value. The speed limit value ranges from  245760 to 838860800, with a unit of bit/s.
        TrafficLimit int64 `input:"header,x-oss-traffic-limit"`

        RequestCommon
}

type UploadPartCopyResult struct {
        // The time when the returned objects were last modified.
        LastModified *time.Time `xml:"LastModified"`

        // Entity tag for the uploaded part.
        ETag *string `xml:"ETag"`

        // The version ID of the source object.
        VersionId *string `output:"header,x-oss-copy-source-version-id"`

        ResultCommon
}

// UploadPartCopy You can call this operation to copy data from an existing object to upload a part by adding a x-oss-copy-request header to UploadPart.
func (c *Client) UploadPartCopy(ctx context.Context, request *UploadPartCopyRequest, optFns ...func(*Options)) (*UploadPartCopyResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;UploadPartCopyRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "UploadPartCopy",
                Method: "PUT",
                Bucket: request.Bucket,
                Key:    request.Key,
                Headers: map[string]string{
                        "x-oss-copy-source": encodeSourceObject(request),
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;UploadPartCopyResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type CompleteMultipartUploadRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,uploadId,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The ID of the multipart upload task.
        UploadId *string `input:"query,uploadId,required"`

        // The encoding type of the object names in the response. Valid value: url
        EncodingType *string `input:"query,encoding-type"`

        // Specifies whether the object that is uploaded by calling the PutObject operation
        // overwrites an existing object that has the same name. Valid values: true and false
        ForbidOverwrite *string `input:"header,x-oss-forbid-overwrite"`

        // Specifies whether to list all parts that are uploaded by using the current upload ID. Valid value: yes
        CompleteAll *string `input:"header,x-oss-complete-all"`

        // The container that stores the content of the CompleteMultipartUpload
        CompleteMultipartUpload *CompleteMultipartUpload `input:"body,CompleteMultipartUpload,xml"`

        // A callback parameter is a Base64-encoded string that contains multiple fields in the JSON format.
        Callback *string `input:"header,x-oss-callback"`

        // Configure custom parameters by using the callback-var parameter.
        CallbackVar *string `input:"header,x-oss-callback-var"`

        RequestCommon
}

type UploadPart struct {
        // The number of parts.
        PartNumber int32 `xml:"PartNumber"`

        // The ETag values that are returned by OSS after parts are uploaded.
        ETag *string `xml:"ETag"`
}

type CompleteMultipartUpload struct {
        Parts []UploadPart `xml:"Part"`
}
type UploadParts []UploadPart

func (slice UploadParts) Len() int <span class="cov8" title="1">{
        return len(slice)
}</span>
func (slice UploadParts) Less(i, j int) bool <span class="cov8" title="1">{
        return slice[i].PartNumber &lt; slice[j].PartNumber
}</span>
func (slice UploadParts) Swap(i, j int) <span class="cov8" title="1">{
        slice[i], slice[j] = slice[j], slice[i]
}</span>

type CompleteMultipartUploadResult struct {
        // The version ID of the source object.
        VersionId *string `output:"header,x-oss-version-id"`

        // The 64-bit CRC value of the object.
        // This value is calculated based on the ECMA-182 standard.
        HashCRC64 *string `output:"header,x-oss-hash-crc64ecma"`

        // The encoding type of the name of the deleted object in the response.
        // If encoding-type is specified in the request, the object name is encoded in the returned result.
        EncodingType *string `xml:"EncodingType"`

        // The URL that is used to access the uploaded object.
        Location *string `xml:"Location"`

        // The name of the bucket.
        Bucket *string `xml:"Bucket"`

        // The name of the uploaded object.
        Key *string `xml:"Key"`

        // The ETag that is generated when an object is created.
        // ETags are used to identify the content of objects.
        ETag *string `xml:"ETag"`

        CallbackResult map[string]any

        ResultCommon
}

// CompleteMultipartUpload Completes the multipart upload task of an object after all parts of the object are uploaded.
func (c *Client) CompleteMultipartUpload(ctx context.Context, request *CompleteMultipartUploadRequest, optFns ...func(*Options)) (*CompleteMultipartUploadResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;CompleteMultipartUploadRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "CompleteMultipartUpload",
                Method: "POST",
                Bucket: request.Bucket,
                Key:    request.Key,
                Parameters: map[string]string{
                        "encoding-type": "url",
                },
        }
        if request.CompleteMultipartUpload != nil &amp;&amp; len(request.CompleteMultipartUpload.Parts) &gt; 0 </span><span class="cov8" title="1">{
                sort.Sort(UploadParts(request.CompleteMultipartUpload.Parts))
        }</span>
        <span class="cov8" title="1">if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if request.Callback != nil </span><span class="cov8" title="1">{
                optFns = append(optFns, callbackResponseHandler)
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;CompleteMultipartUploadResult{}
        var unmarshalFns []func(result any, output *OperationOutput) error
        unmarshalFns = append(unmarshalFns, unmarshalHeader)
        if request.Callback != nil </span><span class="cov8" title="1">{
                unmarshalFns = append(unmarshalFns, unmarshalCallbackBody)
        }</span> else<span class="cov8" title="1"> {
                unmarshalFns = append(unmarshalFns, unmarshalBodyXml, unmarshalEncodeType)
        }</span>
        <span class="cov8" title="1">if err = c.unmarshalOutput(result, output, unmarshalFns...); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

type AbortMultipartUploadRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,uploadId,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The ID of the multipart upload task.
        UploadId *string `input:"query,uploadId,required"`

        RequestCommon
}

type AbortMultipartUploadResult struct {
        ResultCommon
}

// AbortMultipartUpload Cancels a multipart upload task and deletes the parts uploaded in the task.
func (c *Client) AbortMultipartUpload(ctx context.Context, request *AbortMultipartUploadRequest, optFns ...func(*Options)) (*AbortMultipartUploadResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;AbortMultipartUploadRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "AbortMultipartUpload",
                Method: "DELETE",
                Bucket: request.Bucket,
                Key:    request.Key,
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;AbortMultipartUploadResult{}
        if err = c.unmarshalOutput(result, output, discardBody); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type ListMultipartUploadsRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,uploadId,required"`

        // The character that is used to group objects by name. If you specify the delimiter parameter in the request,
        // the response contains the CommonPrefixes parameter. The objects whose names contain the same string from
        // the prefix to the next occurrence of the delimiter are grouped as a single result element in CommonPrefixes.
        Delimiter *string `input:"query,delimiter"`

        // The encoding type of the content in the response. Valid value: url
        EncodingType *string `input:"query,encoding-type"`

        // This parameter is used together with the upload-id-marker parameter to specify
        // the position from which the next list begins.
        KeyMarker *string `input:"query,key-marker"`

        // The maximum number of multipart upload tasks that can be returned for the current request.
        // Default value: 1000. Maximum value: 1000.
        MaxUploads int32 `input:"query,max-uploads"`

        // The prefix that the names of the returned objects must contain.
        Prefix *string `input:"query,prefix"`

        // The upload ID of the multipart upload task after which the list begins.
        // This parameter is used together with the key-marker parameter.
        UploadIdMarker *string `input:"query,upload-id-marker"`

        RequestCommon
}

type ListMultipartUploadsResult struct {
        // The method used to encode the object name in the response.
        // If encoding-type is specified in the request, values of those elements including
        // Delimiter, KeyMarker, Prefix, NextKeyMarker, and Key are encoded in the returned result.
        EncodingType *string `xml:"EncodingType"`

        // The name of the bucket.
        Bucket *string `xml:"Bucket"`

        // The name of the object that corresponds to the multipart upload task after which the list begins.
        KeyMarker *string `xml:"KeyMarker"`

        // The upload ID of the multipart upload task after which the list begins.
        UploadIdMarker *string `xml:"UploadIdMarker"`

        // The upload ID of the multipart upload task after which the list begins.
        NextKeyMarker *string `xml:"NextKeyMarker"`

        // The NextUploadMarker value that is used for the UploadMarker value in
        // the next request if the response does not contain all required results.
        NextUploadIdMarker *string `xml:"NextUploadIdMarker"`

        // The character that is used to group objects by name.
        Delimiter *string `xml:"Delimiter"`

        // The prefix contained in the returned object names.
        Prefix *string `xml:"Prefix"`

        // The maximum number of multipart upload tasks returned by OSS.
        MaxUploads int32 `xml:"MaxUploads"`

        // Indicates whether the list of multipart upload tasks returned in the response is truncated.
        // true: Only part of the results are returned this time.
        // false: All results are returned.
        IsTruncated bool `xml:"IsTruncated"`

        Uploads []Upload `xml:"Upload"`

        ResultCommon
}

type Upload struct {
        // The name of the object for which a multipart upload task was initiated.
        Key *string `xml:"Key"`

        // The ID of the multipart upload task
        UploadId *string `xml:"UploadId"`

        // The time when the multipart upload task was initialized.
        Initiated *time.Time `xml:"Initiated"`
}

// ListMultipartUploads Lists all multipart upload tasks in progress. The tasks are not completed or canceled.
func (c *Client) ListMultipartUploads(ctx context.Context, request *ListMultipartUploadsRequest, optFns ...func(*Options)) (*ListMultipartUploadsResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;ListMultipartUploadsRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "ListMultipartUploads",
                Method: "GET",
                Bucket: request.Bucket,
                Parameters: map[string]string{
                        "encoding-type": "url",
                        "uploads":       "",
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;ListMultipartUploadsResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml, unmarshalEncodeType); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type ListPartsRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,uploadId,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The ID of the multipart upload task.
        UploadId *string `input:"query,uploadId,required"`

        // The encoding type of the content in the response. Valid value: url
        EncodingType *string `input:"query,encoding-type"`

        // The maximum number of parts that can be returned by OSS.
        // Default value: 1000. Maximum value: 1000.
        MaxParts int32 `input:"query,max-parts"`

        // The position from which the list starts.
        // All parts whose part numbers are greater than the value of this parameter are listed.
        PartNumberMarker int32 `input:"query,part-number-marker"`

        RequestCommon
}

type ListPartsResult struct {
        // The method used to encode the object name in the response.
        // If encoding-type is specified in the request, values of those elements including
        // Delimiter, KeyMarker, Prefix, NextKeyMarker, and Key are encoded in the returned result.
        EncodingType *string `xml:"EncodingType"`

        // The name of the bucket.
        Bucket *string `xml:"Bucket"`

        // The name of the object that corresponds to the multipart upload task after which the list begins.
        Key *string `xml:"Key"`

        // The ID of the upload task.
        UploadId *string `xml:"UploadId"`

        // The position from which the list starts.
        // All parts whose part numbers are greater than the value of this parameter are listed.
        PartNumberMarker int32 `xml:"PartNumberMarker"`

        // The NextPartNumberMarker value that is used for the PartNumberMarker value in a subsequent
        // request when the response does not contain all required results.
        NextPartNumberMarker int32 `xml:"NextPartNumberMarker"`

        // he maximum number of parts in the response.
        MaxParts int32 `xml:"MaxParts"`

        // Indicates whether the list of parts returned in the response has been truncated.
        // true: Only part of the results are returned this time.
        // false: All results are returned.
        IsTruncated bool `xml:"IsTruncated"`

        // The storage class of the object.
        StorageClass *string `xml:"StorageClass"`

        Parts []Part `xml:"Part"`

        ResultCommon
}

type Part struct {
        // The number that identifies a part.
        PartNumber int32 `xml:"PartNumber"`

        // The ETag value of the content of the uploaded part.
        ETag *string `xml:"ETag"`

        // The time when the part was uploaded.
        LastModified *time.Time `xml:"LastModified"`

        // The size of the uploaded parts.
        Size int64 `xml:"Size"`

        // The 64-bit CRC value of the object.
        // This value is calculated based on the ECMA-182 standard.
        HashCRC64 *string `xml:"HashCrc64ecma"`
}

// ListParts Lists all parts that are uploaded by using a specified upload ID.
func (c *Client) ListParts(ctx context.Context, request *ListPartsRequest, optFns ...func(*Options)) (*ListPartsResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;ListPartsRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "ListParts",
                Method: "GET",
                Bucket: request.Bucket,
                Key:    request.Key,
                Parameters: map[string]string{
                        "encoding-type": "url",
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;ListPartsResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml, unmarshalEncodeType); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type PutSymlinkRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The destination object to which the symbolic link points.
        Target *string `input:"header,x-oss-symlink-target,required"`

        // Specifies whether the object that is uploaded by calling the PutObject operation
        // overwrites an existing object that has the same name. Valid values: true and false
        ForbidOverwrite *string `input:"header,x-oss-forbid-overwrite"`

        // The ACL of the object. Default value: default.
        Acl ObjectACLType `input:"header,x-oss-object-acl"`

        // The storage class of the object.
        StorageClass StorageClassType `input:"header,x-oss-storage-class"`

        // The metadata of the object that you want to symlink.
        Metadata map[string]string `input:"header,x-oss-meta-,usermeta"`

        RequestCommon
}

type PutSymlinkResult struct {
        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        ResultCommon
}

// PutSymlink Creates a symbolic link that points to a destination object. You can use the symbolic link to access the destination object.
func (c *Client) PutSymlink(ctx context.Context, request *PutSymlinkRequest, optFns ...func(*Options)) (*PutSymlinkResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;PutSymlinkRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "PutSymlink",
                Method: "PUT",
                Bucket: request.Bucket,
                Key:    request.Key,
                Parameters: map[string]string{
                        "symlink": "",
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;PutSymlinkResult{}
        if err = c.unmarshalOutput(result, output, discardBody, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type GetSymlinkRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // Version of the object.
        VersionId *string `input:"query,versionId"`

        RequestCommon
}

type GetSymlinkResult struct {
        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        // Indicates the target object that the symbol link directs to.
        Target *string `output:"header,x-oss-symlink-target"`

        // Entity tag for the uploaded object.
        ETag *string `output:"header,ETag"`

        // The metadata of the object that you want to symlink.
        Metadata map[string]string `output:"header,x-oss-meta-,usermeta"`

        ResultCommon
}

// GetSymlink Obtains a symbol link. To perform GetSymlink operations, you must have the read permission on the symbol link.
func (c *Client) GetSymlink(ctx context.Context, request *GetSymlinkRequest, optFns ...func(*Options)) (*GetSymlinkResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;GetSymlinkRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "GetSymlink",
                Method: "GET",
                Bucket: request.Bucket,
                Key:    request.Key,
                Parameters: map[string]string{
                        "symlink": "",
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;GetSymlinkResult{}
        if err = c.unmarshalOutput(result, output, discardBody, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type PutObjectTaggingRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // Version of the object.
        VersionId *string `input:"query,versionId"`

        Tagging *Tagging `input:"body,Tagging,xml,required"`

        RequestCommon
}

type Tagging struct {
        TagSet TagSet `xml:"TagSet"`
}

type TagSet struct {
        Tags []Tag `xml:"Tag"`
}

type Tag struct {
        Key   *string `xml:"Key"`
        Value *string `xml:"Value"`
}

type PutObjectTaggingResult struct {
        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        ResultCommon
}

// PutObjectTagging Adds tags to an object or updates the tags added to the object. Each tag added to an object is a key-value pair.
func (c *Client) PutObjectTagging(ctx context.Context, request *PutObjectTaggingRequest, optFns ...func(*Options)) (*PutObjectTaggingResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;PutObjectTaggingRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "PutObjectTagging",
                Method: "PUT",
                Bucket: request.Bucket,
                Key:    request.Key,
                Parameters: map[string]string{
                        "tagging": "",
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;PutObjectTaggingResult{}
        if err = c.unmarshalOutput(result, output, discardBody, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type GetObjectTaggingRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // Version of the object.
        VersionId *string `input:"query,versionId"`

        RequestCommon
}

type GetObjectTaggingResult struct {
        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        // The container used to store the collection of tags.
        Tags []Tag `xml:"TagSet&gt;Tag"`

        ResultCommon
}

// GetObjectTagging You can call this operation to query the tags of an object.
func (c *Client) GetObjectTagging(ctx context.Context, request *GetObjectTaggingRequest, optFns ...func(*Options)) (*GetObjectTaggingResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;GetObjectTaggingRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "GetObjectTagging",
                Method: "GET",
                Bucket: request.Bucket,
                Key:    request.Key,
                Parameters: map[string]string{
                        "tagging": "",
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;GetObjectTaggingResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

type DeleteObjectTaggingRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // Version of the object.
        VersionId *string `input:"query,versionId"`

        RequestCommon
}

type DeleteObjectTaggingResult struct {
        // Version of the object.
        VersionId *string `output:"header,x-oss-version-id"`

        ResultCommon
}

// DeleteObjectTagging You can call this operation to delete the tags of a specified object.
func (c *Client) DeleteObjectTagging(ctx context.Context, request *DeleteObjectTaggingRequest, optFns ...func(*Options)) (*DeleteObjectTaggingResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;DeleteObjectTaggingRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "DeleteObjectTagging",
                Method: "DELETE",
                Bucket: request.Bucket,
                Key:    request.Key,
                Parameters: map[string]string{
                        "tagging": "",
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;DeleteObjectTaggingResult{}
        if err = c.unmarshalOutput(result, output, discardBody, unmarshalHeader); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package oss

import (
        "bytes"
        "context"
        "encoding/base64"
        "encoding/binary"
        "encoding/xml"
        "fmt"
        "hash"
        "hash/crc32"
        "io"
        "strconv"
        "strings"
)

// FrameType
const (
        DataFrameType        = 8388609
        ContinuousFrameType  = 8388612
        EndFrameType         = 8388613
        MetaEndFrameCSVType  = 8388614
        MetaEndFrameJSONType = 8388615
)

type CreateSelectObjectMetaRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,uploadId,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        MetaRequest any `input:"nop,meta-request,required"`

        RequestCommon
}

type JsonMetaRequest struct {
        InputSerialization *InputSerialization `xml:"InputSerialization"`
        OverwriteIfExists  *bool               `xml:"OverwriteIfExists"`
}

type CsvMetaRequest struct {
        InputSerialization *InputSerialization `xml:"InputSerialization"`
        OverwriteIfExists  *bool               `xml:"OverwriteIfExists"`
}

type InputSerialization struct {
        CSV             *InputSerializationCSV  `xml:"CSV"`
        JSON            *InputSerializationJSON `xml:"JSON"`
        CompressionType *string                 `xml:"CompressionType"`
}

type InputSerializationCSV struct {
        RecordDelimiter *string `xml:"RecordDelimiter"`
        FieldDelimiter  *string `xml:"FieldDelimiter"`
        QuoteCharacter  *string `xml:"QuoteCharacter"`
}

type InputSerializationJSON struct {
        JSONType *string `xml:"Type"`
}

type CreateSelectObjectMetaResult struct {
        TotalScanned int64
        MetaStatus   int
        SplitsCount  int32
        RowsCount    int64
        ColumnsCount int32
        ErrorMsg     string
        ResultCommon
}

type ReadFlagInfo struct {
        OpenLine            bool
        ConsumedBytesLength int32
        EnablePayloadCrc    bool
        OutputRawData       bool
}

// CreateSelectObjectMeta You can call the CreateSelectObjectMeta operation to obtain information about an object, such as the total number of rows and the number of splits.
func (c *Client) CreateSelectObjectMeta(ctx context.Context, request *CreateSelectObjectMetaRequest, optFns ...func(*Options)) (*CreateSelectObjectMetaResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;CreateSelectObjectMetaRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "CreateSelectObjectMeta",
                Method: "POST",
                Bucket: request.Bucket,
                Key:    request.Key,
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeXML,
                },
        }
        if err = c.marshalInput(request, input, marshalMetaRequest, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;CreateSelectObjectMetaResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyCreateSelectObjectMeta); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

func marshalMetaRequest(request any, input *OperationInput) error <span class="cov8" title="1">{
        var builder strings.Builder
        var process string
        switch r := request.(*CreateSelectObjectMetaRequest).MetaRequest.(type) </span>{
        case *JsonMetaRequest:<span class="cov8" title="1">
                process = "json/meta"
                builder.WriteString("&lt;JsonMetaRequest&gt;")
                if r.InputSerialization != nil </span><span class="cov8" title="1">{
                        bs, err := xml.Marshal(r.InputSerialization)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">builder.WriteString(string(bs))</span>
                }
                <span class="cov8" title="1">if r.OverwriteIfExists != nil </span><span class="cov0" title="0">{
                        builder.WriteString("&lt;OverwriteIfExists&gt;")
                        builder.WriteString(strconv.FormatBool(*r.OverwriteIfExists))
                        builder.WriteString("&lt;/OverwriteIfExists&gt;")
                }</span>
                <span class="cov8" title="1">builder.WriteString("&lt;/JsonMetaRequest&gt;")</span>
        case *CsvMetaRequest:<span class="cov8" title="1">
                r.encodeBase64()
                process = "csv/meta"
                builder.WriteString("&lt;CsvMetaRequest&gt;")
                if r.InputSerialization != nil </span><span class="cov8" title="1">{
                        bs, err := xml.Marshal(r.InputSerialization)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">builder.WriteString(string(bs))</span>
                }
                <span class="cov8" title="1">if r.OverwriteIfExists != nil </span><span class="cov8" title="1">{
                        builder.WriteString("&lt;OverwriteIfExists&gt;")
                        builder.WriteString(strconv.FormatBool(*r.OverwriteIfExists))
                        builder.WriteString("&lt;/OverwriteIfExists&gt;")
                }</span>
                <span class="cov8" title="1">builder.WriteString("&lt;/CsvMetaRequest&gt;")</span>
        default:<span class="cov8" title="1">
                return NewErrParamInvalid("MetaRequest")</span>
        }
        <span class="cov8" title="1">input.Body = strings.NewReader(builder.String())
        if input.Parameters == nil </span><span class="cov8" title="1">{
                input.Parameters = map[string]string{}
        }</span>
        <span class="cov8" title="1">input.Parameters["x-oss-process"] = process
        return nil</span>
}

func unmarshalBodyCreateSelectObjectMeta(result any, output *OperationOutput) error <span class="cov8" title="1">{
        var err error
        if output.Body != nil </span><span class="cov8" title="1">{
                defer output.Body.Close()
                readerWrapper := &amp;ReaderWrapper{
                        Body:                output.Body,
                        WriterForCheckCrc32: crc32.NewIEEE(),
                }
                if _, err = io.ReadAll(readerWrapper); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">result.(*CreateSelectObjectMetaResult).TotalScanned = readerWrapper.TotalScanned
                result.(*CreateSelectObjectMetaResult).MetaStatus = int(readerWrapper.Status)
                result.(*CreateSelectObjectMetaResult).SplitsCount = readerWrapper.SplitsCount
                result.(*CreateSelectObjectMetaResult).RowsCount = readerWrapper.RowsCount
                result.(*CreateSelectObjectMetaResult).ColumnsCount = readerWrapper.ColumnsCount
                result.(*CreateSelectObjectMetaResult).ErrorMsg = readerWrapper.ErrorMsg</span>
        }
        <span class="cov8" title="1">return err</span>
}

type SelectObjectRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,uploadId,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        SelectRequest *SelectRequest `input:"nop,SelectRequest,required"`

        RequestCommon
}

type SelectObjectResult struct {
        Body io.ReadCloser
        ResultCommon
}

type SelectRequest struct {
        Expression                *string                   `xml:"Expression"`
        InputSerializationSelect  InputSerializationSelect  `xml:"InputSerialization"`
        OutputSerializationSelect OutputSerializationSelect `xml:"OutputSerialization"`
        SelectOptions             *SelectOptions            `xml:"Options"`
}

type OutputSerializationSelect struct {
        CsvBodyOutput    *CSVSelectOutput  `xml:"CSV"`
        JsonBodyOutput   *JSONSelectOutput `xml:"JSON"`
        OutputRawData    *bool             `xml:"OutputRawData"`
        KeepAllColumns   *bool             `xml:"KeepAllColumns"`
        EnablePayloadCrc *bool             `xml:"EnablePayloadCrc"`
        OutputHeader     *bool             `xml:"OutputHeader"`
}
type CSVSelectOutput struct {
        RecordDelimiter *string `xml:"RecordDelimiter"`
        FieldDelimiter  *string `xml:"FieldDelimiter"`
}
type JSONSelectOutput struct {
        RecordDelimiter *string `xml:"RecordDelimiter"`
}

type SelectOptions struct {
        SkipPartialDataRecord    *bool `xml:"SkipPartialDataRecord"`
        MaxSkippedRecordsAllowed *int  `xml:"MaxSkippedRecordsAllowed"`
}

type InputSerializationSelect struct {
        CsvBodyInput    *CSVSelectInput  `xml:"CSV"`
        JsonBodyInput   *JSONSelectInput `xml:"JSON"`
        CompressionType *string          `xml:"CompressionType"`
}

type CSVSelectInput struct {
        FileHeaderInfo             *string `xml:"FileHeaderInfo"`
        RecordDelimiter            *string `xml:"RecordDelimiter"`
        FieldDelimiter             *string `xml:"FieldDelimiter"`
        QuoteCharacter             *string `xml:"QuoteCharacter"`
        CommentCharacter           *string `xml:"CommentCharacter"`
        Range                      *string `xml:"Range"`
        SplitRange                 *string
        AllowQuotedRecordDelimiter *bool `xml:"AllowQuotedRecordDelimiter"`
}

type JSONSelectInput struct {
        JSONType                *string `xml:"Type"`
        Range                   *string `xml:"Range"`
        ParseJSONNumberAsString *bool   `xml:"ParseJsonNumberAsString"`
        SplitRange              *string
}

func (jsonInput JSONSelectInput) JsonIsEmpty() bool <span class="cov0" title="0">{
        if jsonInput.JSONType != nil </span><span class="cov0" title="0">{
                if *jsonInput.JSONType != "" </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// SelectObject Executes SQL statements to perform operations on an object and obtains the execution results.
func (c *Client) SelectObject(ctx context.Context, request *SelectObjectRequest, optFns ...func(*Options)) (*SelectObjectResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;SelectObjectRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "SelectObject",
                Method: "POST",
                Bucket: request.Bucket,
                Key:    request.Key,
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeXML,
                },
        }
        if err = c.marshalInput(request, input, marshalSelectObjectRequest, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := &amp;SelectObjectResult{}
        err = unmarshalResultSelectObject(request, result, output)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err = c.unmarshalOutput(result, output); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

func marshalSelectObjectRequest(request any, input *OperationInput) error <span class="cov8" title="1">{
        var process string
        if request.(*SelectObjectRequest).SelectRequest != nil </span><span class="cov8" title="1">{
                if request.(*SelectObjectRequest).SelectRequest.InputSerializationSelect.JsonBodyInput == nil </span><span class="cov8" title="1">{
                        process = "csv/select"
                }</span> else<span class="cov8" title="1"> {
                        process = "json/select"
                }</span>
                <span class="cov8" title="1">request.(*SelectObjectRequest).SelectRequest.encodeBase64()</span>
        }
        <span class="cov8" title="1">if input.Parameters == nil </span><span class="cov8" title="1">{
                input.Parameters = map[string]string{}
        }</span>
        <span class="cov8" title="1">input.Parameters["x-oss-process"] = process
        bs, err := xml.Marshal(request.(*SelectObjectRequest).SelectRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">input.Body = strings.NewReader(string(bs))
        return err</span>
}

func unmarshalResultSelectObject(request *SelectObjectRequest, result *SelectObjectResult, output *OperationOutput) error <span class="cov8" title="1">{
        var err error
        if output.Body != nil </span><span class="cov8" title="1">{
                readerWrapper := &amp;ReaderWrapper{
                        Body:                output.Body,
                        WriterForCheckCrc32: crc32.NewIEEE(),
                }
                if request.SelectRequest.OutputSerializationSelect.EnablePayloadCrc != nil &amp;&amp; *request.SelectRequest.OutputSerializationSelect.EnablePayloadCrc == true </span><span class="cov8" title="1">{
                        readerWrapper.EnablePayloadCrc = true
                }</span>
                <span class="cov8" title="1">readerWrapper.OutputRawData = strings.ToUpper(output.Headers.Get("x-oss-select-output-raw")) == "TRUE"
                result.Body = readerWrapper</span>
        }
        <span class="cov8" title="1">return err</span>
}

// The adapter class for Select object's response.
// The response consists of frames. Each frame has the following format:

// Type  |   Payload Length |  Header Checksum | Payload | Payload Checksum

// |&lt;4--&gt;|  &lt;--4 bytes------&gt;&lt;---4 bytes-------&gt;&lt;-n/a-----&gt;&lt;--4 bytes---------&gt;
// And we have three kind of frames.
// Data Frame:
// Type:8388609
// Payload:   Offset    |    Data
//            &lt;-8 bytes&gt;

// Continuous Frame
// Type:8388612
// Payload: Offset  (8-bytes)

// End Frame
// Type:8388613
// Payload: Offset | total scanned bytes | http status code | error message
//     &lt;-- 8bytes--&gt;&lt;-----8 bytes--------&gt;&lt;---4 bytes-------&gt;&lt;---variabe---&gt;

// SelectObjectResponse defines HTTP response from OSS SelectObject
//type SelectObjectResponse struct {
//        Body        io.ReadCloser
//        Frame       SelectObjectResult
//        ReadTimeOut uint
//        Finish      bool
//        ResultCommon
//}

// ReaderWrapper defines HTTP response from OSS SelectObject
type ReaderWrapper struct {
        Body                io.ReadCloser
        Version             byte
        FrameType           int32
        PayloadLength       int32
        HeaderCheckSum      uint32
        Offset              uint64
        Data                string
        ClientCRC32         uint32
        ServerCRC32         uint32
        WriterForCheckCrc32 hash.Hash32
        HTTPStatusCode      int32
        TotalScanned        int64
        Status              int32
        SplitsCount         int32
        RowsCount           int64
        ColumnsCount        int32
        ErrorMsg            string
        PayloadChecksum     uint32
        ReadFlagInfo
        Finish bool
}

func (rw *ReaderWrapper) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        n, err = rw.readFrames(p)
        return
}</span>

// Close http response body
func (rw *ReaderWrapper) Close() error <span class="cov0" title="0">{
        return rw.Body.Close()
}</span>

// readFrames is read Frame
func (rw *ReaderWrapper) readFrames(p []byte) (int, error) <span class="cov8" title="1">{
        var nn int
        var err error
        var checkValid bool
        if rw.OutputRawData == true </span><span class="cov8" title="1">{
                nn, err = rw.Body.Read(p)
                return nn, err
        }</span>

        <span class="cov8" title="1">if rw.Finish </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                // if this Frame is Read, then not reading Header
                if rw.OpenLine != true </span><span class="cov8" title="1">{
                        err = rw.analysisHeader()
                        if err != nil </span><span class="cov8" title="1">{
                                return nn, err
                        }</span>
                }

                <span class="cov8" title="1">if rw.FrameType == DataFrameType </span><span class="cov8" title="1">{
                        n, err := rw.analysisData(p[nn:])
                        if err != nil </span><span class="cov0" title="0">{
                                return nn, err
                        }</span>
                        <span class="cov8" title="1">nn += n

                        // if this Frame is read all data, then empty the Frame to read it with next frame
                        if rw.ConsumedBytesLength == rw.PayloadLength-8 </span><span class="cov8" title="1">{
                                checkValid, err = rw.checkPayloadSum()
                                if err != nil || !checkValid </span><span class="cov0" title="0">{
                                        return nn, fmt.Errorf("%s", err.Error())
                                }</span>
                                <span class="cov8" title="1">rw.emptyFrame()</span>
                        }

                        <span class="cov8" title="1">if nn == len(p) </span><span class="cov8" title="1">{
                                return nn, nil
                        }</span>
                } else<span class="cov8" title="1"> if rw.FrameType == ContinuousFrameType </span><span class="cov0" title="0">{
                        checkValid, err = rw.checkPayloadSum()
                        if err != nil || !checkValid </span><span class="cov0" title="0">{
                                return nn, fmt.Errorf("%s", err.Error())
                        }</span>
                        <span class="cov0" title="0">rw.OpenLine = false</span>
                } else<span class="cov8" title="1"> if rw.FrameType == EndFrameType </span><span class="cov8" title="1">{
                        err = rw.analysisEndFrame()
                        if err != nil </span><span class="cov0" title="0">{
                                return nn, err
                        }</span>
                        <span class="cov8" title="1">checkValid, err = rw.checkPayloadSum()
                        if checkValid </span><span class="cov8" title="1">{
                                rw.Finish = true
                        }</span>
                        <span class="cov8" title="1">return nn, err</span>
                } else<span class="cov8" title="1"> if rw.FrameType == MetaEndFrameCSVType </span><span class="cov8" title="1">{
                        err = rw.analysisMetaEndFrameCSV()
                        if err != nil </span><span class="cov0" title="0">{
                                return nn, err
                        }</span>
                        <span class="cov8" title="1">checkValid, err = rw.checkPayloadSum()
                        if checkValid </span><span class="cov8" title="1">{
                                rw.Finish = true
                        }</span>
                        <span class="cov8" title="1">return nn, err</span>
                } else<span class="cov8" title="1"> if rw.FrameType == MetaEndFrameJSONType </span><span class="cov8" title="1">{
                        err = rw.analysisMetaEndFrameJSON()
                        if err != nil </span><span class="cov0" title="0">{
                                return nn, err
                        }</span>
                        <span class="cov8" title="1">checkValid, err = rw.checkPayloadSum()
                        if checkValid </span><span class="cov8" title="1">{
                                rw.Finish = true
                        }</span>
                        <span class="cov8" title="1">return nn, err</span>
                }
        }
}

type chanReadIO struct {
        readLen int
        err     error
}

func (rw *ReaderWrapper) readLen(p []byte) (int, error) <span class="cov8" title="1">{
        r := rw.Body
        ch := make(chan chanReadIO, 1)
        defer close(ch)
        go func(p []byte) </span><span class="cov8" title="1">{
                var needReadLength int
                readChan := chanReadIO{}
                needReadLength = len(p)
                for </span><span class="cov8" title="1">{
                        n, err := r.Read(p[readChan.readLen:needReadLength])
                        readChan.readLen += n
                        if err != nil </span><span class="cov8" title="1">{
                                readChan.err = err
                                ch &lt;- readChan
                                return
                        }</span>

                        <span class="cov8" title="1">if readChan.readLen == needReadLength </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">ch &lt;- readChan</span>
        }(p)

        <span class="cov8" title="1">select </span>{
        case result := &lt;-ch:<span class="cov8" title="1">
                return result.readLen, result.err</span>
        }
}

// analysisHeader is reading selectObject response body's header
func (rw *ReaderWrapper) analysisHeader() error <span class="cov8" title="1">{
        headFrameByte := make([]byte, 20)
        _, err := rw.readLen(headFrameByte)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read response frame header failure,err:%s", err.Error())
        }</span>

        <span class="cov8" title="1">frameTypeByte := headFrameByte[0:4]
        rw.Version = frameTypeByte[0]
        frameTypeByte[0] = 0
        bytesToInt(frameTypeByte, &amp;rw.FrameType)

        if rw.FrameType != DataFrameType &amp;&amp; rw.FrameType != ContinuousFrameType &amp;&amp;
                rw.FrameType != EndFrameType &amp;&amp; rw.FrameType != MetaEndFrameCSVType &amp;&amp; rw.FrameType != MetaEndFrameJSONType </span><span class="cov8" title="1">{
                return fmt.Errorf("unexpected frame type: %d", rw.FrameType)
        }</span>

        <span class="cov8" title="1">payloadLengthByte := headFrameByte[4:8]
        bytesToInt(payloadLengthByte, &amp;rw.PayloadLength)
        headCheckSumByte := headFrameByte[8:12]
        bytesToInt(headCheckSumByte, &amp;rw.HeaderCheckSum)
        byteOffset := headFrameByte[12:20]
        bytesToInt(byteOffset, &amp;rw.Offset)
        rw.OpenLine = true
        err = rw.writerCheckCrc32(byteOffset)
        return err</span>
}

// analysisData is reading the DataFrameType data of selectObject response body
func (rw *ReaderWrapper) analysisData(p []byte) (int, error) <span class="cov8" title="1">{
        var needReadLength int32
        lenP := int32(len(p))
        restByteLength := rw.PayloadLength - 8 - rw.ConsumedBytesLength
        if lenP &lt;= restByteLength </span><span class="cov8" title="1">{
                needReadLength = lenP
        }</span> else<span class="cov8" title="1"> {
                needReadLength = restByteLength
        }</span>
        <span class="cov8" title="1">n, err := rw.readLen(p[:needReadLength])
        if err != nil </span><span class="cov0" title="0">{
                return n, fmt.Errorf("read frame data error,%s", err.Error())
        }</span>
        <span class="cov8" title="1">rw.ConsumedBytesLength += int32(n)
        err = rw.writerCheckCrc32(p[:n])
        return n, err</span>
}

// analysisEndFrame is reading the EndFrameType data of selectObject response body
func (rw *ReaderWrapper) analysisEndFrame() error <span class="cov8" title="1">{
        payLoadBytes := make([]byte, rw.PayloadLength-8)
        _, err := rw.readLen(payLoadBytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read end frame error:%s", err.Error())
        }</span>
        <span class="cov8" title="1">bytesToInt(payLoadBytes[0:8], &amp;rw.TotalScanned)
        bytesToInt(payLoadBytes[8:12], &amp;rw.HTTPStatusCode)
        errMsgLength := rw.PayloadLength - 20
        rw.ErrorMsg = string(payLoadBytes[12 : errMsgLength+12])
        err = rw.writerCheckCrc32(payLoadBytes)
        return err</span>
}

// analysisMetaEndFrameCSV is reading the MetaEndFrameCSVType data of selectObject response body
func (rw *ReaderWrapper) analysisMetaEndFrameCSV() error <span class="cov8" title="1">{
        payLoadBytes := make([]byte, rw.PayloadLength-8)
        _, err := rw.readLen(payLoadBytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read meta end csv frame error:%s", err.Error())
        }</span>

        <span class="cov8" title="1">bytesToInt(payLoadBytes[0:8], &amp;rw.TotalScanned)
        bytesToInt(payLoadBytes[8:12], &amp;rw.Status)
        bytesToInt(payLoadBytes[12:16], &amp;rw.SplitsCount)
        bytesToInt(payLoadBytes[16:24], &amp;rw.RowsCount)
        bytesToInt(payLoadBytes[24:28], &amp;rw.ColumnsCount)
        errMsgLength := rw.PayloadLength - 36
        rw.ErrorMsg = string(payLoadBytes[28 : errMsgLength+28])
        err = rw.writerCheckCrc32(payLoadBytes)
        return err</span>
}

// analysisMetaEndFrameJSON is reading the MetaEndFrameJSONType data of selectObject response body
func (rw *ReaderWrapper) analysisMetaEndFrameJSON() error <span class="cov8" title="1">{
        payLoadBytes := make([]byte, rw.PayloadLength-8)
        _, err := rw.readLen(payLoadBytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read meta end json frame error:%s", err.Error())
        }</span>

        <span class="cov8" title="1">bytesToInt(payLoadBytes[0:8], &amp;rw.TotalScanned)
        bytesToInt(payLoadBytes[8:12], &amp;rw.Status)
        bytesToInt(payLoadBytes[12:16], &amp;rw.SplitsCount)
        bytesToInt(payLoadBytes[16:24], &amp;rw.RowsCount)
        errMsgLength := rw.PayloadLength - 32
        rw.ErrorMsg = string(payLoadBytes[24 : errMsgLength+24])
        err = rw.writerCheckCrc32(payLoadBytes)
        return err</span>
}

func (rw *ReaderWrapper) checkPayloadSum() (bool, error) <span class="cov8" title="1">{
        payLoadChecksumByte := make([]byte, 4)
        n, err := rw.readLen(payLoadChecksumByte)
        if n == 4 </span><span class="cov8" title="1">{
                bytesToInt(payLoadChecksumByte, &amp;rw.PayloadChecksum)
                rw.ServerCRC32 = rw.PayloadChecksum
                rw.ClientCRC32 = rw.WriterForCheckCrc32.Sum32()
                if rw.EnablePayloadCrc == true &amp;&amp; rw.ServerCRC32 != 0 &amp;&amp; rw.ServerCRC32 != rw.ClientCRC32 </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("unexpected frame type: %d, client %d but server %d", rw.FrameType, rw.ClientCRC32, rw.ServerCRC32)
                }</span>
                <span class="cov8" title="1">return true, err</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("read checksum error:%s", err.Error())</span>
}

func (rw *ReaderWrapper) writerCheckCrc32(p []byte) (err error) <span class="cov8" title="1">{
        err = nil
        if rw.EnablePayloadCrc == true </span><span class="cov8" title="1">{
                _, err = rw.WriterForCheckCrc32.Write(p)
        }</span>
        <span class="cov8" title="1">return err</span>
}

// emptyFrame is emptying SelectObjectResponse Frame information
func (rw *ReaderWrapper) emptyFrame() <span class="cov8" title="1">{
        rw.WriterForCheckCrc32 = crc32.NewIEEE()

        rw.Finish = false
        rw.ConsumedBytesLength = 0
        rw.OpenLine = false
        rw.Version = byte(0)
        rw.FrameType = 0
        rw.PayloadLength = 0
        rw.HeaderCheckSum = 0
        rw.Offset = 0
        rw.Data = ""

        rw.TotalScanned = 0
        rw.Status = 0
        rw.SplitsCount = 0
        rw.RowsCount = 0
        rw.ColumnsCount = 0

        rw.ErrorMsg = ""

        rw.PayloadChecksum = 0
}</span>

// bytesToInt byte's array trans to int
func bytesToInt(b []byte, ret interface{}) <span class="cov8" title="1">{
        binBuf := bytes.NewBuffer(b)
        binary.Read(binBuf, binary.BigEndian, ret)
}</span>

// jsonEncodeBase64 encode base64 of the SelectObject api request params
func (selectReq *SelectRequest) jsonEncodeBase64() <span class="cov8" title="1">{
        if selectReq == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if selectReq.Expression != nil </span><span class="cov8" title="1">{
                *selectReq.Expression = base64.StdEncoding.EncodeToString([]byte(*selectReq.Expression))
        }</span>
        <span class="cov8" title="1">if selectReq.OutputSerializationSelect.JsonBodyOutput == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if selectReq.OutputSerializationSelect.JsonBodyOutput.RecordDelimiter != nil </span><span class="cov8" title="1">{
                *selectReq.OutputSerializationSelect.JsonBodyOutput.RecordDelimiter =
                        base64.StdEncoding.EncodeToString([]byte(*selectReq.OutputSerializationSelect.JsonBodyOutput.RecordDelimiter))
        }</span>
        <span class="cov8" title="1">if selectReq.InputSerializationSelect.JsonBodyInput.Range != nil </span><span class="cov8" title="1">{
                *selectReq.InputSerializationSelect.JsonBodyInput.Range = "line-range=" + *selectReq.InputSerializationSelect.JsonBodyInput.Range
        }</span>
        <span class="cov8" title="1">if selectReq.InputSerializationSelect.JsonBodyInput.SplitRange != nil &amp;&amp; *selectReq.InputSerializationSelect.JsonBodyInput.SplitRange != "" </span><span class="cov8" title="1">{
                selectReq.InputSerializationSelect.JsonBodyInput.Range = Ptr("split-range=" + *selectReq.InputSerializationSelect.JsonBodyInput.SplitRange)
                selectReq.InputSerializationSelect.JsonBodyInput.SplitRange = nil
        }</span>
}

// encodeBase64 encode base64 of the CreateSelectObjectMeta api request params
func (meta *CsvMetaRequest) encodeBase64() <span class="cov8" title="1">{
        if meta == nil || meta.InputSerialization == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if meta.InputSerialization.CSV.RecordDelimiter != nil </span><span class="cov8" title="1">{
                *meta.InputSerialization.CSV.RecordDelimiter =
                        base64.StdEncoding.EncodeToString([]byte(*meta.InputSerialization.CSV.RecordDelimiter))
        }</span>
        <span class="cov8" title="1">if meta.InputSerialization.CSV.FieldDelimiter != nil </span><span class="cov8" title="1">{
                *meta.InputSerialization.CSV.FieldDelimiter =
                        base64.StdEncoding.EncodeToString([]byte(*meta.InputSerialization.CSV.FieldDelimiter))
        }</span>

        <span class="cov8" title="1">if meta.InputSerialization.CSV.QuoteCharacter != nil </span><span class="cov8" title="1">{
                *meta.InputSerialization.CSV.QuoteCharacter =
                        base64.StdEncoding.EncodeToString([]byte(*meta.InputSerialization.CSV.QuoteCharacter))
        }</span>
}

func (selectReq *SelectRequest) encodeBase64() <span class="cov8" title="1">{
        if selectReq.InputSerializationSelect.JsonBodyInput == nil </span><span class="cov8" title="1">{
                selectReq.csvEncodeBase64()
        }</span> else<span class="cov8" title="1"> {
                selectReq.jsonEncodeBase64()
        }</span>
}

// csvEncodeBase64 encode base64 of the SelectObject api request params
func (selectReq *SelectRequest) csvEncodeBase64() <span class="cov8" title="1">{
        if selectReq == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if selectReq.Expression != nil </span><span class="cov8" title="1">{
                *selectReq.Expression = base64.StdEncoding.EncodeToString([]byte(*selectReq.Expression))
        }</span>
        <span class="cov8" title="1">if selectReq.InputSerializationSelect.CsvBodyInput == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if selectReq.InputSerializationSelect.CsvBodyInput.RecordDelimiter != nil </span><span class="cov8" title="1">{
                *selectReq.InputSerializationSelect.CsvBodyInput.RecordDelimiter =
                        base64.StdEncoding.EncodeToString([]byte(*selectReq.InputSerializationSelect.CsvBodyInput.RecordDelimiter))
        }</span>
        <span class="cov8" title="1">if selectReq.InputSerializationSelect.CsvBodyInput.FieldDelimiter != nil </span><span class="cov8" title="1">{
                *selectReq.InputSerializationSelect.CsvBodyInput.FieldDelimiter =
                        base64.StdEncoding.EncodeToString([]byte(*selectReq.InputSerializationSelect.CsvBodyInput.FieldDelimiter))
        }</span>
        <span class="cov8" title="1">if selectReq.InputSerializationSelect.CsvBodyInput.QuoteCharacter != nil </span><span class="cov8" title="1">{
                *selectReq.InputSerializationSelect.CsvBodyInput.QuoteCharacter =
                        base64.StdEncoding.EncodeToString([]byte(*selectReq.InputSerializationSelect.CsvBodyInput.QuoteCharacter))
        }</span>
        <span class="cov8" title="1">if selectReq.InputSerializationSelect.CsvBodyInput.CommentCharacter != nil </span><span class="cov8" title="1">{
                *selectReq.InputSerializationSelect.CsvBodyInput.CommentCharacter =
                        base64.StdEncoding.EncodeToString([]byte(*selectReq.InputSerializationSelect.CsvBodyInput.CommentCharacter))
        }</span>
        <span class="cov8" title="1">if selectReq.InputSerializationSelect.CsvBodyInput.Range != nil &amp;&amp; *selectReq.InputSerializationSelect.CsvBodyInput.Range != "" </span><span class="cov8" title="1">{
                *selectReq.InputSerializationSelect.CsvBodyInput.Range = "line-range=" + *selectReq.InputSerializationSelect.CsvBodyInput.Range
        }</span>
        <span class="cov8" title="1">if selectReq.InputSerializationSelect.CsvBodyInput.SplitRange != nil &amp;&amp; *selectReq.InputSerializationSelect.CsvBodyInput.SplitRange != "" </span><span class="cov8" title="1">{
                selectReq.InputSerializationSelect.CsvBodyInput.Range = Ptr("split-range=" + *selectReq.InputSerializationSelect.CsvBodyInput.SplitRange)
                selectReq.InputSerializationSelect.CsvBodyInput.SplitRange = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package oss

import (
        "context"
        "time"
)

type ListBucketsRequest struct {
        // The name of the bucket from which the list operation begins.
        Marker *string `input:"query,marker"`

        // The maximum number of buckets that can be returned in the single query.
        // Valid values: 1 to 1000.
        MaxKeys int32 `input:"query,max-keys"`

        // The prefix that the names of returned buckets must contain.
        Prefix *string `input:"query,prefix"` // Limits the response to keys that begin with the specified prefix

        // The ID of the resource group.
        ResourceGroupId *string `input:"header,x-oss-resource-group-id"`

        RequestCommon
}

type ListBucketsResult struct {
        // The prefix contained in the names of the returned bucket.
        Prefix *string `xml:"Prefix"`

        // The name of the bucket after which the ListBuckets  operation starts.
        Marker *string `xml:"Marker"` // The marker filter.

        // The maximum number of buckets that can be returned for the request.
        MaxKeys int32 `xml:"MaxKeys"`

        // Indicates whether all results are returned.
        // true: Only part of the results are returned for the request.
        // false: All results are returned for the request.
        IsTruncated bool `xml:"IsTruncated"`

        // The marker for the next ListBuckets request, which can be used to return the remaining results.
        NextMarker *string `xml:"NextMarker"`

        // The container that stores information about the bucket owner.
        Owner *Owner `xml:"Owner"`

        // The container that stores information about buckets.
        Buckets []BucketProperties `xml:"Buckets&gt;Bucket"`

        ResultCommon
}

type BucketProperties struct {
        // The name of the bucket.
        Name *string `xml:"Name"`

        // The data center in which the bucket is located.
        Location *string `xml:"Location"`

        // The time when the bucket was created. Format: yyyy-mm-ddThh:mm:ss.timezone.
        CreationDate *time.Time `xml:"CreationDate"`

        // The storage class of the bucket. Valid values:
        // Standard, IA, Archive, ColdArchive and DeepColdArchive.
        StorageClass *string `xml:"StorageClass"`

        // The public endpoint used to access the bucket over the Internet.
        ExtranetEndpoint *string `xml:"ExtranetEndpoint"`

        // The internal endpoint that is used to access the bucket from ECS instances
        // that reside in the same region as the bucket.
        IntranetEndpoint *string `xml:"IntranetEndpoint"`

        // The region in which the bucket is located.
        Region *string `xml:"Region"`

        // The ID of the resource group to which the bucket belongs.
        ResourceGroupId *string `xml:"ResourceGroupId"`
}

// ListBuckets Lists buckets that belong to the current account.
func (c *Client) ListBuckets(ctx context.Context, request *ListBucketsRequest, optFns ...func(*Options)) (*ListBucketsResult, error) <span class="cov8" title="1">{
        var err error
        if request == nil </span><span class="cov8" title="1">{
                request = &amp;ListBucketsRequest{}
        }</span>
        <span class="cov8" title="1">input := &amp;OperationInput{
                OpName: "ListBuckets",
                Method: "GET",
                Headers: map[string]string{
                        HTTPHeaderContentType: contentTypeDefault,
                },
        }
        if err = c.marshalInput(request, input, updateContentMd5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, input, optFns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;ListBucketsResult{}
        if err = c.unmarshalOutput(result, output, unmarshalBodyXml); err != nil </span><span class="cov0" title="0">{
                return nil, c.toClientError(err, "UnmarshalOutputFail", output)
        }</span>
        <span class="cov8" title="1">return result, err</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package oss

import (
        "bytes"
        "context"
        "crypto/md5"
        "encoding/base64"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "io"
        "net"
        "net/http"
        "net/url"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/aliyun/aliyun-oss-go-sdk/v3/oss/credentials"
        "github.com/aliyun/aliyun-oss-go-sdk/v3/oss/retry"
        "github.com/aliyun/aliyun-oss-go-sdk/v3/oss/signer"
        "github.com/aliyun/aliyun-oss-go-sdk/v3/oss/transport"
)

type Options struct {
        Region string

        Endpoint *url.URL

        RetryMaxAttempts int

        Retryer retry.Retryer

        Signer signer.Signer

        CredentialsProvider credentials.CredentialsProvider

        HttpClient HTTPClient

        ResponseHandlers []func(*http.Response) error

        UrlStyle UrlStyleType

        FeatureFlags FeatureFlagsType

        OpReadWriteTimeout *time.Duration

        AuthMethod *AuthMethodType

        AdditionalHeaders []string
}

func (c Options) Copy() Options <span class="cov8" title="1">{
        to := c
        to.ResponseHandlers = make([]func(*http.Response) error, len(c.ResponseHandlers))
        copy(to.ResponseHandlers, c.ResponseHandlers)
        return to
}</span>

type innerOptions struct {
        BwTokenBuckets BwTokenBuckets

        // A clock offset that how much client time is different from server time
        ClockOffset time.Duration
}

type Client struct {
        options Options
        inner   innerOptions
}

func NewClient(cfg *Config, optFns ...func(*Options)) *Client <span class="cov8" title="1">{
        options := Options{
                Region:              cfg.Region,
                RetryMaxAttempts:    cfg.RetryMaxAttempts,
                Retryer:             cfg.Retryer,
                CredentialsProvider: cfg.CredentialsProvider,
                HttpClient:          cfg.HttpClient,
                FeatureFlags:        FeatureFlagsDefault,
        }
        inner := innerOptions{}

        resolveEndpoint(cfg, &amp;options)
        resolveRetryer(cfg, &amp;options)
        resolveHTTPClient(cfg, &amp;options, &amp;inner)
        resolveSigner(cfg, &amp;options)
        resolveUrlStyle(cfg, &amp;options)
        resolveFeatureFlags(cfg, &amp;options)

        for _, fn := range optFns </span><span class="cov0" title="0">{
                fn(&amp;options)
        }</span>

        <span class="cov8" title="1">client := &amp;Client{
                options: options,
                inner:   inner,
        }

        return client</span>
}

func resolveEndpoint(cfg *Config, o *Options) <span class="cov8" title="1">{
        if cfg.Endpoint == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">scheme := "http"
        endpoint := *cfg.Endpoint
        if strings.HasPrefix(endpoint, "http://") </span><span class="cov8" title="1">{
                scheme = "http"
                endpoint = endpoint[len("http://"):]
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(endpoint, "https://") </span><span class="cov0" title="0">{
                scheme = "https"
                endpoint = endpoint[len("https://"):]
        }</span>
        <span class="cov8" title="1">o.Endpoint, _ = url.Parse(fmt.Sprintf("%s://%s", scheme, endpoint))</span>
}

func resolveRetryer(cfg *Config, o *Options) <span class="cov8" title="1">{
        if o.Retryer != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">o.Retryer = retry.NewStandard()</span>
}

func resolveHTTPClient(cfg *Config, o *Options, inner *innerOptions) <span class="cov8" title="1">{
        if o.HttpClient != nil </span><span class="cov0" title="0">{
                return
        }</span>

        //config in http.Transport
        <span class="cov8" title="1">custom := []func(*http.Transport){}
        if cfg.InsecureSkipVerify != nil </span><span class="cov8" title="1">{
                custom = append(custom, transport.InsecureSkipVerify(*cfg.InsecureSkipVerify))
        }</span>
        <span class="cov8" title="1">if cfg.ProxyFromEnvironment != nil &amp;&amp; *cfg.ProxyFromEnvironment </span><span class="cov8" title="1">{
                custom = append(custom, transport.ProxyFromEnvironment())
        }</span>
        <span class="cov8" title="1">if cfg.ProxyHost != nil </span><span class="cov0" title="0">{
                if url, err := url.Parse(*cfg.ProxyHost); err == nil </span><span class="cov0" title="0">{
                        custom = append(custom, transport.HttpProxy(url))
                }</span>
        }

        //config in transport  package
        <span class="cov8" title="1">tcfg := &amp;transport.Config{}
        if cfg.ConnectTimeout != nil </span><span class="cov8" title="1">{
                tcfg.ConnectTimeout = cfg.ConnectTimeout
        }</span>
        <span class="cov8" title="1">if cfg.ReadWriteTimeout != nil </span><span class="cov8" title="1">{
                tcfg.ReadWriteTimeout = cfg.ReadWriteTimeout
        }</span>
        <span class="cov8" title="1">if cfg.EnabledRedirect != nil </span><span class="cov8" title="1">{
                tcfg.EnabledRedirect = cfg.EnabledRedirect
        }</span>
        <span class="cov8" title="1">if cfg.UploadBandwidthlimit != nil </span><span class="cov0" title="0">{
                value := *cfg.UploadBandwidthlimit * 1024
                tb := newBwTokenBucket(value)
                tcfg.PostWrite = append(tcfg.PostWrite, func(n int, _ error) </span><span class="cov0" title="0">{
                        tb.LimitBandwidth(n)
                }</span>)
                <span class="cov0" title="0">inner.BwTokenBuckets[BwTokenBucketSlotTx] = tb</span>
        }
        <span class="cov8" title="1">if cfg.DownloadBandwidthlimit != nil </span><span class="cov0" title="0">{
                value := *cfg.DownloadBandwidthlimit * 1024
                tb := newBwTokenBucket(value)
                tcfg.PostRead = append(tcfg.PostRead, func(n int, _ error) </span><span class="cov0" title="0">{
                        tb.LimitBandwidth(n)
                }</span>)
                <span class="cov0" title="0">inner.BwTokenBuckets[BwTokenBucketSlotRx] = tb</span>
        }

        <span class="cov8" title="1">o.HttpClient = transport.NewHttpClient(tcfg, custom...)</span>
}

func resolveSigner(cfg *Config, o *Options) <span class="cov8" title="1">{
        if o.Signer != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">switch cfg.SignatureVersion </span>{
        case SignatureVersionV1:<span class="cov8" title="1">
                o.Signer = &amp;signer.SignerV1{}</span>
        default:<span class="cov8" title="1">
                o.Signer = &amp;signer.SignerV4{}</span>
        }
}

func resolveUrlStyle(cfg *Config, o *Options) <span class="cov8" title="1">{
        if cfg.UseCName != nil &amp;&amp; *cfg.UseCName </span><span class="cov0" title="0">{
                o.UrlStyle = UrlStyleCName
        }</span> else<span class="cov8" title="1"> if cfg.UsePathStyle != nil &amp;&amp; *cfg.UsePathStyle </span><span class="cov0" title="0">{
                o.UrlStyle = UrlStylePath
        }</span> else<span class="cov8" title="1"> {
                o.UrlStyle = UrlStyleVirtualHosted
        }</span>

        // if the endpoint is ip, set to path-style
        <span class="cov8" title="1">if o.Endpoint != nil </span><span class="cov8" title="1">{
                if ip := net.ParseIP(o.Endpoint.Hostname()); ip != nil </span><span class="cov8" title="1">{
                        o.UrlStyle = UrlStylePath
                }</span>
        }
}

func resolveFeatureFlags(cfg *Config, o *Options) {<span class="cov8" title="1">
        //TODO
}</span>

func (c *Client) invokeOperation(ctx context.Context, input *OperationInput, optFns []func(*Options)) (output *OperationOutput, err error) <span class="cov8" title="1">{
        options := c.options.Copy()
        opOpt := Options{}

        for _, fn := range optFns </span><span class="cov8" title="1">{
                fn(&amp;opOpt)
        }</span>

        <span class="cov8" title="1">applyOperationOpt(&amp;options, &amp;opOpt)

        ctx = applyOperationContext(ctx, &amp;options)

        output, err = c.sendRequest(ctx, input, &amp;options)

        if err != nil </span><span class="cov8" title="1">{
                return output, &amp;OperationError{
                        name: input.OpName,
                        err:  err}
        }</span>

        <span class="cov8" title="1">return output, err</span>
}

func (c *Client) sendRequest(ctx context.Context, input *OperationInput, opts *Options) (output *OperationOutput, err error) <span class="cov8" title="1">{
        // covert input into httpRequest
        if !isValidEndpoint(opts.Endpoint) </span><span class="cov8" title="1">{
                return output, NewErrParamInvalid("Endpoint")
        }</span>

        // host &amp; path
        <span class="cov8" title="1">host, path := buildURL(input, opts)
        strUrl := fmt.Sprintf("%s://%s%s", opts.Endpoint.Scheme, host, path)

        // querys
        if len(input.Parameters) &gt; 0 </span><span class="cov8" title="1">{
                var buf bytes.Buffer
                for k, v := range input.Parameters </span><span class="cov8" title="1">{
                        if buf.Len() &gt; 0 </span><span class="cov8" title="1">{
                                buf.WriteByte('&amp;')
                        }</span>
                        <span class="cov8" title="1">buf.WriteString(url.QueryEscape(k))
                        if len(v) &gt; 0 </span><span class="cov8" title="1">{
                                buf.WriteString("=" + strings.Replace(url.QueryEscape(v), "+", "%20", -1))
                        }</span>
                }
                <span class="cov8" title="1">strUrl += "?" + buf.String()</span>
        }

        <span class="cov8" title="1">request, err := http.NewRequestWithContext(ctx, input.Method, strUrl, nil)
        if err != nil </span><span class="cov0" title="0">{
                return output, err
        }</span>

        // headers
        <span class="cov8" title="1">for k, v := range input.Headers </span><span class="cov8" title="1">{
                if len(k) &gt; 0 &amp;&amp; len(v) &gt; 0 </span><span class="cov8" title="1">{
                        request.Header.Add(k, v)
                }</span>
        }
        <span class="cov8" title="1">request.Header.Set("User-Agent", defaultUserAgent())

        // body
        var body ReadSeekerNopClose
        if input.Body == nil </span><span class="cov8" title="1">{
                body = ReadSeekNopCloser(strings.NewReader(""))
        }</span> else<span class="cov8" title="1"> {
                body = ReadSeekNopCloser(input.Body)
        }</span>
        <span class="cov8" title="1">length, _ := body.GetLen()
        if length &gt;= 0 &amp;&amp; request.Header.Get("Content-Length") == "" </span><span class="cov8" title="1">{
                request.ContentLength = length
        }</span>
        <span class="cov8" title="1">request.Body = body

        //signing context
        subResource, _ := input.OpMetadata.Get(signer.SubResource).([]string)
        clockOffset := c.inner.ClockOffset
        signingCtx := &amp;signer.SigningContext{
                Product:         Ptr("oss"),
                Region:          Ptr(opts.Region),
                Bucket:          input.Bucket,
                Key:             input.Key,
                Request:         request,
                SubResource:     subResource,
                AuthMethodQuery: opts.AuthMethod != nil &amp;&amp; *opts.AuthMethod == AuthMethodQuery,
                ClockOffset:     clockOffset,
        }

        if date := request.Header.Get(HeaderOssDate); date != "" </span><span class="cov0" title="0">{
                signingCtx.Time, _ = http.ParseTime(date)
        }</span> else<span class="cov8" title="1"> if signTime, ok := input.OpMetadata.Get(signer.SignTime).(time.Time); ok </span><span class="cov8" title="1">{
                signingCtx.Time = signTime
        }</span>

        // send http request
        <span class="cov8" title="1">response, err := c.sendHttpRequest(ctx, signingCtx, opts)

        if err != nil </span><span class="cov8" title="1">{
                return output, err
        }</span>

        // covert http response into output context
        <span class="cov8" title="1">output = &amp;OperationOutput{
                Input:       input,
                Status:      response.Status,
                StatusCode:  response.StatusCode,
                Body:        response.Body,
                Headers:     response.Header,
                httpRequest: request,
        }

        // save other info by Metadata filed, ex. retry detail info
        //output.OpMetadata.Set(...)
        if signingCtx.AuthMethodQuery </span><span class="cov8" title="1">{
                output.OpMetadata.Set(signer.SignTime, signingCtx.Time)
        }</span>

        <span class="cov8" title="1">if signingCtx.ClockOffset != clockOffset </span><span class="cov0" title="0">{
                c.inner.ClockOffset = signingCtx.ClockOffset
        }</span>

        <span class="cov8" title="1">return output, err</span>
}

func (c *Client) sendHttpRequest(ctx context.Context, signingCtx *signer.SigningContext, opts *Options) (response *http.Response, err error) <span class="cov8" title="1">{
        request := signingCtx.Request
        retryer := opts.Retryer
        body, _ := request.Body.(ReadSeekerNopClose)
        bodyStart, _ := body.Seek(0, io.SeekCurrent)
        for tries := 1; tries &lt;= retryer.MaxAttempts(); tries++ </span><span class="cov8" title="1">{
                if tries &gt; 1 </span><span class="cov8" title="1">{
                        delay, err := retryer.RetryDelay(tries, err)
                        if err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">if err = sleepWithContext(ctx, delay); err != nil </span><span class="cov0" title="0">{
                                err = &amp;CanceledError{Err: err}
                                break</span>
                        }

                        <span class="cov8" title="1">if _, err = body.Seek(bodyStart, io.SeekStart); err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                <span class="cov8" title="1">if response, err = c.sendHttpRequestOnce(ctx, signingCtx, opts); err == nil </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">c.postSendHttpRequestOnce(signingCtx, response, err)

                if isContextError(ctx, &amp;err) </span><span class="cov0" title="0">{
                        err = &amp;CanceledError{Err: err}
                        break</span>
                }

                <span class="cov8" title="1">if !isReaderSeekable(request.Body) </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">if !retryer.IsErrorRetryable(err) </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return response, err</span>
}

func (c *Client) sendHttpRequestOnce(ctx context.Context, signingCtx *signer.SigningContext, opts *Options) (
        response *http.Response, err error,
) <span class="cov8" title="1">{
        if _, anonymous := opts.CredentialsProvider.(*credentials.AnonymousCredentialsProvider); !anonymous </span><span class="cov8" title="1">{
                cred, err := opts.CredentialsProvider.GetCredentials(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return response, err
                }</span>

                <span class="cov8" title="1">signingCtx.Credentials = &amp;cred
                if err = c.options.Signer.Sign(ctx, signingCtx); err != nil </span><span class="cov0" title="0">{
                        return response, err
                }</span>
        }

        <span class="cov8" title="1">if response, err = opts.HttpClient.Do(signingCtx.Request); err != nil </span><span class="cov8" title="1">{
                return response, err
        }</span>

        <span class="cov8" title="1">for _, fn := range opts.ResponseHandlers </span><span class="cov8" title="1">{
                if err = fn(response); err != nil </span><span class="cov8" title="1">{
                        return response, err
                }</span>
        }

        <span class="cov8" title="1">return response, err</span>
}

func (c *Client) postSendHttpRequestOnce(signingCtx *signer.SigningContext, response *http.Response, err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                switch e := err.(type) </span>{
                case *ServiceError:<span class="cov8" title="1">
                        if c.hasFeature(FeatureCorrectClockSkew) &amp;&amp;
                                e.Code == "RequestTimeTooSkewed" &amp;&amp;
                                !e.Timestamp.IsZero() </span><span class="cov0" title="0">{
                                signingCtx.ClockOffset = e.Timestamp.Sub(signingCtx.Time)
                        }</span>
                }
        }
}

func buildURL(input *OperationInput, opts *Options) (host string, path string) <span class="cov8" title="1">{
        if input == nil || opts == nil || opts.Endpoint == nil </span><span class="cov0" title="0">{
                return host, path
        }</span>

        <span class="cov8" title="1">var paths []string
        if input.Bucket == nil </span><span class="cov8" title="1">{
                host = opts.Endpoint.Host
        }</span> else<span class="cov8" title="1"> {
                switch opts.UrlStyle </span>{
                default:<span class="cov8" title="1"> // UrlStyleVirtualHosted
                        host = fmt.Sprintf("%s.%s", *input.Bucket, opts.Endpoint.Host)</span>
                case UrlStylePath:<span class="cov8" title="1">
                        host = opts.Endpoint.Host
                        paths = append(paths, *input.Bucket)</span>
                case UrlStyleCName:<span class="cov0" title="0">
                        host = opts.Endpoint.Host</span>
                }
        }

        <span class="cov8" title="1">if input.Key != nil </span><span class="cov8" title="1">{
                paths = append(paths, escapePath(*input.Key, false))
        }</span>

        <span class="cov8" title="1">return host, ("/" + strings.Join(paths, "/"))</span>
}

func callbackResponseHandler(opts *Options) <span class="cov8" title="1">{
        opts.ResponseHandlers = []func(*http.Response) error{
                callbackErrorResponseHandler,
        }
}</span>

func serviceErrorResponseHandler(response *http.Response) error <span class="cov8" title="1">{
        if response.StatusCode/100 == 2 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return tryConvertServiceError(response)</span>
}

func callbackErrorResponseHandler(response *http.Response) error <span class="cov8" title="1">{
        if response.StatusCode == 200 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return tryConvertServiceError(response)</span>
}

func tryConvertServiceError(response *http.Response) (err error) <span class="cov8" title="1">{
        var respBody []byte
        var body []byte
        timestamp, err := time.Parse(http.TimeFormat, response.Header.Get("Date"))
        if err != nil </span><span class="cov0" title="0">{
                timestamp = time.Now()
        }</span>

        <span class="cov8" title="1">defer response.Body.Close()
        respBody, err = io.ReadAll(response.Body)
        body = respBody
        if len(respBody) == 0 &amp;&amp; len(response.Header.Get(HeaderOssERR)) &gt; 0 </span><span class="cov8" title="1">{
                body, err = base64.StdEncoding.DecodeString(response.Header.Get(HeaderOssERR))
                if err != nil </span><span class="cov0" title="0">{
                        body = respBody
                }</span>
        }
        <span class="cov8" title="1">se := &amp;ServiceError{
                StatusCode:    response.StatusCode,
                Code:          "BadErrorResponse",
                RequestID:     response.Header.Get(HeaderOssRequestID),
                Timestamp:     timestamp,
                RequestTarget: fmt.Sprintf("%s %s", response.Request.Method, response.Request.URL),
                Snapshot:      body,
        }

        if err != nil </span><span class="cov0" title="0">{
                se.Message = fmt.Sprintf("The body of the response was not readable, due to :%s", err.Error())
                return se
        }</span>
        <span class="cov8" title="1">err = xml.Unmarshal(body, &amp;se)
        if err != nil </span><span class="cov8" title="1">{
                len := len(body)
                if len &gt; 256 </span><span class="cov0" title="0">{
                        len = 256
                }</span>
                <span class="cov8" title="1">se.Message = fmt.Sprintf("Failed to parse xml from response body due to: %s. With part response body %s.", err.Error(), string(body[:len]))
                return se</span>
        }
        <span class="cov8" title="1">return se</span>
}

func applyOperationOpt(c *Options, op *Options) <span class="cov8" title="1">{
        if c == nil || op == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if op.Endpoint != nil </span><span class="cov0" title="0">{
                c.Endpoint = op.Endpoint
        }</span>

        <span class="cov8" title="1">if op.RetryMaxAttempts &gt; 0 </span><span class="cov0" title="0">{
                c.RetryMaxAttempts = op.RetryMaxAttempts
        }</span>

        <span class="cov8" title="1">if op.Retryer != nil </span><span class="cov0" title="0">{
                c.Retryer = op.Retryer
        }</span>

        <span class="cov8" title="1">if c.Retryer == nil </span><span class="cov8" title="1">{
                c.Retryer = retry.NopRetryer{}
        }</span>

        <span class="cov8" title="1">if op.OpReadWriteTimeout != nil </span><span class="cov8" title="1">{
                c.OpReadWriteTimeout = op.OpReadWriteTimeout
        }</span>

        <span class="cov8" title="1">if op.HttpClient != nil </span><span class="cov8" title="1">{
                c.HttpClient = op.HttpClient
        }</span>

        <span class="cov8" title="1">if op.AuthMethod != nil </span><span class="cov8" title="1">{
                c.AuthMethod = op.AuthMethod
        }</span>

        //response handler
        <span class="cov8" title="1">handlers := []func(*http.Response) error{
                serviceErrorResponseHandler,
        }
        handlers = append(handlers, c.ResponseHandlers...)
        handlers = append(handlers, op.ResponseHandlers...)
        c.ResponseHandlers = handlers</span>
}

func applyOperationContext(ctx context.Context, c *Options) context.Context <span class="cov8" title="1">{
        if ctx == nil || c.OpReadWriteTimeout == nil </span><span class="cov8" title="1">{
                return ctx
        }</span>
        <span class="cov8" title="1">return context.WithValue(ctx, "OpReadWriteTimeout", c.OpReadWriteTimeout)</span>
}

// fieldInfo holds details for the input/output of a single field.
type fieldInfo struct {
        idx   int
        flags int
}

const (
        fRequire int = 1 &lt;&lt; iota

        fTypeUsermeta
        fTypeXml
        fTypeTime
)

func parseFiledFlags(tokens []string) int <span class="cov8" title="1">{
        var flags int = 0
        for _, token := range tokens </span><span class="cov8" title="1">{
                switch token </span>{
                case "required":<span class="cov8" title="1">
                        flags |= fRequire</span>
                case "time":<span class="cov8" title="1">
                        flags |= fTypeTime</span>
                case "xml":<span class="cov8" title="1">
                        flags |= fTypeXml</span>
                case "usermeta":<span class="cov8" title="1">
                        flags |= fTypeUsermeta</span>
                }
        }
        <span class="cov8" title="1">return flags</span>
}

func validateInput(input *OperationInput) error <span class="cov8" title="1">{
        if input == nil </span><span class="cov0" title="0">{
                return NewErrParamNull("OperationInput")
        }</span>

        <span class="cov8" title="1">if input.Bucket != nil &amp;&amp; !isValidBucketName(input.Bucket) </span><span class="cov0" title="0">{
                return NewErrParamInvalid("OperationInput.Bucket")
        }</span>

        <span class="cov8" title="1">if input.Key != nil &amp;&amp; !isValidObjectName(input.Key) </span><span class="cov0" title="0">{
                return NewErrParamInvalid("OperationInput.Key")
        }</span>

        <span class="cov8" title="1">if !isValidMethod(input.Method) </span><span class="cov8" title="1">{
                return NewErrParamInvalid("OperationInput.Method")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *Client) marshalInput(request any, input *OperationInput, handlers ...func(any, *OperationInput) error) error <span class="cov8" title="1">{
        // merge common fields
        if cm, ok := request.(RequestCommonInterface); ok </span><span class="cov8" title="1">{
                h, p, b := cm.GetCommonFileds()
                // headers
                if len(h) &gt; 0 </span><span class="cov8" title="1">{
                        if input.Headers == nil </span><span class="cov8" title="1">{
                                input.Headers = map[string]string{}
                        }</span>
                        <span class="cov8" title="1">for k, v := range h </span><span class="cov8" title="1">{
                                input.Headers[k] = v
                        }</span>
                }

                // parameters
                <span class="cov8" title="1">if len(p) &gt; 0 </span><span class="cov8" title="1">{
                        if input.Parameters == nil </span><span class="cov8" title="1">{
                                input.Parameters = map[string]string{}
                        }</span>
                        <span class="cov8" title="1">for k, v := range p </span><span class="cov8" title="1">{
                                input.Parameters[k] = v
                        }</span>
                }

                // body
                <span class="cov8" title="1">input.Body = b</span>
        }

        <span class="cov8" title="1">val := reflect.ValueOf(request)
        switch val.Kind() </span>{
        case reflect.Pointer, reflect.Interface:<span class="cov8" title="1">
                if val.IsNil() </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">val = val.Elem()</span>
        }
        <span class="cov8" title="1">if val.Kind() != reflect.Struct || input == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">t := val.Type()
        for k := 0; k &lt; t.NumField(); k++ </span><span class="cov8" title="1">{
                if tag, ok := t.Field(k).Tag.Lookup("input"); ok </span><span class="cov8" title="1">{
                        // header|query|body,filed_name,[required,time,usermeta...]
                        v := val.Field(k)
                        var flags int = 0
                        tokens := strings.Split(tag, ",")
                        if len(tokens) &lt; 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // parse field flags
                        <span class="cov8" title="1">if len(tokens) &gt; 2 </span><span class="cov8" title="1">{
                                flags = parseFiledFlags(tokens[2:])
                        }</span>
                        // check required flag
                        <span class="cov8" title="1">if isEmptyValue(v) </span><span class="cov8" title="1">{
                                if flags&amp;fRequire != 0 </span><span class="cov8" title="1">{
                                        return NewErrParamRequired(t.Field(k).Name)
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }

                        <span class="cov8" title="1">switch tokens[0] </span>{
                        case "query":<span class="cov8" title="1">
                                if input.Parameters == nil </span><span class="cov8" title="1">{
                                        input.Parameters = map[string]string{}
                                }</span>
                                <span class="cov8" title="1">if v.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                                        v = v.Elem()
                                }</span>
                                <span class="cov8" title="1">input.Parameters[tokens[1]] = fmt.Sprintf("%v", v.Interface())</span>
                        case "header":<span class="cov8" title="1">
                                if input.Headers == nil </span><span class="cov8" title="1">{
                                        input.Headers = map[string]string{}
                                }</span>
                                <span class="cov8" title="1">if v.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                                        v = v.Elem()
                                }</span>
                                <span class="cov8" title="1">if flags&amp;fTypeUsermeta != 0 </span><span class="cov8" title="1">{
                                        if m, ok := v.Interface().(map[string]string); ok </span><span class="cov8" title="1">{
                                                for k, v := range m </span><span class="cov8" title="1">{
                                                        input.Headers[tokens[1]+k] = v
                                                }</span>
                                        }
                                } else<span class="cov8" title="1"> {
                                        input.Headers[tokens[1]] = fmt.Sprintf("%v", v.Interface())
                                }</span>
                        case "body":<span class="cov8" title="1">
                                if flags&amp;fTypeXml != 0 </span><span class="cov8" title="1">{
                                        var b bytes.Buffer
                                        if err := xml.NewEncoder(&amp;b).EncodeElement(
                                                v.Interface(),
                                                xml.StartElement{Name: xml.Name{Local: tokens[1]}}); err != nil </span><span class="cov0" title="0">{
                                                return &amp;SerializationError{
                                                        Err: err,
                                                }
                                        }</span>
                                        <span class="cov8" title="1">input.Body = bytes.NewReader(b.Bytes())</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">if err := validateInput(input); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">for _, h := range handlers </span><span class="cov8" title="1">{
                if err := h(request, input); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func marshalDeleteObjects(request any, input *OperationInput) error <span class="cov8" title="1">{
        var builder strings.Builder
        delRequest := request.(*DeleteMultipleObjectsRequest)
        builder.WriteString("&lt;Delete&gt;")
        builder.WriteString("&lt;Quiet&gt;")
        builder.WriteString(strconv.FormatBool(delRequest.Quiet))
        builder.WriteString("&lt;/Quiet&gt;")
        if len(delRequest.Objects) &gt; 0 </span><span class="cov8" title="1">{
                for _, object := range delRequest.Objects </span><span class="cov8" title="1">{
                        builder.WriteString("&lt;Object&gt;")
                        if object.Key != nil </span><span class="cov8" title="1">{
                                builder.WriteString("&lt;Key&gt;")
                                builder.WriteString(escapeXml(*object.Key))
                                builder.WriteString("&lt;/Key&gt;")
                        }</span>
                        <span class="cov8" title="1">if object.VersionId != nil </span><span class="cov8" title="1">{
                                builder.WriteString("&lt;VersionId&gt;")
                                builder.WriteString(*object.VersionId)
                                builder.WriteString("&lt;/VersionId&gt;")
                        }</span>
                        <span class="cov8" title="1">builder.WriteString("&lt;/Object&gt;")</span>
                }
        } else<span class="cov0" title="0"> {
                return NewErrParamInvalid("Objects")
        }</span>
        <span class="cov8" title="1">builder.WriteString("&lt;/Delete&gt;")
        input.Body = strings.NewReader(builder.String())
        return nil</span>
}

func discardBody(result any, output *OperationOutput) error <span class="cov8" title="1">{
        var err error
        if output.Body != nil </span><span class="cov8" title="1">{
                defer output.Body.Close()
                _, err = io.Copy(io.Discard, output.Body)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func unmarshalBodyXml(result any, output *OperationOutput) error <span class="cov8" title="1">{
        var err error
        var body []byte
        if output.Body != nil </span><span class="cov8" title="1">{
                defer output.Body.Close()
                if body, err = io.ReadAll(output.Body); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if len(body) &gt; 0 </span><span class="cov8" title="1">{
                if err = xml.Unmarshal(body, result); err != nil </span><span class="cov8" title="1">{
                        err = &amp;DeserializationError{
                                Err:      err,
                                Snapshot: body,
                        }
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

func unmarshalBodyDefault(result any, output *OperationOutput) error <span class="cov8" title="1">{
        var err error
        var body []byte
        if output.Body != nil </span><span class="cov8" title="1">{
                defer output.Body.Close()
                if body, err = io.ReadAll(output.Body); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // extract body
        <span class="cov8" title="1">if len(body) &gt; 0 </span><span class="cov8" title="1">{
                contentType := output.Headers.Get("Content-Type")
                switch contentType </span>{
                case "application/xml":<span class="cov0" title="0">
                        err = xml.Unmarshal(body, result)</span>
                case "application/json":<span class="cov0" title="0">
                        err = json.Unmarshal(body, result)</span>
                default:<span class="cov8" title="1">
                        err = fmt.Errorf("unsupport contentType:%s", contentType)</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        err = &amp;DeserializationError{
                                Err:      err,
                                Snapshot: body,
                        }
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

func unmarshalCallbackBody(result any, output *OperationOutput) error <span class="cov8" title="1">{
        var err error
        var body []byte
        if output.Body != nil </span><span class="cov8" title="1">{
                defer output.Body.Close()
                if body, err = io.ReadAll(output.Body); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if len(body) &gt; 0 </span><span class="cov8" title="1">{
                switch r := result.(type) </span>{
                case *PutObjectResult:<span class="cov8" title="1">
                        if err = json.Unmarshal(body, &amp;r.CallbackResult); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case *CompleteMultipartUploadResult:<span class="cov8" title="1">
                        if err = json.Unmarshal(body, &amp;r.CallbackResult); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return err</span>
}

func unmarshalHeader(result any, output *OperationOutput) error <span class="cov8" title="1">{
        val := reflect.ValueOf(result)
        switch val.Kind() </span>{
        case reflect.Pointer, reflect.Interface:<span class="cov8" title="1">
                if val.IsNil() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">val = val.Elem()</span>
        }
        <span class="cov8" title="1">if val.Kind() != reflect.Struct || output == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">filedInfos := map[string]fieldInfo{}

        t := val.Type()
        var usermetaKeys []string
        for k := 0; k &lt; t.NumField(); k++ </span><span class="cov8" title="1">{
                if tag, ok := t.Field(k).Tag.Lookup("output"); ok </span><span class="cov8" title="1">{
                        tokens := strings.Split(tag, ",")
                        if len(tokens) &lt; 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // header|query|body,filed_name,[required,time,usermeta...]
                        <span class="cov8" title="1">switch tokens[0] </span>{
                        case "header":<span class="cov8" title="1">
                                lowkey := strings.ToLower(tokens[1])

                                var flags int = 0
                                if len(tokens) &gt;= 3 </span><span class="cov8" title="1">{
                                        flags = parseFiledFlags(tokens[2:])
                                }</span>
                                <span class="cov8" title="1">filedInfos[lowkey] = fieldInfo{idx: k, flags: flags}
                                if flags&amp;fTypeUsermeta != 0 </span><span class="cov8" title="1">{
                                        usermetaKeys = append(usermetaKeys, lowkey)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">var err error
        for key, vv := range output.Headers </span><span class="cov8" title="1">{
                lkey := strings.ToLower(key)
                for _, prefix := range usermetaKeys </span><span class="cov8" title="1">{
                        if strings.HasPrefix(lkey, prefix) </span><span class="cov8" title="1">{
                                if field, ok := filedInfos[prefix]; ok </span><span class="cov8" title="1">{
                                        if field.flags&amp;fTypeUsermeta != 0 </span><span class="cov8" title="1">{
                                                mapKey := strings.TrimPrefix(lkey, prefix)
                                                err = setMapStringReflectValue(val.Field(field.idx), mapKey, vv[0])
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">if field, ok := filedInfos[lkey]; ok </span><span class="cov8" title="1">{
                        if field.flags&amp;fTypeTime != 0 </span><span class="cov8" title="1">{
                                if t, err := http.ParseTime(vv[0]); err == nil </span><span class="cov8" title="1">{
                                        err = setTimeReflectValue(val.Field(field.idx), t)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                err = setReflectValue(val.Field(field.idx), vv[0])
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func unmarshalHeaderLite(result any, output *OperationOutput) error <span class="cov8" title="1">{
        val := reflect.ValueOf(result)
        switch val.Kind() </span>{
        case reflect.Pointer, reflect.Interface:<span class="cov8" title="1">
                if val.IsNil() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">val = val.Elem()</span>
        }
        <span class="cov8" title="1">if val.Kind() != reflect.Struct || output == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">t := val.Type()
        for k := 0; k &lt; t.NumField(); k++ </span><span class="cov8" title="1">{
                if tag := t.Field(k).Tag.Get("output"); tag != "" </span><span class="cov8" title="1">{
                        tokens := strings.Split(tag, ",")
                        if len(tokens) != 2 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">switch tokens[0] </span>{
                        case "header":<span class="cov8" title="1">
                                if src := output.Headers.Get(tokens[1]); src != "" </span><span class="cov8" title="1">{
                                        if err := setReflectValue(val.Field(k), src); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *Client) unmarshalOutput(result any, output *OperationOutput, handlers ...func(any, *OperationOutput) error) error <span class="cov8" title="1">{
        // Common
        if cm, ok := result.(ResultCommonInterface); ok </span><span class="cov8" title="1">{
                cm.CopyIn(output.Status, output.StatusCode, output.Headers, output.OpMetadata)
        }</span>

        <span class="cov8" title="1">var err error
        for _, h := range handlers </span><span class="cov8" title="1">{
                if err = h(result, output); err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return err</span>
}

func updateContentMd5(_ any, input *OperationInput) error <span class="cov8" title="1">{
        var err error
        var contentMd5 string
        if input.Body != nil </span><span class="cov8" title="1">{
                var r io.ReadSeeker
                var ok bool
                if r, ok = input.Body.(io.ReadSeeker); !ok </span><span class="cov0" title="0">{
                        buf, _ := io.ReadAll(input.Body)
                        r = bytes.NewReader(buf)
                        input.Body = r
                }</span>
                <span class="cov8" title="1">h := md5.New()
                if _, err = copySeekableBody(h, r); err != nil </span>{<span class="cov0" title="0">
                        // error
                }</span> else<span class="cov8" title="1"> {
                        contentMd5 = base64.StdEncoding.EncodeToString(h.Sum(nil))
                }</span>
        } else<span class="cov8" title="1"> {
                contentMd5 = "1B2M2Y8AsgTpgAmY7PhCfg=="
        }</span>

        // set content-md5 and content-type
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                if input.Headers == nil </span><span class="cov8" title="1">{
                        input.Headers = map[string]string{}
                }</span>
                <span class="cov8" title="1">input.Headers["Content-MD5"] = contentMd5</span>
        }

        <span class="cov8" title="1">return err</span>
}

func encodeSourceObject(request any) string <span class="cov8" title="1">{
        var bucket, key, versionId string
        switch req := request.(type) </span>{
        case *CopyObjectRequest:<span class="cov8" title="1">
                key = ToString(req.SourceKey)
                if req.SourceBucket != nil </span><span class="cov8" title="1">{
                        bucket = *req.SourceBucket
                }</span> else<span class="cov8" title="1"> {
                        bucket = ToString(req.Bucket)
                }</span>
                <span class="cov8" title="1">versionId = ToString(req.SourceVersionId)</span>
        case *UploadPartCopyRequest:<span class="cov8" title="1">
                key = ToString(req.SourceKey)
                if req.SourceBucket != nil </span><span class="cov8" title="1">{
                        bucket = *req.SourceBucket
                }</span> else<span class="cov8" title="1"> {
                        bucket = ToString(req.Bucket)
                }</span>
                <span class="cov8" title="1">versionId = ToString(req.SourceVersionId)</span>
        }

        <span class="cov8" title="1">source := fmt.Sprintf("/%s/%s", bucket, escapePath(key, false))
        if versionId != "" </span><span class="cov8" title="1">{
                source += "?versionId=" + versionId
        }</span>

        <span class="cov8" title="1">return source</span>
}

func (c *Client) toClientError(err error, code string, output *OperationOutput) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;ClientError{
                Code: code,
                Message: fmt.Sprintf("execute %s fail, error code is %s, request id:%s",
                        output.Input.OpName,
                        code,
                        output.Headers.Get(HeaderOssRequestID),
                ),
                Err: err}</span>
}

func (c *Client) hasFeature(flag FeatureFlagsType) bool <span class="cov8" title="1">{
        return (c.options.FeatureFlags &amp; flag) &gt; 0
}</span>

// Content-Type
const (
        contentTypeDefault string = "application/octet-stream"
        contentTypeXML            = "application/xml"
)
</pre>
		
		<pre class="file" id="file6" style="display: none">package oss

import (
        "bytes"
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "reflect"
        "sort"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
)

const (
        MaxUploadParts int32 = 10000

        MinUploadPartSize int64 = 5 * 1024 * 1024

        DefaultUploadPartSize = MinUploadPartSize

        DefaultUploadParallel = 3

        DefaultDownloadPartSize = MinUploadPartSize

        DefaultDownloadParallel = 3

        FilePermMode = os.FileMode(0664) // Default file permission

        TempFileSuffix = ".temp" // Temp file suffix

        CheckpointMagic = "92611BED-89E2-46B6-89E5-72F273D4B0A3"
)

type UploaderOptions struct {
        PartSize int64

        ParallelNum int

        LeavePartsOnError bool

        EnableCheckpoint bool

        CheckpointDir string

        ClientOptions []func(*Options)
}

type Uploader struct {
        options UploaderOptions
        client  *Client
}

func (c *Client) NewUploader(optFns ...func(*UploaderOptions)) *Uploader <span class="cov8" title="1">{
        options := UploaderOptions{
                PartSize:          DefaultUploadPartSize,
                ParallelNum:       DefaultUploadParallel,
                LeavePartsOnError: false,
        }

        for _, fn := range optFns </span><span class="cov8" title="1">{
                fn(&amp;options)
        }</span>

        <span class="cov8" title="1">u := &amp;Uploader{
                client:  c,
                options: options,
        }

        return u</span>
}

type UploadRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // The caching behavior of the web page when the object is downloaded.
        CacheControl *string `input:"header,Cache-Control"`

        // The method that is used to access the object.
        ContentDisposition *string `input:"header,Content-Disposition"`

        // The method that is used to encode the object.
        ContentEncoding *string `input:"header,Content-Encoding"`

        // The size of the data in the HTTP message body. Unit: bytes.
        ContentLength *int64 `input:"header,Content-Length"`

        // The MD5 hash of the object that you want to upload.
        ContentMD5 *string `input:"header,Content-MD5"`

        // A standard MIME type describing the format of the contents.
        ContentType *string `input:"header,Content-Type"`

        // The expiration time of the cache in UTC.
        Expires *string `input:"header,Expires"`

        // Specifies whether the object that is uploaded by calling the PutObject operation
        // overwrites an existing object that has the same name. Valid values: true and false
        ForbidOverwrite *string `input:"header,x-oss-forbid-overwrite"`

        // The encryption method on the server side when an object is created.
        // Valid values: AES256 and KMS
        ServerSideEncryption *string `input:"header,x-oss-server-side-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        // This header is valid only when the x-oss-server-side-encryption header is set to KMS.
        ServerSideDataEncryption *string `input:"header,x-oss-server-side-data-encryption"`

        // The ID of the customer master key (CMK) that is managed by Key Management Service (KMS).
        SSEKMSKeyId *string `input:"header,x-oss-server-side-encryption-key-id"`

        // The access control list (ACL) of the object.
        Acl ObjectACLType `input:"header,x-oss-object-acl"`

        // The storage class of the object.
        StorageClass StorageClassType `input:"header,x-oss-storage-class"`

        // The metadata of the object that you want to upload.
        Metadata map[string]string `input:"header,x-oss-meta-,usermeta"`

        // The tags that are specified for the object by using a key-value pair.
        // You can specify multiple tags for an object. Example: TagA=A&amp;TagB=B.
        Tagging *string `input:"header,x-oss-tagging"`

        // A callback parameter is a Base64-encoded string that contains multiple fields in the JSON format.
        Callback *string `input:"header,x-oss-callback"`

        // Configure custom parameters by using the callback-var parameter.
        CallbackVar *string `input:"header,x-oss-callback-var"`

        // Specify the speed limit value. The speed limit value ranges from 245760 to 838860800, with a unit of bit/s.
        TrafficLimit int64 `input:"header,x-oss-traffic-limit"`

        RequestCommon
}

type UploadResult struct {
        UploadId *string

        ETag *string

        VersionId *string

        HashCRC64 *string

        ResultCommon
}

type UploadError struct {
        Err      error
        UploadId string
        Path     string
}

func (m *UploadError) Error() string <span class="cov0" title="0">{
        var extra string
        if m.Err != nil </span><span class="cov0" title="0">{
                extra = fmt.Sprintf(", cause: %s", m.Err.Error())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("upload failed, upload id: %s%s", m.UploadId, extra)</span>
}

func (m *UploadError) Unwrap() error <span class="cov8" title="1">{
        return m.Err
}</span>

func (u *Uploader) UploadFrom(ctx context.Context, request *UploadRequest, body io.Reader, optFns ...func(*UploaderOptions)) (*UploadResult, error) <span class="cov8" title="1">{
        // Uploader wrapper
        delegate, err := u.newDelegate(ctx, request, optFns...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">delegate.body = body
        if err = delegate.applySource(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return delegate.upload()</span>
}

func (u *Uploader) UploadFile(ctx context.Context, request *UploadRequest, filePath string, optFns ...func(*UploaderOptions)) (*UploadResult, error) <span class="cov8" title="1">{
        // Uploader wrapper
        delegate, err := u.newDelegate(ctx, request, optFns...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Source
        <span class="cov8" title="1">if err = delegate.checkSource(filePath); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var file *os.File
        if file, err = delegate.openReader(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">delegate.body = file

        if err = delegate.applySource(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err = delegate.checkCheckpoint(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err = delegate.adjustSource(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result, err := delegate.upload()

        return result, delegate.closeReader(file, err)</span>
}

type uploaderDelegate struct {
        options UploaderOptions
        client  *Client
        context context.Context
        request *UploadRequest

        body      io.Reader
        readerPos int64
        totalSize int64

        // Source's Info, from file or reader
        filePath string
        fileInfo os.FileInfo

        // for resume upload
        uploadId   string
        partNumber int32

        partPool byteSlicePool

        checkpoint *uploadCheckpoint
}

func (u *Uploader) newDelegate(ctx context.Context, request *UploadRequest, optFns ...func(*UploaderOptions)) (*uploaderDelegate, error) <span class="cov8" title="1">{
        if request == nil </span><span class="cov8" title="1">{
                return nil, NewErrParamNull("request")
        }</span>

        <span class="cov8" title="1">if request.Bucket == nil </span><span class="cov8" title="1">{
                return nil, NewErrParamNull("request.Bucket")
        }</span>

        <span class="cov8" title="1">if request.Key == nil </span><span class="cov8" title="1">{
                return nil, NewErrParamNull("request.Key")
        }</span>

        <span class="cov8" title="1">d := uploaderDelegate{
                options: u.options,
                client:  u.client,
                context: ctx,
                request: request,
        }

        for _, opt := range optFns </span><span class="cov8" title="1">{
                opt(&amp;d.options)
        }</span>

        <span class="cov8" title="1">if d.options.ParallelNum &lt;= 0 </span><span class="cov8" title="1">{
                d.options.ParallelNum = DefaultUploadParallel
        }</span>
        <span class="cov8" title="1">if d.options.PartSize &lt;= 0 </span><span class="cov8" title="1">{
                d.options.PartSize = DefaultUploadPartSize
        }</span>

        <span class="cov8" title="1">return &amp;d, nil</span>
}

func (u *uploaderDelegate) checkSource(filePath string) error <span class="cov8" title="1">{
        if filePath == "" </span><span class="cov0" title="0">{
                return NewErrParamRequired("filePath")
        }</span>

        <span class="cov8" title="1">if !FileExists(filePath) </span><span class="cov8" title="1">{
                return fmt.Errorf("File not exists, %v", filePath)
        }</span>

        <span class="cov8" title="1">info, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">u.filePath = filePath
        u.fileInfo = info

        return nil</span>
}

func (u *uploaderDelegate) applySource() error <span class="cov8" title="1">{
        if u.body == nil </span><span class="cov8" title="1">{
                return NewErrParamNull("the body is null")
        }</span>

        <span class="cov8" title="1">totalSize := getReaderLen(u.body)

        //Part Size
        partSize := u.options.PartSize
        if totalSize &gt; 0 </span><span class="cov8" title="1">{
                for totalSize/partSize &gt;= int64(MaxUploadParts) </span><span class="cov8" title="1">{
                        partSize += u.options.PartSize
                }</span>
        }

        <span class="cov8" title="1">u.totalSize = totalSize
        u.options.PartSize = partSize

        return nil</span>
}

func (u *uploaderDelegate) adjustSource() error <span class="cov8" title="1">{
        // resume from upload id
        if u.uploadId != "" </span><span class="cov8" title="1">{
                // if the body supports seek
                r, ok := u.body.(io.Seeker)
                // not support
                if !ok </span><span class="cov0" title="0">{
                        u.uploadId = ""
                        return nil
                }</span>

                // if upload id is valid
                <span class="cov8" title="1">paginator := u.client.NewListPartsPaginator(&amp;ListPartsRequest{
                        Bucket:   u.request.Bucket,
                        Key:      u.request.Key,
                        UploadId: Ptr(u.uploadId),
                })

                // find consecutive sequence from min part number
                var (
                        checkPartNumber int32 = 1
                )
        outerLoop:
                for paginator.HasNext() </span><span class="cov8" title="1">{
                        page, err := paginator.NextPage(u.context, u.options.ClientOptions...)
                        if err != nil </span><span class="cov8" title="1">{
                                u.uploadId = ""
                                return nil
                        }</span>
                        <span class="cov8" title="1">for _, p := range page.Parts </span><span class="cov8" title="1">{
                                if p.PartNumber != checkPartNumber ||
                                        p.Size != u.options.PartSize </span><span class="cov8" title="1">{
                                        break outerLoop</span>
                                }
                                <span class="cov8" title="1">checkPartNumber++</span>
                        }
                }

                <span class="cov8" title="1">partNumber := checkPartNumber - 1
                newOffset := int64(partNumber) * u.options.PartSize
                if _, err := r.Seek(newOffset, io.SeekStart); err != nil </span><span class="cov0" title="0">{
                        u.uploadId = ""
                        return nil
                }</span>
                <span class="cov8" title="1">u.partNumber = partNumber
                u.readerPos = newOffset</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (d *uploaderDelegate) checkCheckpoint() error <span class="cov8" title="1">{
        if d.options.EnableCheckpoint </span><span class="cov8" title="1">{
                d.checkpoint = newUploadCheckpoint(d.request, d.filePath, d.options.CheckpointDir, d.fileInfo, d.options.PartSize)
                if err := d.checkpoint.load(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if d.checkpoint.Loaded </span><span class="cov8" title="1">{
                        d.uploadId = d.checkpoint.Info.Data.UploadInfo.UploadId
                }</span>
                <span class="cov8" title="1">d.options.LeavePartsOnError = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (d *uploaderDelegate) openReader() (*os.File, error) <span class="cov8" title="1">{
        file, err := os.Open(d.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">d.body = file
        return file, nil</span>
}

func (d *uploaderDelegate) closeReader(file *os.File, err error) error <span class="cov8" title="1">{
        if file != nil </span><span class="cov8" title="1">{
                file.Close()
        }</span>

        <span class="cov8" title="1">if d.checkpoint != nil &amp;&amp; err == nil </span><span class="cov8" title="1">{
                d.checkpoint.remove()
        }</span>

        <span class="cov8" title="1">d.body = nil
        d.checkpoint = nil

        return err</span>
}

func (u *uploaderDelegate) upload() (*UploadResult, error) <span class="cov8" title="1">{
        if u.totalSize &gt;= 0 &amp;&amp; u.totalSize &lt; u.options.PartSize </span><span class="cov8" title="1">{
                return u.singlePart()
        }</span>
        <span class="cov8" title="1">return u.multiPart()</span>
}

func (u *uploaderDelegate) singlePart() (*UploadResult, error) <span class="cov8" title="1">{
        request := &amp;PutObjectRequest{}
        copyRequest(request, u.request)
        request.Body = u.body
        if request.ContentType == nil </span><span class="cov8" title="1">{
                request.ContentType = u.getContentType()
        }</span>

        <span class="cov8" title="1">result, err := u.client.PutObject(u.context, request, u.options.ClientOptions...)

        if err != nil </span><span class="cov8" title="1">{
                return nil, u.wrapErr("", err)
        }</span>

        <span class="cov8" title="1">return &amp;UploadResult{
                ETag:         result.ETag,
                VersionId:    result.VersionId,
                HashCRC64:    result.HashCRC64,
                ResultCommon: result.ResultCommon,
        }, nil</span>
}

func (u *uploaderDelegate) nextReader() (io.ReadSeeker, int, func(), error) <span class="cov8" title="1">{
        type readerAtSeeker interface {
                io.ReaderAt
                io.ReadSeeker
        }
        switch r := u.body.(type) </span>{
        case readerAtSeeker:<span class="cov8" title="1">
                var err error

                n := u.options.PartSize
                if u.totalSize &gt;= 0 </span><span class="cov8" title="1">{
                        bytesLeft := u.totalSize - u.readerPos
                        if bytesLeft &lt;= u.options.PartSize </span><span class="cov8" title="1">{
                                err = io.EOF
                                n = bytesLeft
                        }</span>
                }

                <span class="cov8" title="1">reader := io.NewSectionReader(r, u.readerPos, n)
                cleanup := func() </span>{<span class="cov8" title="1">}</span>

                <span class="cov8" title="1">u.readerPos += n

                return reader, int(n), cleanup, err</span>

        default:<span class="cov8" title="1">
                if u.partPool == nil </span><span class="cov8" title="1">{
                        u.partPool = newByteSlicePool(u.options.PartSize)
                        u.partPool.ModifyCapacity(u.options.ParallelNum + 1)
                }</span>

                <span class="cov8" title="1">part, err := u.partPool.Get(u.context)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, func() </span>{<span class="cov0" title="0">}</span>, err
                }

                <span class="cov8" title="1">n, err := readFill(r, *part)
                u.readerPos += int64(n)

                cleanup := func() </span><span class="cov8" title="1">{
                        u.partPool.Put(part)
                }</span>

                <span class="cov8" title="1">return bytes.NewReader((*part)[0:n]), n, cleanup, err</span>
        }
}

type uploaderChunk struct {
        partNum int32
        body    io.ReadSeeker
        cleanup func()
}

func (u *uploaderDelegate) multiPart() (*UploadResult, error) <span class="cov8" title="1">{
        release := func() </span><span class="cov8" title="1">{
                if u.partPool != nil </span><span class="cov8" title="1">{
                        u.partPool.Close()
                }</span>
        }
        <span class="cov8" title="1">defer release()

        var (
                wg       sync.WaitGroup
                mu       sync.Mutex
                parts    UploadParts
                errValue atomic.Value
        )

        // Init the multipart
        uploadId, startPartNum, err := u.getUploadId()
        if err != nil </span><span class="cov8" title="1">{
                return nil, u.wrapErr("", err)
        }</span>
        //fmt.Printf("getUploadId result: %v, %#v\n", uploadId, err)

        // Update Checkpoint
        <span class="cov8" title="1">if u.checkpoint != nil </span><span class="cov8" title="1">{
                u.checkpoint.Info.Data.UploadInfo.UploadId = uploadId
                u.checkpoint.dump()
        }</span>

        <span class="cov8" title="1">saveErrFn := func(e error) </span><span class="cov8" title="1">{
                errValue.Store(e)
        }</span>

        <span class="cov8" title="1">getErrFn := func() error </span><span class="cov8" title="1">{
                v := errValue.Load()
                if v == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">e, _ := v.(error)
                return e</span>
        }

        // readChunk runs in worker goroutines to pull chunks off of the ch channel
        <span class="cov8" title="1">readChunkFn := func(ch chan uploaderChunk) </span><span class="cov8" title="1">{
                defer wg.Done()
                for </span><span class="cov8" title="1">{
                        data, ok := &lt;-ch
                        if !ok </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov8" title="1">if getErrFn() == nil </span><span class="cov8" title="1">{
                                upResult, err := u.client.UploadPart(u.context, &amp;UploadPartRequest{
                                        Bucket:     u.request.Bucket,
                                        Key:        u.request.Key,
                                        UploadId:   Ptr(uploadId),
                                        PartNumber: data.partNum,
                                        RequestCommon: RequestCommon{
                                                Body: data.body,
                                        }}, u.options.ClientOptions...)

                                //fmt.Printf("UploadPart result: %#v, %#v\n", upResult, err)

                                if err == nil </span><span class="cov8" title="1">{
                                        mu.Lock()
                                        parts = append(parts, UploadPart{ETag: upResult.ETag, PartNumber: data.partNum})
                                        mu.Unlock()
                                }</span> else<span class="cov8" title="1"> {
                                        saveErrFn(err)
                                }</span>
                        }
                        <span class="cov8" title="1">data.cleanup()</span>
                }
        }

        <span class="cov8" title="1">ch := make(chan uploaderChunk, u.options.ParallelNum)
        for i := 0; i &lt; u.options.ParallelNum; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go readChunkFn(ch)
        }</span>

        // Read and queue the parts
        <span class="cov8" title="1">var (
                qnum int32 = startPartNum
                qerr error = nil
        )
        for getErrFn() == nil &amp;&amp; qerr == nil </span><span class="cov8" title="1">{
                var (
                        reader       io.ReadSeeker
                        nextChunkLen int
                        cleanup      func()
                )

                reader, nextChunkLen, cleanup, qerr = u.nextReader()
                // check err
                if (qerr != nil &amp;&amp; qerr != io.EOF) ||
                        nextChunkLen == 0 </span><span class="cov0" title="0">{
                        cleanup()
                        saveErrFn(qerr)
                        break</span>
                }
                <span class="cov8" title="1">qnum++
                //fmt.Printf("send chunk: %d\n", qnum)
                ch &lt;- uploaderChunk{body: reader, partNum: qnum, cleanup: cleanup}</span>
        }

        // Close the channel, wait for workers
        <span class="cov8" title="1">close(ch)
        wg.Wait()

        // Complete upload
        var cmResult *CompleteMultipartUploadResult
        if err = getErrFn(); err == nil </span><span class="cov8" title="1">{
                sort.Sort(parts)
                cmRequest := &amp;CompleteMultipartUploadRequest{}
                copyRequest(cmRequest, u.request)
                cmRequest.UploadId = Ptr(uploadId)
                cmRequest.CompleteMultipartUpload = &amp;CompleteMultipartUpload{Parts: parts}
                cmResult, err = u.client.CompleteMultipartUpload(u.context, cmRequest, u.options.ClientOptions...)
        }</span>
        //fmt.Printf("CompleteMultipartUpload cmResult: %#v, %#v\n", cmResult, err)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                //Abort
                if !u.options.LeavePartsOnError </span><span class="cov8" title="1">{
                        abortRequest := &amp;AbortMultipartUploadRequest{}
                        copyRequest(abortRequest, u.request)
                        abortRequest.UploadId = Ptr(uploadId)
                        _, _ = u.client.AbortMultipartUpload(u.context, abortRequest, u.options.ClientOptions...)
                }</span>
                <span class="cov8" title="1">return nil, u.wrapErr(uploadId, err)</span>
        }

        <span class="cov8" title="1">return &amp;UploadResult{
                UploadId:     Ptr(uploadId),
                ETag:         cmResult.ETag,
                VersionId:    cmResult.VersionId,
                HashCRC64:    cmResult.HashCRC64,
                ResultCommon: cmResult.ResultCommon,
        }, nil</span>
}

func (u *uploaderDelegate) getUploadId() (uploadId string, startNum int32, err error) <span class="cov8" title="1">{
        if u.uploadId != "" </span><span class="cov8" title="1">{
                return u.uploadId, u.partNumber, nil
        }</span>

        // if not exist or fail, create a new upload id
        <span class="cov8" title="1">request := &amp;InitiateMultipartUploadRequest{}
        copyRequest(request, u.request)
        if request.ContentType == nil </span><span class="cov8" title="1">{
                request.ContentType = u.getContentType()
        }</span>

        <span class="cov8" title="1">result, err := u.client.InitiateMultipartUpload(u.context, request, u.options.ClientOptions...)
        if err != nil </span><span class="cov8" title="1">{
                return "", 0, err
        }</span>

        <span class="cov8" title="1">return *result.UploadId, 0, nil</span>
}

func (u *uploaderDelegate) getContentType() *string <span class="cov8" title="1">{
        if u.filePath != "" </span><span class="cov8" title="1">{
                if contentType := TypeByExtension(u.filePath); contentType != "" </span><span class="cov8" title="1">{
                        return Ptr(contentType)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (u *uploaderDelegate) wrapErr(uploadId string, err error) error <span class="cov8" title="1">{
        return &amp;UploadError{
                UploadId: uploadId,
                Path:     fmt.Sprintf("oss://%s/%s", *u.request.Bucket, *u.request.Key),
                Err:      err}
}</span>

type DownloaderOptions struct {
        PartSize int64

        ParallelNum int

        EnableCheckpoint bool

        CheckpointDir string

        UseTempFile bool

        ClientOptions []func(*Options)
}

type Downloader struct {
        options DownloaderOptions
        client  *Client
}

func (c *Client) NewDownloader(optFns ...func(*DownloaderOptions)) *Downloader <span class="cov8" title="1">{
        options := DownloaderOptions{
                PartSize:    DefaultUploadPartSize,
                ParallelNum: DefaultUploadParallel,
                UseTempFile: true,
        }

        for _, fn := range optFns </span><span class="cov8" title="1">{
                fn(&amp;options)
        }</span>

        <span class="cov8" title="1">u := &amp;Downloader{
                client:  c,
                options: options,
        }

        return u</span>
}

type DownloadRequest struct {
        // The name of the bucket.
        Bucket *string `input:"host,bucket,required"`

        // The name of the object.
        Key *string `input:"path,key,required"`

        // If the ETag specified in the request matches the ETag value of the object,
        // the object and 200 OK are returned. Otherwise, 412 Precondition Failed is returned.
        IfMatch *string `input:"header,If-Match"`

        // If the ETag specified in the request does not match the ETag value of the object,
        // the object and 200 OK are returned. Otherwise, 304 Not Modified is returned.
        IfNoneMatch *string `input:"header,If-None-Match"`

        // If the time specified in this header is earlier than the object modified time or is invalid,
        // the object and 200 OK are returned. Otherwise, 304 Not Modified is returned.
        // The time must be in GMT. Example: Fri, 13 Nov 2015 14:47:53 GMT.
        IfModifiedSince *string `input:"header,If-Modified-Since"`

        // If the time specified in this header is the same as or later than the object modified time,
        // the object and 200 OK are returned. Otherwise, 412 Precondition Failed is returned.
        // The time must be in GMT. Example: Fri, 13 Nov 2015 14:47:53 GMT.
        IfUnmodifiedSince *string `input:"header,If-Unmodified-Since"`

        // The content range of the object to be returned.
        // If the value of Range is valid, the total size of the object and the content range are returned.
        // For example, Content-Range: bytes 0~9/44 indicates that the total size of the object is 44 bytes,
        // and the range of data returned is the first 10 bytes.
        // However, if the value of Range is invalid, the entire object is returned,
        // and the response does not include the Content-Range parameter.
        Range *string `input:"header,Range"`

        // The cache-control header to be returned in the response.
        ResponseCacheControl *string `input:"query,response-cache-control"`

        // The content-disposition header to be returned in the response.
        ResponseContentDisposition *string `input:"query,response-content-disposition"`

        // The content-encoding header to be returned in the response.
        ResponseContentEncoding *string `input:"query,response-content-encoding"`

        // The content-language header to be returned in the response.
        ResponseContentLanguage *string `input:"query,response-content-language"`

        // The content-type header to be returned in the response.
        ResponseContentType *string `input:"query,response-content-type"`

        // The expires header to be returned in the response.
        ResponseExpires *string `input:"query,response-expires"`

        // VersionId used to reference a specific version of the object.
        VersionId *string `input:"query,versionId"`

        // Specify the speed limit value. The speed limit value ranges from 245760 to 838860800, with a unit of bit/s.
        TrafficLimit int64 `input:"header,x-oss-traffic-limit"`
}

type DownloadResult struct {
        Written int64
}

type DownloadError struct {
        Err  error
        Path string
}

func (m *DownloadError) Error() string <span class="cov8" title="1">{
        var extra string
        if m.Err != nil </span><span class="cov8" title="1">{
                extra = fmt.Sprintf(", cause: %s", m.Err.Error())
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("download failed, %s", extra)</span>
}

func (m *DownloadError) Unwrap() error <span class="cov0" title="0">{
        return m.Err
}</span>

func (d *Downloader) DownloadFile(ctx context.Context, request *DownloadRequest, filePath string, optFns ...func(*DownloaderOptions)) (result *DownloadResult, err error) <span class="cov8" title="1">{
        // Downloader wrapper
        delegate, err := d.newDelegate(ctx, request, optFns...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Source
        <span class="cov8" title="1">if err = delegate.checkSource(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Destination
        <span class="cov8" title="1">if err = delegate.checkDestination(filePath); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Range
        <span class="cov8" title="1">if err = delegate.adjustRange(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Checkpoint
        <span class="cov8" title="1">if err = delegate.checkCheckpoint(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // open file to write
        <span class="cov8" title="1">var file *os.File
        file, err = delegate.openWriter()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // download
        <span class="cov8" title="1">result, err = delegate.download()

        return result, delegate.closeWriter(file, err)</span>
}

type downloaderDelegate struct {
        options DownloaderOptions
        client  *Client
        context context.Context

        m sync.Mutex

        request DownloadRequest
        w       io.WriterAt
        rstart  int64
        pos     int64
        epos    int64
        written int64

        // Source's Info
        sizeInBytes int64
        etag        string
        modTime     string
        headers     http.Header

        //Destination's Info
        filePath     string
        tempFilePath string

        checkpoint *downloadCheckpoint
}

type downloaderChunk struct {
        w      io.WriterAt
        start  int64
        size   int64
        cur    int64
        rstart int64 //range start
}

type downloadedChunk struct {
        start int64
        size  int64
        crc64 uint64
}

type downloadedChunks []downloadedChunk

func (slice downloadedChunks) Len() int <span class="cov8" title="1">{
        return len(slice)
}</span>
func (slice downloadedChunks) Less(i, j int) bool <span class="cov8" title="1">{
        return slice[i].start &lt; slice[j].start
}</span>
func (slice downloadedChunks) Swap(i, j int) <span class="cov8" title="1">{
        slice[i], slice[j] = slice[j], slice[i]
}</span>

func (c *downloaderChunk) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        if c.cur &gt;= c.size </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>

        <span class="cov8" title="1">n, err = c.w.WriteAt(p, c.start+c.cur-c.rstart)
        c.cur += int64(n)
        return</span>
}

func (d *Downloader) newDelegate(ctx context.Context, request *DownloadRequest, optFns ...func(*DownloaderOptions)) (*downloaderDelegate, error) <span class="cov8" title="1">{
        if request == nil </span><span class="cov8" title="1">{
                return nil, NewErrParamNull("request")
        }</span>

        <span class="cov8" title="1">if !isValidBucketName(request.Bucket) </span><span class="cov8" title="1">{
                return nil, NewErrParamInvalid("request.Bucket")
        }</span>

        <span class="cov8" title="1">if !isValidObjectName(request.Key) </span><span class="cov8" title="1">{
                return nil, NewErrParamInvalid("request.Key")
        }</span>

        <span class="cov8" title="1">if request.Range != nil &amp;&amp; !isValidRange(request.Range) </span><span class="cov8" title="1">{
                return nil, NewErrParamInvalid("request.Range")
        }</span>

        <span class="cov8" title="1">delegate := downloaderDelegate{
                options: d.options,
                client:  d.client,
                context: ctx,
                request: *request,
        }

        for _, opt := range optFns </span><span class="cov8" title="1">{
                opt(&amp;delegate.options)
        }</span>

        <span class="cov8" title="1">if delegate.options.ParallelNum &lt;= 0 </span><span class="cov8" title="1">{
                delegate.options.ParallelNum = DefaultDownloadParallel
        }</span>
        <span class="cov8" title="1">if delegate.options.PartSize &lt;= 0 </span><span class="cov8" title="1">{
                delegate.options.PartSize = DefaultDownloadPartSize
        }</span>

        <span class="cov8" title="1">return &amp;delegate, nil</span>
}

func (d *downloaderDelegate) checkSource() error <span class="cov8" title="1">{
        var request HeadObjectRequest
        copyRequest(&amp;request, &amp;d.request)
        result, err := d.client.HeadObject(d.context, &amp;request, d.options.ClientOptions...)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">d.sizeInBytes = result.ContentLength
        d.modTime = result.Headers.Get(HTTPHeaderLastModified)
        d.etag = result.Headers.Get(HTTPHeaderETag)
        d.headers = result.Headers

        return nil</span>
}

func (d *downloaderDelegate) checkDestination(filePath string) error <span class="cov8" title="1">{
        if filePath == "" </span><span class="cov8" title="1">{
                return NewErrParamInvalid("filePath")
        }</span>
        <span class="cov8" title="1">absFilePath, err := filepath.Abs(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // use temporary file
        <span class="cov8" title="1">tempFilePath := absFilePath
        if d.options.UseTempFile </span><span class="cov8" title="1">{
                tempFilePath += TempFileSuffix
        }</span>
        <span class="cov8" title="1">d.filePath = absFilePath
        d.tempFilePath = tempFilePath

        // use openfile to check the filepath is valid
        var file *os.File
        if file, err = os.OpenFile(tempFilePath, os.O_WRONLY|os.O_CREATE, FilePermMode); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">file.Close()

        return nil</span>
}

func (d *downloaderDelegate) openWriter() (*os.File, error) <span class="cov8" title="1">{
        file, err := os.OpenFile(d.tempFilePath, os.O_WRONLY|os.O_CREATE, FilePermMode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err = file.Truncate(d.pos - d.rstart); err != nil </span><span class="cov0" title="0">{
                file.Close()
                return nil, err
        }</span>

        <span class="cov8" title="1">d.w = file
        return file, nil</span>
}

func (d *downloaderDelegate) closeWriter(file *os.File, err error) error <span class="cov8" title="1">{
        if file != nil </span><span class="cov8" title="1">{
                file.Close()
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if d.checkpoint == nil </span><span class="cov8" title="1">{
                        os.Remove(d.tempFilePath)
                }</span>
        } else<span class="cov8" title="1"> {
                if d.tempFilePath != d.filePath </span><span class="cov8" title="1">{
                        err = os.Rename(d.tempFilePath, d.filePath)
                }</span>
                <span class="cov8" title="1">if err == nil &amp;&amp; d.checkpoint != nil </span><span class="cov8" title="1">{
                        d.checkpoint.remove()
                }</span>
        }

        <span class="cov8" title="1">d.w = nil
        d.checkpoint = nil

        return err</span>
}

func (d *downloaderDelegate) adjustRange() error <span class="cov8" title="1">{
        d.pos = 0
        d.rstart = 0
        d.epos = d.sizeInBytes
        if d.request.Range != nil </span><span class="cov8" title="1">{
                httpRange, _ := ParseRange(*d.request.Range)
                if httpRange.Offset &gt;= d.sizeInBytes </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid range, object size :%v, range: %v", d.sizeInBytes, ToString(d.request.Range))
                }</span>
                <span class="cov8" title="1">d.pos = httpRange.Offset
                d.rstart = d.pos
                if httpRange.Count &gt; 0 </span><span class="cov8" title="1">{
                        d.epos = minInt64(httpRange.Offset+httpRange.Count, d.sizeInBytes)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (d *downloaderDelegate) checkCheckpoint() error <span class="cov8" title="1">{
        if d.options.EnableCheckpoint </span><span class="cov8" title="1">{
                d.checkpoint = newDownloadCheckpoint(&amp;d.request, d.tempFilePath, d.options.CheckpointDir, d.headers, d.options.PartSize)
                if err := d.checkpoint.load(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if d.checkpoint.Loaded </span><span class="cov8" title="1">{
                        d.pos = d.checkpoint.Info.Data.DownloadInfo.Offset
                        d.written = d.pos - d.rstart
                }</span> else<span class="cov8" title="1"> {
                        d.checkpoint.Info.Data.DownloadInfo.Offset = d.pos
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (d *downloaderDelegate) download() (*DownloadResult, error) <span class="cov8" title="1">{
        var (
                wg       sync.WaitGroup
                errValue atomic.Value
                cpCh     chan downloadedChunk
                cpWg     sync.WaitGroup
                cpChunks downloadedChunks
        )

        saveErrFn := func(e error) </span><span class="cov8" title="1">{
                errValue.Store(e)
        }</span>

        <span class="cov8" title="1">getErrFn := func() error </span><span class="cov8" title="1">{
                v := errValue.Load()
                if v == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">e, _ := v.(error)
                return e</span>
        }

        // writeChunkFn runs in worker goroutines to pull chunks off of the ch channel
        <span class="cov8" title="1">writeChunkFn := func(ch chan downloaderChunk) </span><span class="cov8" title="1">{
                defer wg.Done()
                for </span><span class="cov8" title="1">{
                        chunk, ok := &lt;-ch
                        if !ok </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov8" title="1">if getErrFn() != nil </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">dchunk, derr := d.downloadChunk(chunk)

                        if derr != nil &amp;&amp; derr != io.EOF </span><span class="cov8" title="1">{
                                saveErrFn(derr)
                        }</span> else<span class="cov8" title="1"> {
                                // update checkpoint
                                if d.checkpoint != nil </span><span class="cov8" title="1">{
                                        cpCh &lt;- dchunk
                                }</span>
                        }
                }
        }

        // checkpointFn runs in worker goroutines to update checkpoint info
        <span class="cov8" title="1">checkpointFn := func(ch chan downloadedChunk) </span><span class="cov8" title="1">{
                defer cpWg.Done()
                for </span><span class="cov8" title="1">{
                        chunk, ok := &lt;-ch
                        if !ok </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">cpChunks = append(cpChunks, chunk)
                        sort.Sort(cpChunks)
                        newOffset := d.checkpoint.Info.Data.DownloadInfo.Offset
                        i := 0
                        for ii := range cpChunks </span><span class="cov8" title="1">{
                                if cpChunks[ii].start == newOffset </span><span class="cov8" title="1">{
                                        newOffset += cpChunks[ii].size
                                        i++
                                }</span> else<span class="cov8" title="1"> {
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if newOffset != d.checkpoint.Info.Data.DownloadInfo.Offset </span><span class="cov8" title="1">{
                                //remove updated chunk in cpChunks
                                cpChunks = cpChunks[i:]
                                d.checkpoint.Info.Data.DownloadInfo.Offset = newOffset
                                d.checkpoint.dump()
                        }</span>
                }
        }

        // Start the download workers
        <span class="cov8" title="1">ch := make(chan downloaderChunk, d.options.ParallelNum)
        for i := 0; i &lt; d.options.ParallelNum; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go writeChunkFn(ch)
        }</span>

        // Start checkpoint worker if enable checkpoint
        <span class="cov8" title="1">if d.checkpoint != nil </span><span class="cov8" title="1">{
                cpCh = make(chan downloadedChunk, 1)
                cpWg.Add(1)
                go checkpointFn(cpCh)
        }</span>

        // Queue the next range of bytes to read.
        <span class="cov8" title="1">for getErrFn() == nil </span><span class="cov8" title="1">{
                if d.pos &gt;= d.epos </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">size := minInt64(d.epos-d.pos, d.options.PartSize)
                ch &lt;- downloaderChunk{w: d.w, start: d.pos, size: size, rstart: d.rstart}
                d.pos += size</span>
        }

        // Waiting for parts download finished
        <span class="cov8" title="1">close(ch)
        wg.Wait()

        if d.checkpoint != nil </span><span class="cov8" title="1">{
                close(cpCh)
                cpWg.Wait()
        }</span>

        <span class="cov8" title="1">if err := getErrFn(); err != nil </span><span class="cov8" title="1">{
                return nil, &amp;DownloadError{
                        Err:  err,
                        Path: fmt.Sprintf("oss://%s/%s", ToString(d.request.Bucket), ToString(d.request.Key)),
                }
        }</span>

        <span class="cov8" title="1">return &amp;DownloadResult{
                Written: d.written,
        }, nil</span>
}

func (d *downloaderDelegate) incrWritten(n int64) <span class="cov8" title="1">{
        d.m.Lock()
        defer d.m.Unlock()

        d.written += n
}</span>

func (d *downloaderDelegate) downloadChunk(chunk downloaderChunk) (downloadedChunk, error) <span class="cov8" title="1">{
        // Get the next byte range of data
        var request GetObjectRequest
        copyRequest(&amp;request, &amp;d.request)

        getFn := func(ctx context.Context, httpRange HTTPRange) (output *ReaderRangeGetOutput, err error) </span><span class="cov8" title="1">{
                // update range
                request.Range = nil
                rangeStr := httpRange.FormatHTTPRange()
                request.RangeBehavior = nil
                if rangeStr != nil </span><span class="cov8" title="1">{
                        request.Range = rangeStr
                        request.RangeBehavior = Ptr("standard")
                }</span>

                <span class="cov8" title="1">result, err := d.client.GetObject(ctx, &amp;request, d.options.ClientOptions...)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return &amp;ReaderRangeGetOutput{
                        Body:          result.Body,
                        ETag:          result.ETag,
                        ContentLength: result.ContentLength,
                        ContentRange:  result.ContentRange,
                }, nil</span>
        }

        <span class="cov8" title="1">reader, _ := NewRangeReader(d.context, getFn, &amp;HTTPRange{chunk.start, chunk.size}, d.etag)
        n, err := io.Copy(&amp;chunk, reader)
        d.incrWritten(n)

        return downloadedChunk{
                start: chunk.start,
                size:  n,
                crc64: uint64(0),
        }, err</span>
}

// ----- download chcekpoint  -----
type downloadCheckpoint struct {
        CpDirPath  string // checkpoint dir full path
        CpFilePath string // checkpoint file full path
        VerifyData bool   // verify donwloaded data in FilePath
        Loaded     bool   // If Info.Data.DownloadInfo is loaded from checkpoint

        Info struct { //checkpoint data
                Magic string // Magic
                MD5   string // The Data's MD5
                Data  struct {
                        // source
                        ObjectInfo struct {
                                Name      string // oss://bucket/key
                                VersionId string
                                Range     string
                        }
                        ObjectMeta struct {
                                Size         int64
                                LastModified string
                                ETag         string
                        }

                        // destination
                        FilePath string // Local file

                        // download info
                        PartSize int64

                        DownloadInfo struct {
                                Offset int64
                                CRC64  uint64
                        }
                }
        }
}

func newDownloadCheckpoint(request *DownloadRequest, filePath string, baseDir string, header http.Header, partSize int64) *downloadCheckpoint <span class="cov8" title="1">{
        var buf strings.Builder
        name := fmt.Sprintf("%v/%v", ToString(request.Bucket), ToString(request.Key))
        buf.WriteString("oss://" + escapePath(name, false))
        buf.WriteString("\n")
        buf.WriteString(ToString(request.VersionId))
        buf.WriteString("\n")
        buf.WriteString(ToString(request.Range))

        hashmd5 := md5.New()
        hashmd5.Write([]byte(buf.String()))
        srcHash := hex.EncodeToString(hashmd5.Sum(nil))

        absPath, _ := filepath.Abs(filePath)
        hashmd5.Reset()
        hashmd5.Write([]byte(absPath))
        destHash := hex.EncodeToString(hashmd5.Sum(nil))

        var dir string
        if baseDir == "" </span><span class="cov0" title="0">{
                dir = os.TempDir()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(baseDir)
        }</span>

        <span class="cov8" title="1">cpFilePath := filepath.Join(dir, fmt.Sprintf("%v-%v.dcp", srcHash, destHash))

        cp := &amp;downloadCheckpoint{
                CpFilePath: cpFilePath,
                CpDirPath:  dir,
        }

        objectSize, _ := strconv.ParseInt(header.Get("Content-Length"), 10, 64)

        cp.Info.Magic = CheckpointMagic
        cp.Info.Data.ObjectInfo.Name = "oss://" + name
        cp.Info.Data.ObjectInfo.VersionId = ToString(request.VersionId)
        cp.Info.Data.ObjectInfo.Range = ToString(request.Range)
        cp.Info.Data.ObjectMeta.Size = objectSize
        cp.Info.Data.ObjectMeta.LastModified = header.Get("Last-Modified")
        cp.Info.Data.ObjectMeta.ETag = header.Get("ETag")
        cp.Info.Data.FilePath = filePath
        cp.Info.Data.PartSize = partSize

        return cp</span>
}

// load checkpoint from local file
func (cp *downloadCheckpoint) load() error <span class="cov8" title="1">{
        if !DirExists(cp.CpDirPath) </span><span class="cov8" title="1">{
                return fmt.Errorf("Invaid checkpoint dir, %v", cp.CpDirPath)
        }</span>

        <span class="cov8" title="1">if !FileExists(cp.CpFilePath) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if !cp.valid() </span><span class="cov8" title="1">{
                cp.remove()
                return nil
        }</span>

        <span class="cov8" title="1">cp.Loaded = true

        return nil</span>
}

func (cp *downloadCheckpoint) valid() bool <span class="cov8" title="1">{
        // Compare the CP's Magic and the MD5
        contents, err := os.ReadFile(cp.CpFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">dcp := downloadCheckpoint{}

        if err = json.Unmarshal(contents, &amp;dcp.Info); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">js, _ := json.Marshal(dcp.Info.Data)
        sum := md5.Sum(js)
        md5sum := hex.EncodeToString(sum[:])

        if CheckpointMagic != dcp.Info.Magic ||
                md5sum != dcp.Info.MD5 </span><span class="cov8" title="1">{
                return false
        }</span>

        // compare
        <span class="cov8" title="1">if !reflect.DeepEqual(cp.Info.Data.ObjectInfo, dcp.Info.Data.ObjectInfo) ||
                !reflect.DeepEqual(cp.Info.Data.ObjectMeta, dcp.Info.Data.ObjectMeta) ||
                cp.Info.Data.FilePath != dcp.Info.Data.FilePath ||
                cp.Info.Data.PartSize != dcp.Info.Data.PartSize </span><span class="cov8" title="1">{
                return false
        }</span>

        // download info
        <span class="cov8" title="1">if dcp.Info.Data.DownloadInfo.Offset &lt; 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if dcp.Info.Data.DownloadInfo.Offset == 0 &amp;&amp;
                dcp.Info.Data.DownloadInfo.CRC64 != 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">rOffset := int64(0)
        if len(cp.Info.Data.ObjectInfo.Range) &gt; 0 </span><span class="cov8" title="1">{
                if r, err := ParseRange(cp.Info.Data.ObjectInfo.Range); err != nil </span><span class="cov0" title="0">{
                        return false
                }</span> else<span class="cov8" title="1"> {
                        rOffset = r.Offset
                }</span>
        }

        <span class="cov8" title="1">if dcp.Info.Data.DownloadInfo.Offset &lt; rOffset </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">remains := (dcp.Info.Data.DownloadInfo.Offset - rOffset) % dcp.Info.Data.PartSize
        if remains != 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        //valid data
        <span class="cov8" title="1">if cp.VerifyData &amp;&amp; dcp.Info.Data.DownloadInfo.CRC64 != 0 </span><span class="cov8" title="1">{
                if file, err := os.Open(cp.Info.Data.FilePath); err == nil </span><span class="cov8" title="1">{
                        hash := NewCRC64(0)
                        limitN := dcp.Info.Data.DownloadInfo.Offset - rOffset
                        io.Copy(hash, io.LimitReader(file, limitN))
                        file.Close()
                        if hash.Sum64() != dcp.Info.Data.DownloadInfo.CRC64 </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }

        // update
        <span class="cov8" title="1">cp.Info.Data.DownloadInfo = dcp.Info.Data.DownloadInfo

        return true</span>
}

// dump dumps to file
func (cp *downloadCheckpoint) dump() error <span class="cov8" title="1">{
        // Calculate MD5
        js, _ := json.Marshal(cp.Info.Data)
        sum := md5.Sum(js)
        md5sum := hex.EncodeToString(sum[:])
        cp.Info.MD5 = md5sum

        // Serialize
        js, err := json.Marshal(cp.Info)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Dump
        <span class="cov8" title="1">return os.WriteFile(cp.CpFilePath, js, FilePermMode)</span>
}

func (cp *downloadCheckpoint) remove() error <span class="cov8" title="1">{
        return os.Remove(cp.CpFilePath)
}</span>

// ----- upload chcekpoint  -----
type uploadCheckpoint struct {
        CpDirPath  string // checkpoint dir full path
        CpFilePath string // checkpoint file full path
        Loaded     bool   // If Info.Data.UploadInfo is loaded from checkpoint

        Info struct { //checkpoint data
                Magic string // Magic
                MD5   string // The Data's MD5
                Data  struct {
                        // source
                        FilePath string // Local file

                        FileMeta struct {
                                Size         int64
                                LastModified string
                        }

                        // destination
                        ObjectInfo struct {
                                Name string // oss://bucket/key
                        }

                        // upload info
                        PartSize int64

                        UploadInfo struct {
                                UploadId string
                        }
                }
        }
}

func newUploadCheckpoint(request *UploadRequest, filePath string, baseDir string, fileInfo os.FileInfo, partSize int64) *uploadCheckpoint <span class="cov8" title="1">{
        name := fmt.Sprintf("%v/%v", ToString(request.Bucket), ToString(request.Key))
        hashmd5 := md5.New()
        hashmd5.Write([]byte("oss://" + escapePath(name, false)))
        destHash := hex.EncodeToString(hashmd5.Sum(nil))

        absPath, _ := filepath.Abs(filePath)
        hashmd5.Reset()
        hashmd5.Write([]byte(absPath))
        srcHash := hex.EncodeToString(hashmd5.Sum(nil))

        var dir string
        if baseDir == "" </span><span class="cov0" title="0">{
                dir = os.TempDir()
        }</span> else<span class="cov8" title="1"> {
                dir = filepath.Dir(baseDir)
        }</span>

        <span class="cov8" title="1">cpFilePath := filepath.Join(dir, fmt.Sprintf("%v-%v.ucp", srcHash, destHash))

        cp := &amp;uploadCheckpoint{
                CpFilePath: cpFilePath,
                CpDirPath:  dir,
        }

        cp.Info.Magic = CheckpointMagic
        cp.Info.Data.FilePath = filePath
        cp.Info.Data.FileMeta.Size = fileInfo.Size()
        cp.Info.Data.FileMeta.LastModified = fileInfo.ModTime().String()
        cp.Info.Data.ObjectInfo.Name = "oss://" + name
        cp.Info.Data.PartSize = partSize

        return cp</span>
}

// load checkpoint from local file
func (cp *uploadCheckpoint) load() error <span class="cov8" title="1">{
        if !DirExists(cp.CpDirPath) </span><span class="cov8" title="1">{
                return fmt.Errorf("Invaid checkpoint dir, %v", cp.CpDirPath)
        }</span>

        <span class="cov8" title="1">if !FileExists(cp.CpFilePath) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if !cp.valid() </span><span class="cov8" title="1">{
                cp.remove()
                return nil
        }</span>

        <span class="cov8" title="1">cp.Loaded = true

        return nil</span>
}

func (cp *uploadCheckpoint) valid() bool <span class="cov8" title="1">{
        // Compare the CP's Magic and the MD5
        contents, err := os.ReadFile(cp.CpFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">dcp := uploadCheckpoint{}

        if err = json.Unmarshal(contents, &amp;dcp.Info); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">js, _ := json.Marshal(dcp.Info.Data)
        sum := md5.Sum(js)
        md5sum := hex.EncodeToString(sum[:])

        if CheckpointMagic != dcp.Info.Magic ||
                md5sum != dcp.Info.MD5 </span><span class="cov8" title="1">{
                return false
        }</span>

        // compare
        <span class="cov8" title="1">if !reflect.DeepEqual(cp.Info.Data.ObjectInfo, dcp.Info.Data.ObjectInfo) ||
                !reflect.DeepEqual(cp.Info.Data.FileMeta, dcp.Info.Data.FileMeta) ||
                cp.Info.Data.FilePath != dcp.Info.Data.FilePath ||
                cp.Info.Data.PartSize != dcp.Info.Data.PartSize </span><span class="cov8" title="1">{
                return false
        }</span>

        // download info
        <span class="cov8" title="1">if len(dcp.Info.Data.UploadInfo.UploadId) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // update
        <span class="cov8" title="1">cp.Info.Data.UploadInfo = dcp.Info.Data.UploadInfo

        return true</span>
}

// dump dumps to file
func (cp *uploadCheckpoint) dump() error <span class="cov8" title="1">{
        // Calculate MD5
        js, _ := json.Marshal(cp.Info.Data)
        sum := md5.Sum(js)
        md5sum := hex.EncodeToString(sum[:])
        cp.Info.MD5 = md5sum

        // Serialize
        js, err := json.Marshal(cp.Info)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Dump
        <span class="cov8" title="1">return os.WriteFile(cp.CpFilePath, js, FilePermMode)</span>
}

func (cp *uploadCheckpoint) remove() error <span class="cov8" title="1">{
        return os.Remove(cp.CpFilePath)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package oss

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "runtime"
        "time"
)

const (
        defaultPrefetchThreshold = int64(20 * 1024 * 1024)
        defaultChunkSize         = int64(8 * 1024 * 1024)
        defaultPrefetchNum       = 3

        defaultPartSize = int64(8 * 1024 * 1024)
)

type OpenOptions struct {
        Offset int64

        VersionId *string

        EnablePrefetch bool
        PrefetchNum    int
        ChunkSize      int64

        PrefetchThreshold int64
}

type ReadOnlyFile struct {
        client  *Client
        context context.Context

        // object info
        bucket    string
        key       string
        versionId *string

        // file info
        sizeInBytes int64
        modTime     string
        etag        string
        headers     http.Header

        // current read position
        offset int64

        // read
        reader        io.ReadCloser
        readBufOffset int64

        // prefetch
        enablePrefetch    bool
        chunkSize         int64
        prefetchNum       int
        prefetchThreshold int64

        asyncReaders  []*AsyncRangeReader
        seqReadAmount int64 // number of sequential read
        numOOORead    int64 // number of out of order read

        closed bool // whether we have closed the file
}

// OpenFile opens the named file for reading.
// If successful, methods on the returned file can be used for reading.
func (c *Client) OpenFile(ctx context.Context, bucket string, key string, optFns ...func(*OpenOptions)) (*ReadOnlyFile, error) <span class="cov8" title="1">{
        options := OpenOptions{
                Offset:            0,
                EnablePrefetch:    false,
                PrefetchNum:       defaultPrefetchNum,
                ChunkSize:         defaultChunkSize,
                PrefetchThreshold: defaultPrefetchThreshold,
        }

        for _, fn := range optFns </span><span class="cov8" title="1">{
                fn(&amp;options)
        }</span>

        <span class="cov8" title="1">if options.EnablePrefetch </span><span class="cov8" title="1">{
                var chunkSize int64
                if options.ChunkSize &gt; 0 </span><span class="cov8" title="1">{
                        chunkSize = (options.ChunkSize + AsyncReadeBufferSize - 1) / AsyncReadeBufferSize * AsyncReadeBufferSize
                }</span> else<span class="cov8" title="1"> {
                        chunkSize = defaultChunkSize
                }</span>
                <span class="cov8" title="1">options.ChunkSize = chunkSize

                if options.PrefetchNum &lt;= 0 </span><span class="cov8" title="1">{
                        options.PrefetchNum = defaultPrefetchNum
                }</span>
        }

        <span class="cov8" title="1">f := &amp;ReadOnlyFile{
                client:  c,
                context: ctx,

                bucket:    bucket,
                key:       key,
                versionId: options.VersionId,

                offset: options.Offset,

                enablePrefetch:    options.EnablePrefetch,
                prefetchNum:       options.PrefetchNum,
                chunkSize:         options.ChunkSize,
                prefetchThreshold: options.PrefetchThreshold,
        }

        result, err := f.client.HeadObject(f.context, &amp;HeadObjectRequest{
                Bucket:    &amp;f.bucket,
                Key:       &amp;f.key,
                VersionId: f.versionId,
        })

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        //File info
        <span class="cov8" title="1">f.sizeInBytes = result.ContentLength
        f.modTime = result.Headers.Get(HTTPHeaderLastModified)
        f.etag = result.Headers.Get(HTTPHeaderETag)
        f.headers = result.Headers

        if f.sizeInBytes &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file size is invaid, got %v", f.sizeInBytes)
        }</span>

        <span class="cov8" title="1">if f.offset &gt; f.sizeInBytes </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("offset is unavailable, offset:%v, file size:%v", f.offset, f.sizeInBytes)
        }</span>

        <span class="cov8" title="1">return f, nil</span>
}

// Close closes the File.
func (f *ReadOnlyFile) Close() error <span class="cov8" title="1">{
        if f == nil </span><span class="cov8" title="1">{
                return os.ErrInvalid
        }</span>
        <span class="cov8" title="1">return f.close()</span>
}

func (f *ReadOnlyFile) close() error <span class="cov8" title="1">{
        if f.closed </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if f.reader != nil </span><span class="cov8" title="1">{
                f.reader.Close()
                f.reader = nil
        }</span>
        <span class="cov8" title="1">for _, reader := range f.asyncReaders </span><span class="cov8" title="1">{
                reader.Close()
        }</span>
        <span class="cov8" title="1">f.asyncReaders = nil

        f.closed = true
        runtime.SetFinalizer(f, nil)
        return nil</span>
}

// Read reads up to len(b) bytes from the File and stores them in b.
// It returns the number of bytes read and any error encountered.
// At end of file, Read returns 0, io.EOF.
func (f *ReadOnlyFile) Read(p []byte) (bytesRead int, err error) <span class="cov8" title="1">{
        if err := f.checkValid("read"); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">n, e := f.read(p)
        return n, f.wrapErr("read", e)</span>
}

func (f *ReadOnlyFile) read(p []byte) (bytesRead int, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                f.offset += int64(bytesRead)
        }</span>()
        <span class="cov8" title="1">nwant := len(p)
        var nread int
        for bytesRead &lt; nwant &amp;&amp; err == nil </span><span class="cov8" title="1">{
                nread, err = f.readInternal(f.offset+int64(bytesRead), p[bytesRead:])
                if nread &gt; 0 </span><span class="cov8" title="1">{
                        bytesRead += nread
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// Seek sets the offset for the next Read or Write on file to offset, interpreted
// according to whence: 0 means relative to the origin of the file, 1 means
// relative to the current offset, and 2 means relative to the end.
// It returns the new offset and an error.
func (f *ReadOnlyFile) Seek(offset int64, whence int) (int64, error) <span class="cov8" title="1">{
        if err := f.checkValid("seek"); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">r, e := f.seek(offset, whence)
        if e != nil </span><span class="cov8" title="1">{
                return 0, f.wrapErr("seek", e)
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (f *ReadOnlyFile) seek(offset int64, whence int) (int64, error) <span class="cov8" title="1">{
        var abs int64
        switch whence </span>{
        case io.SeekStart:<span class="cov8" title="1">
                abs = offset</span>
        case io.SeekCurrent:<span class="cov8" title="1">
                abs = f.offset + offset</span>
        case io.SeekEnd:<span class="cov8" title="1">
                abs = f.sizeInBytes + offset</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("invalid whence")</span>
        }
        <span class="cov8" title="1">if abs &lt; 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("negative position")
        }</span>
        <span class="cov8" title="1">if abs &gt; f.sizeInBytes </span><span class="cov8" title="1">{
                return offset - (abs - f.sizeInBytes), fmt.Errorf("offset is unavailable")
        }</span>

        <span class="cov8" title="1">f.offset = abs

        return abs, nil</span>
}

type fileInfo struct {
        name    string
        size    int64
        modTime time.Time
        header  http.Header
}

func (fi *fileInfo) Name() string       <span class="cov8" title="1">{ return fi.name }</span>
func (fi *fileInfo) Size() int64        <span class="cov8" title="1">{ return fi.size }</span>
func (fi *fileInfo) Mode() os.FileMode  <span class="cov8" title="1">{ return os.FileMode(0644) }</span>
func (fi *fileInfo) ModTime() time.Time <span class="cov8" title="1">{ return fi.modTime }</span>
func (fi *fileInfo) IsDir() bool        <span class="cov8" title="1">{ return false }</span>
func (fi *fileInfo) Sys() any           <span class="cov8" title="1">{ return fi.header }</span>

// Stat returns the FileInfo structure describing file.
func (f *ReadOnlyFile) Stat() (os.FileInfo, error) <span class="cov8" title="1">{
        if err := f.checkValid("stat"); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">mtime, _ := http.ParseTime(f.modTime)
        return &amp;fileInfo{
                name:    f.name(),
                size:    f.sizeInBytes,
                modTime: mtime,
                header:  f.headers,
        }, nil</span>
}

func (f *ReadOnlyFile) name() string <span class="cov8" title="1">{
        var name string
        if f.versionId != nil </span><span class="cov8" title="1">{
                name = fmt.Sprintf("oss://%s/%s?versionId=%s", f.bucket, f.key, *f.versionId)
        }</span> else<span class="cov8" title="1"> {
                name = fmt.Sprintf("oss://%s/%s", f.bucket, f.key)
        }</span>
        <span class="cov8" title="1">return name</span>
}

func (f *ReadOnlyFile) wrapErr(op string, err error) error <span class="cov8" title="1">{
        if err == nil || err == io.EOF </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return &amp;os.PathError{Op: op, Path: f.name(), Err: err}</span>
}

func (f *ReadOnlyFile) checkValid(op string) error <span class="cov8" title="1">{
        if f == nil </span><span class="cov8" title="1">{
                return os.ErrInvalid
        }</span> else<span class="cov8" title="1"> if f.closed </span><span class="cov8" title="1">{
                return os.ErrClosed
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (f *ReadOnlyFile) readInternal(offset int64, p []byte) (bytesRead int, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if bytesRead &gt; 0 </span><span class="cov8" title="1">{
                        f.readBufOffset += int64(bytesRead)
                        f.seqReadAmount += int64(bytesRead)
                }</span>
        }()

        <span class="cov8" title="1">if offset &gt;= f.sizeInBytes </span><span class="cov8" title="1">{
                err = io.EOF
                return
        }</span>

        <span class="cov8" title="1">if f.readBufOffset != offset </span><span class="cov8" title="1">{
                f.readBufOffset = offset
                f.seqReadAmount = 0

                if f.reader != nil </span><span class="cov8" title="1">{
                        f.reader.Close()
                        f.reader = nil
                }</span>

                <span class="cov8" title="1">if f.asyncReaders != nil </span><span class="cov8" title="1">{
                        f.numOOORead++
                }</span>

                <span class="cov8" title="1">for _, ar := range f.asyncReaders </span><span class="cov8" title="1">{
                        ar.Close()
                }</span>
                <span class="cov8" title="1">f.asyncReaders = nil</span>
        }

        <span class="cov8" title="1">if f.enablePrefetch &amp;&amp; f.seqReadAmount &gt;= f.prefetchThreshold &amp;&amp; f.numOOORead &lt; 3 </span><span class="cov8" title="1">{
                //swith to async reader
                if f.reader != nil </span><span class="cov8" title="1">{
                        f.reader.Close()
                        f.reader = nil
                }</span>

                <span class="cov8" title="1">err = f.prefetch(offset, len(p))
                if err == nil </span><span class="cov8" title="1">{
                        bytesRead, err = f.readFromPrefetcher(offset, p)
                        if err == nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                }

                // fall back to read serially
                <span class="cov8" title="1">f.seqReadAmount = 0
                for _, ar := range f.asyncReaders </span><span class="cov8" title="1">{
                        ar.Close()
                }</span>
                <span class="cov8" title="1">f.asyncReaders = nil</span>
        }

        <span class="cov8" title="1">bytesRead, err = f.readDirect(offset, p)
        return</span>
}

func (f *ReadOnlyFile) readDirect(offset int64, buf []byte) (bytesRead int, err error) <span class="cov8" title="1">{
        if offset &gt;= f.sizeInBytes </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if f.reader == nil </span><span class="cov8" title="1">{
                var result *GetObjectResult
                result, err = f.client.GetObject(f.context, &amp;GetObjectRequest{
                        Bucket:        Ptr(f.bucket),
                        Key:           Ptr(f.key),
                        VersionId:     f.versionId,
                        Range:         Ptr(fmt.Sprintf("bytes=%d-", offset)),
                        RangeBehavior: Ptr("standard"),
                })
                if err != nil </span><span class="cov8" title="1">{
                        return bytesRead, err
                }</span>

                <span class="cov8" title="1">if err = f.checkResultValid(offset, result.Headers); err != nil </span><span class="cov8" title="1">{
                        return bytesRead, err
                }</span>

                <span class="cov8" title="1">f.reader = result.Body</span>
        }

        <span class="cov8" title="1">bytesRead, err = f.reader.Read(buf)
        if err != nil </span><span class="cov8" title="1">{
                f.reader.Close()
                f.reader = nil
                err = nil
        }</span>

        <span class="cov8" title="1">return</span>
}

func (f *ReadOnlyFile) checkResultValid(offset int64, header http.Header) error <span class="cov8" title="1">{
        modTime := header.Get(HTTPHeaderLastModified)
        etag := header.Get(HTTPHeaderETag)
        gotOffset, _ := parseOffsetAndSizeFromHeaders(header)
        if gotOffset != offset </span><span class="cov8" title="1">{
                return fmt.Errorf("Range get fail, expect offset:%v, got offset:%v", offset, gotOffset)
        }</span>

        <span class="cov8" title="1">if modTime != f.modTime || etag != f.etag </span><span class="cov8" title="1">{
                return fmt.Errorf("Source file is changed, origin info [%v,%v], new info [%v,%v]",
                        f.modTime, f.etag, modTime, etag)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (f *ReadOnlyFile) readFromPrefetcher(offset int64, buf []byte) (bytesRead int, err error) <span class="cov8" title="1">{
        var nread int
        for len(f.asyncReaders) != 0 </span><span class="cov8" title="1">{
                asyncReader := f.asyncReaders[0]
                //check offset
                if offset != asyncReader.Offset() </span><span class="cov0" title="0">{
                        return 0, errors.New("out of order")
                }</span>
                <span class="cov8" title="1">nread, err = asyncReader.Read(buf)
                bytesRead += nread
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                //fmt.Printf("asyncReader done\n")
                                asyncReader.Close()
                                f.asyncReaders = f.asyncReaders[1:]
                                err = nil
                        }</span> else<span class="cov8" title="1"> {
                                return 0, err
                        }</span>
                }
                <span class="cov8" title="1">buf = buf[nread:]
                if len(buf) == 0 </span><span class="cov8" title="1">{
                        return
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

func (f *ReadOnlyFile) prefetch(offset int64, needAtLeast int) (err error) <span class="cov8" title="1">{
        off := offset
        for _, ar := range f.asyncReaders </span><span class="cov8" title="1">{
                off = ar.oriHttpRange.Offset + ar.oriHttpRange.Count
        }</span>
        //fmt.Printf("prefetch:offset %v, needAtLeast:%v, off:%v\n", offset, needAtLeast, off)
        <span class="cov8" title="1">for len(f.asyncReaders) &lt; f.prefetchNum </span><span class="cov8" title="1">{
                remaining := f.sizeInBytes - off
                size := minInt64(remaining, f.chunkSize)
                cnt := (size + (AsyncReadeBufferSize - 1)) / AsyncReadeBufferSize
                //fmt.Printf("f.sizeInBytes:%v, off:%v, size:%v, cnt:%v\n", f.sizeInBytes, off, size, cnt)
                if size != 0 </span><span class="cov8" title="1">{
                        getFn := func(ctx context.Context, httpRange HTTPRange) (output *ReaderRangeGetOutput, err error) </span><span class="cov8" title="1">{
                                request := &amp;GetObjectRequest{
                                        Bucket:    Ptr(f.bucket),
                                        Key:       Ptr(f.key),
                                        VersionId: f.versionId,
                                }
                                rangeStr := httpRange.FormatHTTPRange()
                                if rangeStr != nil </span><span class="cov8" title="1">{
                                        request.Range = rangeStr
                                        request.RangeBehavior = Ptr("standard")
                                }</span>
                                <span class="cov8" title="1">var result *GetObjectResult
                                result, err = f.client.GetObject(f.context, request)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">return &amp;ReaderRangeGetOutput{
                                        Body:          result.Body,
                                        ETag:          result.ETag,
                                        ContentLength: result.ContentLength,
                                        ContentRange:  result.ContentRange,
                                }, nil</span>
                                //fmt.Printf("result.Headers:%#v\n", result.Headers)
                        }
                        <span class="cov8" title="1">ar, err := NewAsyncRangeReader(f.context, getFn, &amp;HTTPRange{off, size}, f.etag, int(cnt))
                        if err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">f.asyncReaders = append(f.asyncReaders, ar)
                        off += size</span>
                }

                <span class="cov8" title="1">if size != f.chunkSize </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

type AppendOptions struct {
}

type AppendOnlyFile struct {
        client  *Client
        context context.Context

        // object info
        bucket string
        key    string

        info os.FileInfo

        // current write position
        offset int64

        closed bool
}

// AppendFile opens or creates the named file for appending.
// If successful, methods on the returned file can be used for appending.
func (c *Client) AppendFile(ctx context.Context, bucket string, key string, optFns ...func(*AppendOptions)) (*AppendOnlyFile, error) <span class="cov8" title="1">{
        options := AppendOptions{}

        for _, fn := range optFns </span><span class="cov8" title="1">{
                fn(&amp;options)
        }</span>

        <span class="cov8" title="1">f := &amp;AppendOnlyFile{
                client:  c,
                context: ctx,

                bucket: bucket,
                key:    key,
        }

        result, err := f.client.HeadObject(f.context, &amp;HeadObjectRequest{Bucket: &amp;f.bucket, Key: &amp;f.key})
        if err != nil </span><span class="cov8" title="1">{
                var serr *ServiceError
                if errors.As(err, &amp;serr) &amp;&amp; serr.StatusCode == 404 </span>{<span class="cov8" title="1">
                        // not found
                }</span> else<span class="cov8" title="1"> {
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                if ToString(result.ObjectType) != "Appendable" </span><span class="cov8" title="1">{
                        return nil, errors.New("Not a appendable file")
                }</span>
                <span class="cov8" title="1">f.offset = result.ContentLength</span>
        }

        <span class="cov8" title="1">return f, nil</span>
}

// Write writes len(b) bytes from b to the AppendOnlyFile.
// It returns the number of bytes written and an error, if any.
// Write returns a non-nil error when n != len(b).
func (f *AppendOnlyFile) Write(b []byte) (n int, err error) <span class="cov8" title="1">{
        if err := f.checkValid("write"); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">n, e := f.write(b)
        if n &lt; 0 </span><span class="cov0" title="0">{
                n = 0
        }</span>

        <span class="cov8" title="1">if e == nil &amp;&amp; n != len(b) </span><span class="cov0" title="0">{
                err = io.ErrShortWrite
        }</span>

        <span class="cov8" title="1">if e != nil </span><span class="cov8" title="1">{
                err = f.wrapErr("write", e)
        }</span>

        <span class="cov8" title="1">return n, err</span>
}

// write writes len(b) bytes to the File.
// It returns the number of bytes written and an error, if any.
func (f *AppendOnlyFile) write(b []byte) (n int, err error) <span class="cov8" title="1">{
        offset := f.offset

        request := &amp;AppendObjectRequest{
                Bucket:   &amp;f.bucket,
                Key:      &amp;f.key,
                Position: Ptr(f.offset),
                RequestCommon: RequestCommon{
                        Body: bytes.NewReader(b),
                },
        }

        var result *AppendObjectResult
        if result, err = f.client.AppendObject(f.context, request); err == nil </span><span class="cov8" title="1">{
                f.offset = result.NextPosition
        }</span> else<span class="cov8" title="1"> {
                var serr *ServiceError
                if errors.As(err, &amp;serr) &amp;&amp; serr.Code == "PositionNotEqualToLength" </span><span class="cov8" title="1">{
                        if position, ok := f.nextAppendPosition(); ok </span><span class="cov8" title="1">{
                                if offset+int64(len(b)) == position </span><span class="cov8" title="1">{
                                        f.offset = position
                                        err = nil
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return int(f.offset - offset), err</span>
}

// WriteFrom writes io.Reader to the File.
// It returns the number of bytes written and an error, if any.
func (f *AppendOnlyFile) WriteFrom(r io.Reader) (n int64, err error) <span class="cov8" title="1">{
        if err := f.checkValid("write"); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">n, err = f.writeFrom(r)

        if err != nil </span><span class="cov8" title="1">{
                err = f.wrapErr("write", err)
        }</span>

        <span class="cov8" title="1">return n, err</span>
}

func (f *AppendOnlyFile) writeFrom(r io.Reader) (n int64, err error) <span class="cov8" title="1">{
        offset := f.offset

        request := &amp;AppendObjectRequest{
                Bucket:   &amp;f.bucket,
                Key:      &amp;f.key,
                Position: Ptr(f.offset),
                RequestCommon: RequestCommon{
                        Body: r,
                },
        }

        var roffset int64
        var rs io.Seeker
        rs, ok := r.(io.Seeker)
        if ok </span><span class="cov8" title="1">{
                roffset, _ = rs.Seek(0, io.SeekCurrent)
        }</span>

        <span class="cov8" title="1">var result *AppendObjectResult
        if result, err = f.client.AppendObject(f.context, request); err == nil </span><span class="cov8" title="1">{
                f.offset = result.NextPosition
        }</span> else<span class="cov8" title="1"> {
                var serr *ServiceError
                if errors.As(err, &amp;serr) &amp;&amp; serr.Code == "PositionNotEqualToLength" </span><span class="cov8" title="1">{
                        if position, ok := f.nextAppendPosition(); ok </span><span class="cov8" title="1">{
                                if rs != nil </span><span class="cov8" title="1">{
                                        if curr, e := rs.Seek(0, io.SeekCurrent); e == nil </span><span class="cov8" title="1">{
                                                if offset+(curr-roffset) == position </span><span class="cov8" title="1">{
                                                        f.offset = position
                                                        err = nil
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return f.offset - offset, err</span>
}

func (f *AppendOnlyFile) nextAppendPosition() (int64, bool) <span class="cov8" title="1">{
        if h, e := f.client.HeadObject(f.context, &amp;HeadObjectRequest{Bucket: &amp;f.bucket, Key: &amp;f.key}); e == nil </span><span class="cov8" title="1">{
                return h.ContentLength, true
        }</span>
        <span class="cov0" title="0">return 0, false</span>
}

// wrapErr wraps an error that occurred during an operation on an open file.
// It passes io.EOF through unchanged, otherwise converts
// Wraps the error in a PathError.
func (f *AppendOnlyFile) wrapErr(op string, err error) error <span class="cov8" title="1">{
        if err == nil || err == io.EOF </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return &amp;os.PathError{Op: op, Path: f.name(), Err: err}</span>
}

func (f *AppendOnlyFile) checkValid(op string) error <span class="cov8" title="1">{
        if f == nil </span><span class="cov8" title="1">{
                return os.ErrInvalid
        }</span> else<span class="cov8" title="1"> if f.closed </span><span class="cov8" title="1">{
                return os.ErrClosed
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (f *AppendOnlyFile) name() string <span class="cov8" title="1">{
        return fmt.Sprintf("oss://%s/%s", f.bucket, f.key)
}</span>

// Stat returns the FileInfo structure describing file.
func (f *AppendOnlyFile) Stat() (os.FileInfo, error) <span class="cov8" title="1">{
        if err := f.checkValid("stat"); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">info, err := f.stat()

        if err != nil </span><span class="cov0" title="0">{
                return nil, f.wrapErr("stat", err)
        }</span>

        <span class="cov8" title="1">return info, nil</span>
}

func (f *AppendOnlyFile) stat() (os.FileInfo, error) <span class="cov8" title="1">{
        var err error
        if f.info == nil || f.info.Size() != f.offset </span><span class="cov8" title="1">{
                f.info = nil
                if result, err := f.client.HeadObject(f.context, &amp;HeadObjectRequest{Bucket: &amp;f.bucket, Key: &amp;f.key}); err == nil </span><span class="cov8" title="1">{
                        f.info = &amp;fileInfo{
                                name:    f.name(),
                                size:    result.ContentLength,
                                modTime: ToTime(result.LastModified),
                                header:  result.Headers,
                        }
                }</span>
        }
        <span class="cov8" title="1">return f.info, err</span>
}

// Close closes the File.
func (f *AppendOnlyFile) Close() error <span class="cov8" title="1">{
        if f == nil </span><span class="cov8" title="1">{
                return os.ErrInvalid
        }</span>
        <span class="cov8" title="1">return f.close()</span>
}

func (f *AppendOnlyFile) close() error <span class="cov8" title="1">{
        f.closed = true
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package oss

import (
        "context"
        "fmt"
)

type PaginatorOptions struct {
        // The maximum number of items in the response.
        Limit int32
}

// ListObjectsPaginator is a paginator for ListObjects
type ListObjectsPaginator struct {
        options     PaginatorOptions
        client      *Client
        request     *ListObjectsRequest
        marker      *string
        firstPage   bool
        isTruncated bool
}

func (c *Client) NewListObjectsPaginator(request *ListObjectsRequest, optFns ...func(*PaginatorOptions)) *ListObjectsPaginator <span class="cov8" title="1">{
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;ListObjectsRequest{}
        }</span>

        <span class="cov8" title="1">options := PaginatorOptions{}
        options.Limit = request.MaxKeys

        for _, fn := range optFns </span><span class="cov0" title="0">{
                fn(&amp;options)
        }</span>

        <span class="cov8" title="1">return &amp;ListObjectsPaginator{
                options:     options,
                client:      c,
                request:     request,
                marker:      request.Marker,
                firstPage:   true,
                isTruncated: false,
        }</span>
}

// HasNext Returns true if there’s a next page.
func (p *ListObjectsPaginator) HasNext() bool <span class="cov8" title="1">{
        return p.firstPage || p.isTruncated
}</span>

// NextPage retrieves the next ListObjects page.
func (p *ListObjectsPaginator) NextPage(ctx context.Context, optFns ...func(*Options)) (*ListObjectsResult, error) <span class="cov8" title="1">{
        if !p.HasNext() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no more pages available")
        }</span>

        <span class="cov8" title="1">request := *p.request
        request.Marker = p.marker

        var limit int32
        if p.options.Limit &gt; 0 </span><span class="cov8" title="1">{
                limit = p.options.Limit
        }</span>
        <span class="cov8" title="1">request.MaxKeys = limit
        request.EncodingType = Ptr("url")

        result, err := p.client.ListObjects(ctx, &amp;request, optFns...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">p.firstPage = false
        p.isTruncated = result.IsTruncated
        p.marker = result.NextMarker

        return result, nil</span>
}

// ListObjectsV2Paginator is a paginator for ListObjectsV2
type ListObjectsV2Paginator struct {
        options       PaginatorOptions
        client        *Client
        request       *ListObjectsRequestV2
        continueToken *string
        firstPage     bool
        isTruncated   bool
}

func (c *Client) NewListObjectsV2Paginator(request *ListObjectsRequestV2, optFns ...func(*PaginatorOptions)) *ListObjectsV2Paginator <span class="cov8" title="1">{
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;ListObjectsRequestV2{}
        }</span>

        <span class="cov8" title="1">options := PaginatorOptions{}
        options.Limit = request.MaxKeys

        for _, fn := range optFns </span><span class="cov0" title="0">{
                fn(&amp;options)
        }</span>

        <span class="cov8" title="1">return &amp;ListObjectsV2Paginator{
                options:       options,
                client:        c,
                request:       request,
                continueToken: request.ContinuationToken,
                firstPage:     true,
                isTruncated:   false,
        }</span>
}

// HasNext Returns true if there’s a next page.
func (p *ListObjectsV2Paginator) HasNext() bool <span class="cov8" title="1">{
        return p.firstPage || p.isTruncated
}</span>

// NextPage retrieves the next ListObjectsV2 page.
func (p *ListObjectsV2Paginator) NextPage(ctx context.Context, optFns ...func(*Options)) (*ListObjectsResultV2, error) <span class="cov8" title="1">{
        if !p.HasNext() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no more pages available")
        }</span>

        <span class="cov8" title="1">request := *p.request
        request.ContinuationToken = p.continueToken

        var limit int32
        if p.options.Limit &gt; 0 </span><span class="cov8" title="1">{
                limit = p.options.Limit
        }</span>
        <span class="cov8" title="1">request.MaxKeys = limit
        request.EncodingType = Ptr("url")

        result, err := p.client.ListObjectsV2(ctx, &amp;request, optFns...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">p.firstPage = false
        p.isTruncated = result.IsTruncated
        p.continueToken = result.NextContinuationToken

        return result, nil</span>
}

// ListObjectVersionsPaginator is a paginator for ListObjectVersions
type ListObjectVersionsPaginator struct {
        options         PaginatorOptions
        client          *Client
        request         *ListObjectVersionsRequest
        keyMarker       *string
        versionIdMarker *string
        firstPage       bool
        isTruncated     bool
}

func (c *Client) NewListObjectVersionsPaginator(request *ListObjectVersionsRequest, optFns ...func(*PaginatorOptions)) *ListObjectVersionsPaginator <span class="cov8" title="1">{
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;ListObjectVersionsRequest{}
        }</span>

        <span class="cov8" title="1">options := PaginatorOptions{}
        options.Limit = request.MaxKeys

        for _, fn := range optFns </span><span class="cov0" title="0">{
                fn(&amp;options)
        }</span>

        <span class="cov8" title="1">return &amp;ListObjectVersionsPaginator{
                options:         options,
                client:          c,
                request:         request,
                keyMarker:       request.KeyMarker,
                versionIdMarker: request.VersionIdMarker,
                firstPage:       true,
                isTruncated:     false,
        }</span>
}

// HasNext Returns true if there’s a next page.
func (p *ListObjectVersionsPaginator) HasNext() bool <span class="cov8" title="1">{
        return p.firstPage || p.isTruncated
}</span>

// NextPage retrieves the next ListObjectVersions page.
func (p *ListObjectVersionsPaginator) NextPage(ctx context.Context, optFns ...func(*Options)) (*ListObjectVersionsResult, error) <span class="cov8" title="1">{
        if !p.HasNext() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no more pages available")
        }</span>

        <span class="cov8" title="1">request := *p.request
        request.KeyMarker = p.keyMarker
        request.VersionIdMarker = p.versionIdMarker

        var limit int32
        if p.options.Limit &gt; 0 </span><span class="cov8" title="1">{
                limit = p.options.Limit
        }</span>
        <span class="cov8" title="1">request.MaxKeys = limit
        request.EncodingType = Ptr("url")

        result, err := p.client.ListObjectVersions(ctx, &amp;request, optFns...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">p.firstPage = false
        p.isTruncated = result.IsTruncated
        p.keyMarker = result.NextKeyMarker
        p.versionIdMarker = result.NextVersionIdMarker

        return result, nil</span>
}

// ListBucketsPaginator is a paginator for ListBuckets
type ListBucketsPaginator struct {
        options     PaginatorOptions
        client      *Client
        request     *ListBucketsRequest
        marker      *string
        firstPage   bool
        isTruncated bool
}

func (c *Client) NewListBucketsPaginator(request *ListBucketsRequest, optFns ...func(*PaginatorOptions)) *ListBucketsPaginator <span class="cov8" title="1">{
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;ListBucketsRequest{}
        }</span>

        <span class="cov8" title="1">options := PaginatorOptions{}
        options.Limit = request.MaxKeys

        for _, fn := range optFns </span><span class="cov0" title="0">{
                fn(&amp;options)
        }</span>

        <span class="cov8" title="1">return &amp;ListBucketsPaginator{
                options:     options,
                client:      c,
                request:     request,
                marker:      request.Marker,
                firstPage:   true,
                isTruncated: false,
        }</span>
}

// HasNext Returns true if there’s a next page.
func (p *ListBucketsPaginator) HasNext() bool <span class="cov8" title="1">{
        return p.firstPage || p.isTruncated
}</span>

// NextPage retrieves the next ListBuckets page.
func (p *ListBucketsPaginator) NextPage(ctx context.Context, optFns ...func(*Options)) (*ListBucketsResult, error) <span class="cov8" title="1">{
        if !p.HasNext() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no more pages available")
        }</span>

        <span class="cov8" title="1">request := *p.request
        request.Marker = p.marker

        var limit int32
        if p.options.Limit &gt; 0 </span><span class="cov8" title="1">{
                limit = p.options.Limit
        }</span>
        <span class="cov8" title="1">request.MaxKeys = limit

        result, err := p.client.ListBuckets(ctx, &amp;request, optFns...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">p.firstPage = false
        p.isTruncated = result.IsTruncated
        p.marker = result.NextMarker

        return result, nil</span>
}

// ListPartsPaginator is a paginator for ListParts
type ListPartsPaginator struct {
        options     PaginatorOptions
        client      *Client
        request     *ListPartsRequest
        marker      int32
        firstPage   bool
        isTruncated bool
}

func (c *Client) NewListPartsPaginator(request *ListPartsRequest, optFns ...func(*PaginatorOptions)) *ListPartsPaginator <span class="cov8" title="1">{
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;ListPartsRequest{}
        }</span>

        <span class="cov8" title="1">options := PaginatorOptions{}
        options.Limit = request.MaxParts

        for _, fn := range optFns </span><span class="cov0" title="0">{
                fn(&amp;options)
        }</span>

        <span class="cov8" title="1">return &amp;ListPartsPaginator{
                options:     options,
                client:      c,
                request:     request,
                marker:      request.PartNumberMarker,
                firstPage:   true,
                isTruncated: false,
        }</span>
}

// HasNext Returns true if there’s a next page.
func (p *ListPartsPaginator) HasNext() bool <span class="cov8" title="1">{
        return p.firstPage || p.isTruncated
}</span>

// NextPage retrieves the next ListParts page.
func (p *ListPartsPaginator) NextPage(ctx context.Context, optFns ...func(*Options)) (*ListPartsResult, error) <span class="cov8" title="1">{
        if !p.HasNext() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no more pages available")
        }</span>

        <span class="cov8" title="1">request := *p.request
        request.PartNumberMarker = p.marker
        var limit int32
        if p.options.Limit &gt; 0 </span><span class="cov8" title="1">{
                limit = p.options.Limit
        }</span>
        <span class="cov8" title="1">request.MaxParts = limit
        request.EncodingType = Ptr("url")
        result, err := p.client.ListParts(ctx, &amp;request, optFns...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">p.firstPage = false
        p.isTruncated = result.IsTruncated
        p.marker = result.NextPartNumberMarker

        return result, nil</span>
}

// ListMultipartUploadsPaginator is a paginator for ListMultipartUploads
type ListMultipartUploadsPaginator struct {
        options        PaginatorOptions
        client         *Client
        request        *ListMultipartUploadsRequest
        keyMarker      *string
        uploadIdMarker *string
        firstPage      bool
        isTruncated    bool
}

func (c *Client) NewListMultipartUploadsPaginator(request *ListMultipartUploadsRequest, optFns ...func(*PaginatorOptions)) *ListMultipartUploadsPaginator <span class="cov8" title="1">{
        if request == nil </span><span class="cov0" title="0">{
                request = &amp;ListMultipartUploadsRequest{}
        }</span>
        <span class="cov8" title="1">options := PaginatorOptions{}
        options.Limit = request.MaxUploads
        for _, fn := range optFns </span><span class="cov0" title="0">{
                fn(&amp;options)
        }</span>
        <span class="cov8" title="1">return &amp;ListMultipartUploadsPaginator{
                options:        options,
                client:         c,
                request:        request,
                keyMarker:      request.KeyMarker,
                uploadIdMarker: request.UploadIdMarker,
                firstPage:      true,
                isTruncated:    false,
        }</span>
}

// HasNext Returns true if there’s a next page.
func (p *ListMultipartUploadsPaginator) HasNext() bool <span class="cov8" title="1">{
        return p.firstPage || p.isTruncated
}</span>

// NextPage retrieves the next ListMultipartUploads page.
func (p *ListMultipartUploadsPaginator) NextPage(ctx context.Context, optFns ...func(*Options)) (*ListMultipartUploadsResult, error) <span class="cov8" title="1">{
        if !p.HasNext() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no more pages available")
        }</span>
        <span class="cov8" title="1">request := *p.request
        request.KeyMarker = p.keyMarker
        request.UploadIdMarker = p.uploadIdMarker
        var limit int32
        if p.options.Limit &gt; 0 </span><span class="cov8" title="1">{
                limit = p.options.Limit
        }</span>
        <span class="cov8" title="1">request.MaxUploads = limit
        request.EncodingType = Ptr("url")
        result, err := p.client.ListMultipartUploads(ctx, &amp;request, optFns...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">p.firstPage = false
        p.isTruncated = result.IsTruncated
        p.keyMarker = result.NextKeyMarker
        p.uploadIdMarker = result.NextUploadIdMarker
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package oss

import (
        "context"
        "fmt"
        "net/http"
        "reflect"
        "time"

        "github.com/aliyun/aliyun-oss-go-sdk/v3/oss/signer"
)

type PresignOptions struct {
        // Expires sets the expiration duration for the generated presign url.
        Expires time.Duration

        // Expiration sets the expiration time for the generated presign url.
        Expiration time.Time
}

type PresignResult struct {
        Method        string
        URL           string
        Expiration    time.Time
        SignedHeaders map[string]string
}

type nopHttpClient struct {
}

func (c *nopHttpClient) Do(*http.Request) (*http.Response, error) <span class="cov8" title="1">{
        return &amp;http.Response{
                StatusCode: 200,
                Header:     http.Header{},
                Body:       http.NoBody,
        }, nil
}</span>

var (
        defaultNopHttpClient  = &amp;nopHttpClient{}
        defaultPresignOptions = []func(*Options){
                func(o *Options) <span class="cov8" title="1">{
                        o.HttpClient = defaultNopHttpClient
                        o.AuthMethod = Ptr(AuthMethodQuery)
                }</span>,
        }
)

func (c *Client) Presign(ctx context.Context, request any, optFns ...func(*PresignOptions)) (*PresignResult, error) <span class="cov8" title="1">{
        options := PresignOptions{}

        if request == nil </span><span class="cov8" title="1">{
                return nil, NewErrParamNull("request")
        }</span>

        <span class="cov8" title="1">for _, fn := range optFns </span><span class="cov8" title="1">{
                fn(&amp;options)
        }</span>

        <span class="cov8" title="1">var input OperationInput
        if i, ok := request.(*OperationInput); ok </span><span class="cov8" title="1">{
                input = *i
        }</span> else<span class="cov8" title="1"> {
                input = OperationInput{}
                if err := c.marshalPresignInput(request, &amp;input); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        // expiration
        <span class="cov8" title="1">if !options.Expiration.IsZero() </span><span class="cov8" title="1">{
                input.OpMetadata.Set(signer.SignTime, options.Expiration)
        }</span> else<span class="cov8" title="1"> if options.Expires &gt; 0 </span><span class="cov8" title="1">{
                input.OpMetadata.Set(signer.SignTime, time.Now().Add(options.Expires))
        }</span>

        <span class="cov8" title="1">output, err := c.invokeOperation(ctx, &amp;input, defaultPresignOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;PresignResult{}
        err = c.unmarshalPresignOutput(result, output)
        return result, err</span>
}

func PresignExpires(value time.Duration) func(*PresignOptions) <span class="cov8" title="1">{
        return func(o *PresignOptions) </span><span class="cov8" title="1">{
                o.Expires = value
        }</span>
}

func PresignExpiration(value time.Time) func(*PresignOptions) <span class="cov8" title="1">{
        return func(o *PresignOptions) </span><span class="cov8" title="1">{
                o.Expiration = value
        }</span>
}

func (c *Client) marshalPresignInput(request any, input *OperationInput) error <span class="cov8" title="1">{
        switch t := request.(type) </span>{
        case *GetObjectRequest:<span class="cov8" title="1">
                input.OpName = "GetObject"
                input.Method = "GET"
                input.Bucket = t.Bucket
                input.Key = t.Key</span>
        // TODO
        case *PutObjectRequest:<span class="cov8" title="1">
                input.OpName = "PutObject"
                input.Method = "PUT"
                input.Bucket = t.Bucket
                input.Key = t.Key</span>
        case *CopyObjectRequest:<span class="cov8" title="1">
                input.OpName = "CopyObject"
                input.Method = "PUT"
                input.Bucket = t.Bucket
                input.Key = t.Key
                input.Headers = map[string]string{
                        "x-oss-copy-source": encodeSourceObject(request),
                }</span>
        case *HeadObjectRequest:<span class="cov8" title="1">
                input.OpName = "HeadObject"
                input.Method = "HEAD"
                input.Bucket = t.Bucket
                input.Key = t.Key</span>
        case *AppendObjectRequest:<span class="cov8" title="1">
                input.OpName = "AppendObject"
                input.Method = "POST"
                input.Bucket = t.Bucket
                input.Key = t.Key
                input.Parameters = map[string]string{
                        "append": "",
                }</span>
        case *InitiateMultipartUploadRequest:<span class="cov8" title="1">
                input.OpName = "InitiateMultipartUpload"
                input.Method = "POST"
                input.Bucket = t.Bucket
                input.Key = t.Key
                input.Parameters = map[string]string{
                        "uploads":       "",
                        "encoding-type": "url",
                }</span>
        case *UploadPartRequest:<span class="cov8" title="1">
                input.OpName = "UploadPart"
                input.Method = "PUT"
                input.Bucket = t.Bucket
                input.Key = t.Key</span>
        case *UploadPartCopyRequest:<span class="cov8" title="1">
                input.OpName = "UploadPartCopy"
                input.Method = "PUT"
                input.Bucket = t.Bucket
                input.Key = t.Key
                input.Headers = map[string]string{
                        "x-oss-copy-source": encodeSourceObject(request),
                }</span>
        case *CompleteMultipartUploadRequest:<span class="cov8" title="1">
                input.OpName = "CompleteMultipartUpload"
                input.Method = "POST"
                input.Bucket = t.Bucket
                input.Key = t.Key
                input.Parameters = map[string]string{
                        "encoding-type": "url",
                }</span>
        case *AbortMultipartUploadRequest:<span class="cov8" title="1">
                input.OpName = "AbortMultipartUpload"
                input.Method = "DELETE"
                input.Bucket = t.Bucket
                input.Key = t.Key</span>
        default:<span class="cov8" title="1">
                return NewErrParamInvalid(fmt.Sprintf("request %v", reflect.ValueOf(request).Type().String()))</span>
        }

        <span class="cov8" title="1">return c.marshalInput(request, input)</span>
}

func (c *Client) unmarshalPresignOutput(result *PresignResult, output *OperationOutput) error <span class="cov8" title="1">{
        if chk, ok := c.options.Signer.(interface{ IsSignedHeader(string) bool }); ok </span><span class="cov8" title="1">{
                header := map[string]string{}
                for k, v := range output.httpRequest.Header </span><span class="cov8" title="1">{
                        if chk.IsSignedHeader(k) </span><span class="cov8" title="1">{
                                header[k] = v[0]
                        }</span>
                }
                <span class="cov8" title="1">if len(header) &gt; 0 </span><span class="cov8" title="1">{
                        result.SignedHeaders = header
                }</span>
        }
        <span class="cov8" title="1">result.Method = output.httpRequest.Method
        result.URL = output.httpRequest.URL.String()
        if signTime, ok := output.OpMetadata.Get(signer.SignTime).(time.Time); ok </span><span class="cov8" title="1">{
                result.Expiration = signTime
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package oss

import (
        "net/http"
        "time"

        "github.com/aliyun/aliyun-oss-go-sdk/v3/oss/credentials"
        "github.com/aliyun/aliyun-oss-go-sdk/v3/oss/retry"
)

type HTTPClient interface {
        Do(*http.Request) (*http.Response, error)
}

type Config struct {
        // The region in which the bucket is located.
        Region string

        // The domain names that other services can use to access OSS.
        Endpoint *string

        // RetryMaxAttempts specifies the maximum number attempts an API client will call
        // an operation that fails with a retryable error.
        RetryMaxAttempts int

        // Retryer guides how HTTP requests should be retried in case of recoverable failures.
        Retryer retry.Retryer

        // The HTTP client to invoke API calls with. Defaults to client's default HTTP
        // implementation if nil.
        HttpClient HTTPClient

        // The credentials provider to use when signing requests.
        CredentialsProvider credentials.CredentialsProvider

        // Allows you to enable the client to use path-style addressing, i.e., https://oss-cn-hangzhou.aliyuncs.com/bucket/key.
        // By default, the oss client will use virtual hosted addressing i.e., https://bucket.oss-cn-hangzhou.aliyuncs.com/key.
        UsePathStyle *bool

        // If the endpoint is s CName, set this flag to true
        UseCName *bool

        // Connect timeout
        ConnectTimeout *time.Duration

        // read &amp; write timeout
        ReadWriteTimeout *time.Duration

        // Skip server certificate verification
        InsecureSkipVerify *bool

        // Enable http redirect or not. Default is disable
        EnabledRedirect *bool

        // Flag of using proxy host.
        ProxyHost *string

        // Read the proxy setting from the environment variables.
        // HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof).
        // HTTPS_PROXY takes precedence over HTTP_PROXY for https requests.
        ProxyFromEnvironment *bool

        // Upload bandwidth limit in kBytes/s for all request
        UploadBandwidthlimit *int64

        // Download bandwidth limit in kBytes/s for all request
        DownloadBandwidthlimit *int64

        // Authentication with OSS Signature Version
        SignatureVersion SignatureVersionType
}

func NewConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{}
}</span>

func (c Config) Copy() Config <span class="cov0" title="0">{
        cp := c
        return cp
}</span>

func LoadDefaultConfig() *Config <span class="cov8" title="1">{
        config := &amp;Config{
                RetryMaxAttempts: 3,
                SignatureVersion: SignatureVersionV1,
        }
        return config
}</span>

func (c *Config) WithRegion(region string) *Config <span class="cov8" title="1">{
        c.Region = region
        return c
}</span>

func (c *Config) WithEndpoint(endpoint string) *Config <span class="cov8" title="1">{
        c.Endpoint = Ptr(endpoint)
        return c
}</span>

func (c *Config) WithRetryMaxAttempts(value int) *Config <span class="cov8" title="1">{
        c.RetryMaxAttempts = value
        return c
}</span>

func (c *Config) WithRetryer(retryer retry.Retryer) *Config <span class="cov0" title="0">{
        c.Retryer = retryer
        return c
}</span>

func (c *Config) WithHttpClient(client *http.Client) *Config <span class="cov0" title="0">{
        c.HttpClient = client
        return c
}</span>

func (c *Config) WithCredentialsProvider(provider credentials.CredentialsProvider) *Config <span class="cov8" title="1">{
        c.CredentialsProvider = provider
        return c
}</span>

func (c *Config) WithUsePathStyle(enable bool) *Config <span class="cov0" title="0">{
        c.UsePathStyle = Ptr(enable)
        return c
}</span>

func (c *Config) WithUseCName(enable bool) *Config <span class="cov0" title="0">{
        c.UseCName = Ptr(enable)
        return c
}</span>

func (c *Config) WithConnectTimeout(value time.Duration) *Config <span class="cov0" title="0">{
        c.ConnectTimeout = Ptr(value)
        return c
}</span>

func (c *Config) WithReadWriteTimeout(value time.Duration) *Config <span class="cov8" title="1">{
        c.ReadWriteTimeout = Ptr(value)
        return c
}</span>

func (c *Config) WithInsecureSkipVerify(value bool) *Config <span class="cov0" title="0">{
        c.InsecureSkipVerify = Ptr(value)
        return c
}</span>

func (c *Config) WithEnabledRedirect(value bool) *Config <span class="cov0" title="0">{
        c.EnabledRedirect = Ptr(value)
        return c
}</span>

func (c *Config) WithProxyHost(value string) *Config <span class="cov0" title="0">{
        c.ProxyHost = Ptr(value)
        return c
}</span>

func (c *Config) WithProxyFromEnvironment(value bool) *Config <span class="cov0" title="0">{
        c.ProxyFromEnvironment = Ptr(value)
        return c
}</span>

func (c *Config) WithUploadBandwidthlimit(value int64) *Config <span class="cov0" title="0">{
        c.UploadBandwidthlimit = Ptr(value)
        return c
}</span>

func (c *Config) WithDownloadBandwidthlimit(value int64) *Config <span class="cov0" title="0">{
        c.DownloadBandwidthlimit = Ptr(value)
        return c
}</span>

func (c *Config) WithSignatureVersion(value SignatureVersionType) *Config <span class="cov8" title="1">{
        c.SignatureVersion = value
        return c
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package oss

// BucketACLType The access control list (ACL) of the bucket
type BucketACLType string

// Enum values for BucketACLType
const (
        // BucketACLPrivate Only the bucket owner can perform read and write operations on objects in the bucket.
        // Other users cannot access the objects in the bucket.
        BucketACLPrivate BucketACLType = "private"

        // BucketACLPublicRead Only the bucket owner can write data to objects in the bucket.
        // Other users, including anonymous users, can only read objects in the bucket.
        BucketACLPublicRead BucketACLType = "public-read"

        // BucketACLPublicReadWrite All users, including anonymous users, can perform read and write operations on the bucket.
        BucketACLPublicReadWrite BucketACLType = "public-read-write"
)

// StorageClassType The storage class of the bucket
type StorageClassType string

// Enum values for StorageClassType
const (
        // StorageClassStandard Standard provides highly reliable, highly available,
        // and high-performance object storage for data that is frequently accessed.
        StorageClassStandard StorageClassType = "Standard"

        // StorageClassIA IA provides highly durable storage at lower prices compared with Standard.
        // IA has a minimum billable size of 64 KB and a minimum billable storage duration of 30 days.
        StorageClassIA StorageClassType = "IA"

        // StorageClassArchive Archive provides high-durability storage at lower prices compared with Standard and IA.
        // Archive has a minimum billable size of 64 KB and a minimum billable storage duration of 60 days.
        StorageClassArchive StorageClassType = "Archive"

        // StorageClassColdArchive Cold Archive provides highly durable storage at lower prices compared with Archive.
        // Cold Archive has a minimum billable size of 64 KB and a minimum billable storage duration of 180 days.
        StorageClassColdArchive StorageClassType = "ColdArchive"

        // StorageClassDeepColdArchive Deep Cold Archive provides highly durable storage at lower prices compared with Cold Archive.
        // Deep Cold Archive has a minimum billable size of 64 KB and a minimum billable storage duration of 180 days.
        StorageClassDeepColdArchive StorageClassType = "DeepColdArchive"
)

// DataRedundancyType The redundancy type of the bucket
type DataRedundancyType string

// Enum values for BucketACLType
const (
        // DataRedundancyLRS Locally redundant storage (LRS) stores copies of each object across different devices in the same zone.
        // This ensures data reliability and availability even if two storage devices are damaged at the same time.
        DataRedundancyLRS DataRedundancyType = "LRS"

        // DataRedundancyZRS Zone-redundant storage (ZRS) uses the multi-zone mechanism to distribute user data across
        // multiple zones in the same region. If one zone becomes unavailable, you can continue to access the data
        // that is stored in other zones.
        DataRedundancyZRS DataRedundancyType = "ZRS"
)

// ObjectACLType The access control list (ACL) of the object
type ObjectACLType string

// Enum values for ObjectACLType
const (
        // ObjectACLPrivate Only the object owner is allowed to perform read and write operations on the object.
        // Other users cannot access the object.
        ObjectACLPrivate ObjectACLType = "private"

        // ObjectACLPublicRead Only the object owner can write data to the object.
        // Other users, including anonymous users, can only read the object.
        ObjectACLPublicRead ObjectACLType = "public-read"

        // ObjectACLPublicReadWrite All users, including anonymous users, can perform read and write operations on the object.
        ObjectACLPublicReadWrite ObjectACLType = "public-read-write"

        // ObjectACLDefault The ACL of the object is the same as that of the bucket in which the object is stored.
        ObjectACLDefault ObjectACLType = "default"
)

// VersioningStatusType bucket versioning status
type VersioningStatusType string

const (
        // VersionEnabled Versioning Status definition: Enabled
        VersionEnabled VersioningStatusType = "Enabled"

        // VersionSuspended Versioning Status definition: Suspended
        VersionSuspended VersioningStatusType = "Suspended"
)

// OSS headers
const (
        HeaderOssPrefix                      string = "X-Oss-"
        HeaderOssMetaPrefix                         = "X-Oss-Meta-"
        HeaderOssACL                                = "X-Oss-Acl"
        HeaderOssObjectACL                          = "X-Oss-Object-Acl"
        HeaderOssObjectType                         = "X-Oss-Object-Type"
        HeaderOssSecurityToken                      = "X-Oss-Security-Token"
        HeaderOssServerSideEncryption               = "X-Oss-Server-Side-Encryption"
        HeaderOssServerSideEncryptionKeyID          = "X-Oss-Server-Side-Encryption-Key-Id"
        HeaderOssServerSideDataEncryption           = "X-Oss-Server-Side-Data-Encryption"
        HeaderOssSSECAlgorithm                      = "X-Oss-Server-Side-Encryption-Customer-Algorithm"
        HeaderOssSSECKey                            = "X-Oss-Server-Side-Encryption-Customer-Key"
        HeaderOssSSECKeyMd5                         = "X-Oss-Server-Side-Encryption-Customer-Key-MD5"
        HeaderOssCopySource                         = "X-Oss-Copy-Source"
        HeaderOssCopySourceRange                    = "X-Oss-Copy-Source-Range"
        HeaderOssCopySourceIfMatch                  = "X-Oss-Copy-Source-If-Match"
        HeaderOssCopySourceIfNoneMatch              = "X-Oss-Copy-Source-If-None-Match"
        HeaderOssCopySourceIfModifiedSince          = "X-Oss-Copy-Source-If-Modified-Since"
        HeaderOssCopySourceIfUnmodifiedSince        = "X-Oss-Copy-Source-If-Unmodified-Since"
        HeaderOssMetadataDirective                  = "X-Oss-Metadata-Directive"
        HeaderOssNextAppendPosition                 = "X-Oss-Next-Append-Position"
        HeaderOssRequestID                          = "X-Oss-Request-Id"
        HeaderOssCRC64                              = "X-Oss-Hash-Crc64ecma"
        HeaderOssSymlinkTarget                      = "X-Oss-Symlink-Target"
        HeaderOssStorageClass                       = "X-Oss-Storage-Class"
        HeaderOssCallback                           = "X-Oss-Callback"
        HeaderOssCallbackVar                        = "X-Oss-Callback-Var"
        HeaderOssRequester                          = "X-Oss-Request-Payer"
        HeaderOssTagging                            = "X-Oss-Tagging"
        HeaderOssTaggingDirective                   = "X-Oss-Tagging-Directive"
        HeaderOssTrafficLimit                       = "X-Oss-Traffic-Limit"
        HeaderOssForbidOverWrite                    = "X-Oss-Forbid-Overwrite"
        HeaderOssRangeBehavior                      = "X-Oss-Range-Behavior"
        HeaderOssAllowSameActionOverLap             = "X-Oss-Allow-Same-Action-Overlap"
        HeaderOssDate                               = "X-Oss-Date"
        HeaderOssContentSha256                      = "X-Oss-Content-Sha256"
        HeaderOssEC                                 = "X-Oss-Ec"
        HeaderOssERR                                = "X-Oss-Err"
)

// HTTP headers
const (
        HTTPHeaderAcceptEncoding     string = "Accept-Encoding"
        HTTPHeaderAuthorization             = "Authorization"
        HTTPHeaderCacheControl              = "Cache-Control"
        HTTPHeaderContentDisposition        = "Content-Disposition"
        HTTPHeaderContentEncoding           = "Content-Encoding"
        HTTPHeaderContentLength             = "Content-Length"
        HTTPHeaderContentMD5                = "Content-MD5"
        HTTPHeaderContentType               = "Content-Type"
        HTTPHeaderContentLanguage           = "Content-Language"
        HTTPHeaderDate                      = "Date"
        HTTPHeaderETag                      = "ETag"
        HTTPHeaderExpires                   = "Expires"
        HTTPHeaderHost                      = "Host"
        HTTPHeaderLastModified              = "Last-Modified"
        HTTPHeaderRange                     = "Range"
        HTTPHeaderLocation                  = "Location"
        HTTPHeaderUserAgent                 = "User-Agent"
        HTTPHeaderIfModifiedSince           = "If-Modified-Since"
        HTTPHeaderIfUnmodifiedSince         = "If-Unmodified-Since"
        HTTPHeaderIfMatch                   = "If-Match"
        HTTPHeaderIfNoneMatch               = "If-None-Match"
)

type UrlStyleType int

const (
        UrlStyleVirtualHosted UrlStyleType = iota
        UrlStylePath
        UrlStyleCName
)

func (f UrlStyleType) String() string <span class="cov0" title="0">{
        switch f </span>{
        default:<span class="cov0" title="0">
                return "virtual-hosted-style"</span>
        case UrlStylePath:<span class="cov0" title="0">
                return "path-style"</span>
        case UrlStyleCName:<span class="cov0" title="0">
                return "cname-style"</span>
        }
}

type FeatureFlagsType int

const (
        // FeatureCorrectClockSkew If the client time is different from server time by more than about 15 minutes,
        // the requests your application makes will be signed with the incorrect time, and the server will reject them.
        // The feature to help to identify this case, and SDK will correct for clock skew.
        FeatureCorrectClockSkew FeatureFlagsType = 1 &lt;&lt; iota

        FeatureEnableMD5

        FeatureFlagsDefault = FeatureCorrectClockSkew
)

type SignatureVersionType int

const (
        SignatureVersionV1 SignatureVersionType = iota
        SignatureVersionV4
)

func (f SignatureVersionType) String() string <span class="cov0" title="0">{
        switch f </span>{
        default:<span class="cov0" title="0">
                return "OSS Signature Version 1"</span>
        }
}

type AuthMethodType int

const (
        AuthMethodHeader AuthMethodType = iota
        AuthMethodQuery
)

func (f AuthMethodType) String() string <span class="cov0" title="0">{
        switch f </span>{
        case AuthMethodQuery:<span class="cov0" title="0">
                return "authentication in query"</span>
        default:<span class="cov0" title="0">
                return "authentication in header"</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package oss

import (
        "encoding/xml"
        "fmt"
        "strings"
        "time"
)

type ServiceError struct {
        XMLName   xml.Name `xml:"Error"`
        Code      string   `xml:"Code"`
        Message   string   `xml:"Message"`
        RequestID string   `xml:"RequestId"`
        EC        string   `xml:"EC"`

        StatusCode    int
        Snapshot      []byte
        Timestamp     time.Time
        RequestTarget string
}

func (e *ServiceError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                `Error returned by Service. 
Http Status Code: %d. 
Error Code: %s. 
Request Id: %s. 
Message: %s.
EC: %s.
Timestamp: %s.
Request Endpoint: %s.`,
                e.StatusCode, e.Code, e.RequestID, e.Message, e.EC, e.Timestamp, e.RequestTarget)
}</span>

func (e *ServiceError) HttpStatusCode() int <span class="cov8" title="1">{
        return e.StatusCode
}</span>

func (e *ServiceError) ErrorCode() string <span class="cov8" title="1">{
        return e.Code
}</span>

type ClientError struct {
        Code    string
        Message string
        Err     error
}

func (e *ClientError) Unwrap() error <span class="cov0" title="0">{ return e.Err }</span>

func (e *ClientError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("client error: %v, %v", e.Message, e.Err)
}</span>

type OperationError struct {
        name string
        err  error
}

func (e *OperationError) Operation() string <span class="cov0" title="0">{ return e.name }</span>

func (e *OperationError) Unwrap() error <span class="cov8" title="1">{ return e.err }</span>

func (e *OperationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("operation error %s: %v", e.name, e.err)
}</span>

type DeserializationError struct {
        Err      error
        Snapshot []byte
}

func (e *DeserializationError) Error() string <span class="cov8" title="1">{
        const msg = "deserialization failed"
        if e.Err == nil </span><span class="cov0" title="0">{
                return msg
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s, %v", msg, e.Err)</span>
}

func (e *DeserializationError) Unwrap() error <span class="cov0" title="0">{ return e.Err }</span>

type SerializationError struct {
        Err error
}

func (e *SerializationError) Error() string <span class="cov0" title="0">{
        const msg = "serialization failed"
        if e.Err == nil </span><span class="cov0" title="0">{
                return msg
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s: %v", msg, e.Err)</span>
}

func (e *SerializationError) Unwrap() error <span class="cov0" title="0">{ return e.Err }</span>

type CanceledError struct {
        Err error
}

func (*CanceledError) CanceledError() bool <span class="cov0" title="0">{ return true }</span>

func (e *CanceledError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

func (e *CanceledError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("canceled, %v", e.Err)
}</span>

type InvalidParamError interface {
        error
        Field() string
        SetContext(string)
}

type invalidParamError struct {
        context string
        field   string
        reason  string
}

func (e invalidParamError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s, %s.", e.reason, e.Field())
}</span>

func (e invalidParamError) Field() string <span class="cov8" title="1">{
        sb := &amp;strings.Builder{}
        sb.WriteString(e.context)
        if sb.Len() &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteRune('.')
        }</span>
        <span class="cov8" title="1">sb.WriteString(e.field)
        return sb.String()</span>
}

func (e *invalidParamError) SetContext(ctx string) <span class="cov0" title="0">{
        e.context = ctx
}</span>

func NewErrParamRequired(field string) InvalidParamError <span class="cov8" title="1">{
        return &amp;invalidParamError{
                field:  field,
                reason: fmt.Sprintf("missing required field"),
        }
}</span>

func NewErrParamInvalid(field string) InvalidParamError <span class="cov8" title="1">{
        return &amp;invalidParamError{
                field:  field,
                reason: fmt.Sprintf("invalid field"),
        }
}</span>

func NewErrParamNull(field string) InvalidParamError <span class="cov8" title="1">{
        return &amp;invalidParamError{
                field:  field,
                reason: fmt.Sprintf("null field"),
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package oss

import "time"

// ToBool returns bool value if the pointer is not nil.
// Returns a bool zero value if the pointer is nil.
func ToBool(p *bool) (v bool) <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">return *p</span>
}

// ToString returns bool value if the pointer is not nil.
// Returns a string zero value if the pointer is nil.
func ToString(p *string) (v string) <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">return *p</span>
}

// ToTime returns time.Time value if the pointer is not nil.
// Returns a time.Time  zero value if the pointer is nil.
func ToTime(p *time.Time) (v time.Time) <span class="cov8" title="1">{
        if p == nil </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov8" title="1">return *p</span>
}

// ToDuration returns time.Duration value if the pointer is not nil.
// Returns a time.Duration  zero value if the pointer is nil.
func ToDuration(p *time.Duration) (v time.Duration) <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">return *p</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package oss

import (
        "context"
        "errors"
        "fmt"
        "io"
        "sync"
        "time"
)

type LimitedReadCloser struct {
        *io.LimitedReader
        io.Closer
}

func NewLimitedReadCloser(rc io.ReadCloser, limit int64) io.ReadCloser <span class="cov8" title="1">{
        if limit &lt; 0 </span><span class="cov0" title="0">{
                return rc
        }</span>
        <span class="cov8" title="1">return &amp;LimitedReadCloser{
                LimitedReader: &amp;io.LimitedReader{R: rc, N: limit},
                Closer:        rc,
        }</span>
}

func ReadSeekNopCloser(r io.Reader) ReadSeekerNopClose <span class="cov8" title="1">{
        return ReadSeekerNopClose{r}
}</span>

type ReadSeekerNopClose struct {
        r io.Reader
}

func (r ReadSeekerNopClose) Read(p []byte) (int, error) <span class="cov8" title="1">{
        switch t := r.r.(type) </span>{
        case io.Reader:<span class="cov8" title="1">
                return t.Read(p)</span>
        }
        <span class="cov0" title="0">return 0, nil</span>
}

func (r ReadSeekerNopClose) Seek(offset int64, whence int) (int64, error) <span class="cov8" title="1">{
        switch t := r.r.(type) </span>{
        case io.Seeker:<span class="cov8" title="1">
                return t.Seek(offset, whence)</span>
        }
        <span class="cov8" title="1">return int64(0), nil</span>
}

func (r ReadSeekerNopClose) Close() error <span class="cov8" title="1">{
        return nil
}</span>

func (r ReadSeekerNopClose) IsSeeker() bool <span class="cov8" title="1">{
        _, ok := r.r.(io.Seeker)
        return ok
}</span>

func (r ReadSeekerNopClose) HasLen() (int, bool) <span class="cov8" title="1">{
        type lenner interface {
                Len() int
        }

        if lr, ok := r.r.(lenner); ok </span><span class="cov8" title="1">{
                return lr.Len(), true
        }</span>

        <span class="cov8" title="1">return 0, false</span>
}

func (r ReadSeekerNopClose) GetLen() (int64, error) <span class="cov8" title="1">{
        if l, ok := r.HasLen(); ok </span><span class="cov8" title="1">{
                return int64(l), nil
        }</span>

        <span class="cov8" title="1">if s, ok := r.r.(io.Seeker); ok </span><span class="cov8" title="1">{
                return seekerLen(s)
        }</span>

        <span class="cov8" title="1">return -1, nil</span>
}

func seekerLen(s io.Seeker) (int64, error) <span class="cov8" title="1">{
        curOffset, err := s.Seek(0, io.SeekCurrent)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">endOffset, err := s.Seek(0, io.SeekEnd)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">_, err = s.Seek(curOffset, io.SeekStart)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return endOffset - curOffset, nil</span>
}

func isReaderSeekable(r io.Reader) bool <span class="cov8" title="1">{
        switch v := r.(type) </span>{
        case ReadSeekerNopClose:<span class="cov8" title="1">
                return v.IsSeeker()</span>
        case *ReadSeekerNopClose:<span class="cov0" title="0">
                return v.IsSeeker()</span>
        case io.ReadSeeker:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func getReaderLen(r io.Reader) int64 <span class="cov8" title="1">{
        type lenner interface {
                Len() int
        }

        if lr, ok := r.(lenner); ok </span><span class="cov8" title="1">{
                return int64(lr.Len())
        }</span>

        <span class="cov8" title="1">if s, ok := r.(io.Seeker); ok </span><span class="cov8" title="1">{
                if l, err := seekerLen(s); err == nil </span><span class="cov8" title="1">{
                        return l
                }</span>
        }

        <span class="cov8" title="1">return -1</span>
}

type buffer struct {
        buf    []byte
        err    error
        offset int
}

func (b *buffer) isEmpty() bool <span class="cov8" title="1">{
        if b == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if len(b.buf)-b.offset &lt;= 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (b *buffer) read(rd io.Reader) error <span class="cov8" title="1">{
        var n int
        n, b.err = readFill(rd, b.buf)
        b.buf = b.buf[0:n]
        b.offset = 0
        return b.err
}</span>

func (b *buffer) buffer() []byte <span class="cov8" title="1">{
        return b.buf[b.offset:]
}</span>

func (b *buffer) increment(n int) <span class="cov8" title="1">{
        b.offset += n
}</span>

const (
        AsyncReadeBufferSize = 1024 * 1024
        softStartInitial     = 512 * 1024
)

type ReaderRangeGetOutput struct {
        Body          io.ReadCloser
        ContentLength int64
        ContentRange  *string
        ETag          *string
        LastModified  *time.Time
}

type ReaderRangeGetFn func(context.Context, HTTPRange) (output *ReaderRangeGetOutput, err error)

type AsyncRangeReader struct {
        in      io.ReadCloser // Input reader
        ready   chan *buffer  // Buffers ready to be handed to the reader
        token   chan struct{} // Tokens which allow a buffer to be taken
        exit    chan struct{} // Closes when finished
        buffers int           // Number of buffers
        err     error         // If an error has occurred it is here
        cur     *buffer       // Current buffer being served
        exited  chan struct{} // Channel is closed been the async reader shuts down
        size    int           // size of buffer to use
        closed  bool          // whether we have closed the underlying stream
        mu      sync.Mutex    // lock for Read/WriteTo/Abandon/Close

        //Range Getter
        rangeGet  ReaderRangeGetFn
        httpRange HTTPRange

        // For reader
        offset  int64
        gotsize int64

        oriHttpRange HTTPRange

        context context.Context
        cancel  context.CancelFunc

        // Origin file pattern
        etag    string
        modTime string
}

// NewAsyncRangeReader returns a reader that will asynchronously read from
// the Reader returued by getter from the given offset into a number of buffers each of size AsyncReadeBufferSize
// The input can be read from the returned reader.
// When done use Close to release the buffers and close the supplied input.
// The etag is used to identify the content of the object. If not set, the first ETag returned value will be used instead.
func NewAsyncRangeReader(ctx context.Context,
        rangeGet ReaderRangeGetFn, httpRange *HTTPRange, etag string, buffers int) (*AsyncRangeReader, error) <span class="cov8" title="1">{

        if buffers &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("number of buffers too small")
        }</span>
        <span class="cov8" title="1">if rangeGet == nil </span><span class="cov8" title="1">{
                return nil, errors.New("nil reader supplied")
        }</span>

        <span class="cov8" title="1">context, cancel := context.WithCancel(ctx)

        range_ := HTTPRange{}
        if httpRange != nil </span><span class="cov8" title="1">{
                range_ = *httpRange
        }</span>

        <span class="cov8" title="1">a := &amp;AsyncRangeReader{
                rangeGet:     rangeGet,
                context:      context,
                cancel:       cancel,
                httpRange:    range_,
                oriHttpRange: range_,
                offset:       range_.Offset,
                gotsize:      0,
                etag:         etag,
                buffers:      buffers,
        }

        //fmt.Printf("NewAsyncRangeReader, range: %s, etag:%s, buffer count:%v\n", ToString(a.httpRange.FormatHTTPRange()), a.etag, a.buffers)

        a.init(buffers)
        return a, nil</span>
}

func (a *AsyncRangeReader) init(buffers int) <span class="cov8" title="1">{
        a.ready = make(chan *buffer, buffers)
        a.token = make(chan struct{}, buffers)
        a.exit = make(chan struct{})
        a.exited = make(chan struct{})
        a.buffers = buffers
        a.cur = nil
        a.size = softStartInitial

        // Create tokens
        for i := 0; i &lt; buffers; i++ </span><span class="cov8" title="1">{
                a.token &lt;- struct{}{}
        }</span>

        // Start async reader
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                // Ensure that when we exit this is signalled.
                defer close(a.exited)
                defer close(a.ready)
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-a.token:<span class="cov8" title="1">
                                b := a.getBuffer()
                                if a.size &lt; AsyncReadeBufferSize </span><span class="cov8" title="1">{
                                        b.buf = b.buf[:a.size]
                                        a.size &lt;&lt;= 1
                                }</span>

                                <span class="cov8" title="1">if a.httpRange.Count &gt; 0 &amp;&amp; a.gotsize &gt; a.httpRange.Count </span><span class="cov0" title="0">{
                                        b.buf = b.buf[0:0]
                                        b.err = io.EOF
                                        //fmt.Printf("a.gotsize &gt; a.httpRange.Count, err:%v\n", b.err)
                                        a.ready &lt;- b
                                        return
                                }</span>

                                <span class="cov8" title="1">if a.in == nil </span><span class="cov8" title="1">{
                                        output, err := a.rangeGet(a.context, a.httpRange)
                                        if err == nil </span><span class="cov8" title="1">{
                                                etag := ToString(output.ETag)
                                                if a.etag == "" </span><span class="cov8" title="1">{
                                                        a.etag = etag
                                                }</span>
                                                <span class="cov8" title="1">if etag != a.etag </span><span class="cov8" title="1">{
                                                        err = fmt.Errorf("Source file is changed, expect etag:%s ,got offset:%s", a.etag, etag)
                                                }</span>

                                                // Partial Response check
                                                <span class="cov8" title="1">var off int64
                                                if output.ContentRange == nil </span><span class="cov8" title="1">{
                                                        off = 0
                                                }</span> else<span class="cov8" title="1"> {
                                                        off, _, _, _ = ParseContentRange(*output.ContentRange)
                                                }</span>
                                                <span class="cov8" title="1">if off != a.httpRange.Offset </span><span class="cov8" title="1">{
                                                        err = fmt.Errorf("Range get fail, expect offset:%v, got offset:%v", a.httpRange.Offset, off)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                                b.buf = b.buf[0:0]
                                                b.err = err
                                                //fmt.Printf("call getFunc fail, err:%v\n", err)
                                                a.ready &lt;- b
                                                return
                                        }</span>
                                        <span class="cov8" title="1">body := output.Body
                                        if a.httpRange.Count &gt; 0 </span><span class="cov8" title="1">{
                                                body = NewLimitedReadCloser(output.Body, a.httpRange.Count)
                                        }</span>
                                        <span class="cov8" title="1">a.in = body</span>
                                        //fmt.Printf("call getFunc done, range:%s\n", ToString(a.httpRange.FormatHTTPRange()))
                                }

                                // ignore err from read
                                <span class="cov8" title="1">err := b.read(a.in)
                                a.httpRange.Offset += int64(len(b.buf))
                                a.gotsize += int64(len(b.buf))
                                if err != io.EOF </span><span class="cov8" title="1">{
                                        b.err = nil
                                }</span>
                                //fmt.Printf("read into buffer, size:%v, next begin:%v, err:%v\n", len(b.buf), a.httpRange.Offset, err)
                                <span class="cov8" title="1">a.ready &lt;- b
                                if err != nil </span><span class="cov8" title="1">{
                                        a.in.Close()
                                        a.in = nil
                                        if err == io.EOF </span><span class="cov8" title="1">{
                                                return
                                        }</span>
                                }
                        case &lt;-a.exit:<span class="cov8" title="1">
                                return</span>
                        }
                }
        }()
}

func (a *AsyncRangeReader) fill() (err error) <span class="cov8" title="1">{
        if a.cur.isEmpty() </span><span class="cov8" title="1">{
                if a.cur != nil </span><span class="cov8" title="1">{
                        a.putBuffer(a.cur)
                        a.token &lt;- struct{}{}
                        a.cur = nil
                }</span>
                <span class="cov8" title="1">b, ok := &lt;-a.ready
                if !ok </span><span class="cov8" title="1">{
                        // Return an error to show fill failed
                        if a.err == nil </span><span class="cov8" title="1">{
                                return errors.New("stream abandoned")
                        }</span>
                        <span class="cov8" title="1">return a.err</span>
                }
                <span class="cov8" title="1">a.cur = b</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Read will return the next available data.
func (a *AsyncRangeReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()
        defer func() </span><span class="cov8" title="1">{
                a.offset += int64(n)
        }</span>()

        // Swap buffer and maybe return error
        <span class="cov8" title="1">err = a.fill()
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        // Copy what we can
        <span class="cov8" title="1">n = copy(p, a.cur.buffer())
        a.cur.increment(n)

        // If at end of buffer, return any error, if present
        if a.cur.isEmpty() </span><span class="cov8" title="1">{
                a.err = a.cur.err
                return n, a.err
        }</span>
        <span class="cov8" title="1">return n, nil</span>
}

func (a *AsyncRangeReader) Offset() int64 <span class="cov8" title="1">{
        return a.offset
}</span>

func (a *AsyncRangeReader) Close() (err error) <span class="cov8" title="1">{
        a.abandon()
        if a.closed </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">a.closed = true

        if a.in != nil </span><span class="cov8" title="1">{
                err = a.in.Close()
        }</span>
        <span class="cov8" title="1">return</span>
}

func (a *AsyncRangeReader) abandon() <span class="cov8" title="1">{
        a.stop()
        a.mu.Lock()
        defer a.mu.Unlock()
        if a.cur != nil </span><span class="cov8" title="1">{
                a.putBuffer(a.cur)
                a.cur = nil
        }</span>
        <span class="cov8" title="1">for b := range a.ready </span><span class="cov8" title="1">{
                a.putBuffer(b)
        }</span>
}

func (a *AsyncRangeReader) stop() <span class="cov8" title="1">{
        select </span>{
        case &lt;-a.exit:<span class="cov8" title="1">
                return</span>
        default:<span class="cov8" title="1"></span>
        }
        <span class="cov8" title="1">a.cancel()
        close(a.exit)
        &lt;-a.exited</span>
}

// bufferPool is a global pool of buffers
var bufferPool *sync.Pool
var bufferPoolOnce sync.Once

// TODO use pool
func (a *AsyncRangeReader) putBuffer(b *buffer) <span class="cov8" title="1">{
        b.buf = b.buf[0:cap(b.buf)]
        bufferPool.Put(b.buf)
}</span>

func (a *AsyncRangeReader) getBuffer() *buffer <span class="cov8" title="1">{
        bufferPoolOnce.Do(func() </span><span class="cov8" title="1">{
                // Initialise the buffer pool when used
                bufferPool = &amp;sync.Pool{
                        New: func() any </span><span class="cov8" title="1">{
                                //fmt.Printf("make([]byte, BufferSize)\n")
                                return make([]byte, AsyncReadeBufferSize)
                        }</span>,
                }
        })
        <span class="cov8" title="1">return &amp;buffer{
                buf: bufferPool.Get().([]byte),
        }</span>
}

func readFill(r io.Reader, buf []byte) (n int, err error) <span class="cov8" title="1">{
        var nn int
        for n &lt; len(buf) &amp;&amp; err == nil </span><span class="cov8" title="1">{
                nn, err = r.Read(buf[n:])
                n += nn
        }</span>
        <span class="cov8" title="1">return n, err</span>
}

// A Reader implements the io.Reader, io.Seeker interfaces by reading from multi byte slice.
type MultiBytesReader struct {
        s    [][]byte
        i    int64 // current reading index
        size int64
        rbuf int
        rp   int
}

// Len returns the number of bytes of the unread portion of the slice.
func (r *MultiBytesReader) Len() int <span class="cov8" title="1">{
        if r.i &gt;= r.size </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return int(r.size - r.i)</span>
}

// Size returns the original length of the underlying byte slice.
func (r *MultiBytesReader) Size() int64 <span class="cov8" title="1">{ return r.size }</span>

// Read implements the io.Reader interface.
func (r *MultiBytesReader) Read(b []byte) (n int, err error) <span class="cov8" title="1">{
        if r.i &gt;= r.size </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>

        <span class="cov8" title="1">var nn int
        for n &lt; len(b) &amp;&amp; err == nil </span><span class="cov8" title="1">{
                nn, err = r.read(b[n:])
                n += nn
        }</span>

        <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                err = nil
        }</span>

        <span class="cov8" title="1">return n, err</span>
}

func (r *MultiBytesReader) read(b []byte) (n int, err error) <span class="cov8" title="1">{
        if r.i &gt;= r.size </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>

        //if r.rp == cap(r.s[r.rbuf]) {
        <span class="cov8" title="1">if r.rp == len(r.s[r.rbuf]) </span><span class="cov8" title="1">{
                r.rbuf++
                r.rp = 0
        }</span>

        <span class="cov8" title="1">if r.rbuf == len(r.s) </span><span class="cov0" title="0">{
                err = io.EOF
                return
        }</span> else<span class="cov8" title="1"> if r.rbuf &gt; len(r.s) </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("read overflow, rbuf:%d, buf len%d", r.rbuf, len(r.s))
        }</span>

        <span class="cov8" title="1">n = copy(b, r.s[r.rbuf][r.rp:])
        r.rp += n
        r.i += int64(n)

        return</span>
}

// Seek implements the io.Seeker interface.
func (r *MultiBytesReader) Seek(offset int64, whence int) (int64, error) <span class="cov8" title="1">{
        var abs int64
        switch whence </span>{
        case io.SeekStart:<span class="cov8" title="1">
                abs = offset</span>
        case io.SeekCurrent:<span class="cov8" title="1">
                abs = r.i + offset</span>
        case io.SeekEnd:<span class="cov8" title="1">
                abs = r.size + offset</span>
        default:<span class="cov0" title="0">
                return 0, errors.New("MultiSliceReader.Seek: invalid whence")</span>
        }
        <span class="cov8" title="1">if abs &lt; 0 </span><span class="cov8" title="1">{
                return 0, errors.New("MultiSliceReader.Seek: negative position")
        }</span>
        <span class="cov8" title="1">r.i = abs
        r.updateRp()
        return abs, nil</span>
}

// Reset resets the Reader to be reading from b.
func (r *MultiBytesReader) Reset(b [][]byte) <span class="cov8" title="1">{
        n := MultiBytesReader{
                s: b,
                i: 0,
        }
        n.size = int64(r.calcSize(n.s))
        n.updateRp()
        *r = n
}</span>

func (r *MultiBytesReader) calcSize(b [][]byte) int <span class="cov8" title="1">{
        size := 0
        for i := 0; i &lt; len(b); i++ </span><span class="cov8" title="1">{
                size += len(r.s[i])
        }</span>
        <span class="cov8" title="1">return size</span>
}

func (r *MultiBytesReader) updateRp() <span class="cov8" title="1">{
        remains := r.i
        rbuf := 0
        for remains &gt; 0 &amp;&amp; rbuf &lt; len(r.s) </span><span class="cov8" title="1">{
                slen := int64(len(r.s[rbuf]))
                if remains &lt; slen </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">rbuf++
                remains -= slen</span>
        }
        <span class="cov8" title="1">r.rbuf = rbuf
        r.rp = int(remains)</span>
}

// NewReader returns a new Reader reading from b.
func NewMultiBytesReader(b [][]byte) *MultiBytesReader <span class="cov8" title="1">{
        r := &amp;MultiBytesReader{
                s: b,
                i: 0,
        }
        r.size = int64(r.calcSize(r.s))
        r.updateRp()
        return r
}</span>

type RangeReader struct {
        in     io.ReadCloser // Input reader
        closed bool          // whether we have closed the underlying stream

        //Range Getter
        rangeGet  ReaderRangeGetFn
        httpRange HTTPRange

        // For reader
        offset int64

        oriHttpRange HTTPRange

        context context.Context

        // Origin file pattern
        etag      string
        modTime   *time.Time
        totalSize int64
}

// NewRangeReader returns a reader that will read from the Reader returued by getter from the given offset.
// The etag is used to identify the content of the object. If not set, the first ETag returned value will be used instead.
func NewRangeReader(ctx context.Context, rangeGet ReaderRangeGetFn, httpRange *HTTPRange, etag string) (*RangeReader, error) <span class="cov8" title="1">{
        if rangeGet == nil </span><span class="cov8" title="1">{
                return nil, errors.New("nil reader supplied")
        }</span>

        <span class="cov8" title="1">range_ := HTTPRange{}
        if httpRange != nil </span><span class="cov8" title="1">{
                range_ = *httpRange
        }</span>

        <span class="cov8" title="1">a := &amp;RangeReader{
                rangeGet:     rangeGet,
                context:      ctx,
                httpRange:    range_,
                oriHttpRange: range_,
                offset:       range_.Offset,
                etag:         etag,
        }

        //fmt.Printf("NewRangeReader, range: %s, etag:%s\n", ToString(a.httpRange.FormatHTTPRange()), a.etag)

        return a, nil</span>
}

// Read will return the next available data.
func (r *RangeReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                r.offset += int64(n)
                r.httpRange.Offset += int64(n)
        }</span>()
        <span class="cov8" title="1">n, err = r.read(p)
        return</span>
}

func (r *RangeReader) read(p []byte) (int, error) <span class="cov8" title="1">{
        if r.closed </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("RangeReader is closed")
        }</span>

        // open stream
        <span class="cov8" title="1">if r.in == nil </span><span class="cov8" title="1">{
                output, err := r.rangeGet(r.context, r.httpRange)
                if err == nil </span><span class="cov8" title="1">{
                        etag := ToString(output.ETag)
                        if r.etag == "" </span><span class="cov8" title="1">{
                                r.etag = etag
                                r.modTime = output.LastModified
                        }</span>
                        <span class="cov8" title="1">if etag != r.etag </span><span class="cov8" title="1">{
                                err = fmt.Errorf("Source file is changed, expect etag:%s ,got offset:%s", r.etag, etag)
                        }</span>

                        // Partial Response check
                        <span class="cov8" title="1">var off int64
                        if output.ContentRange == nil </span><span class="cov8" title="1">{
                                off = 0
                                r.totalSize = output.ContentLength
                        }</span> else<span class="cov8" title="1"> {
                                off, _, r.totalSize, _ = ParseContentRange(*output.ContentRange)
                        }</span>
                        <span class="cov8" title="1">if off != r.httpRange.Offset </span><span class="cov8" title="1">{
                                err = fmt.Errorf("Range get fail, expect offset:%v, got offset:%v", r.httpRange.Offset, off)
                        }</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">body := output.Body
                if r.httpRange.Count &gt; 0 </span><span class="cov8" title="1">{
                        body = NewLimitedReadCloser(output.Body, r.httpRange.Count)
                }</span>
                <span class="cov8" title="1">r.in = body</span>
        }

        // read from stream
        // ignore error when reading from stream
        <span class="cov8" title="1">n, err := r.in.Read(p)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov8" title="1">{
                r.in.Close()
                r.in = nil
                err = nil
        }</span>

        <span class="cov8" title="1">return n, err</span>
}

func (r *RangeReader) Offset() int64 <span class="cov0" title="0">{
        return r.offset
}</span>

func (r *RangeReader) Close() (err error) <span class="cov8" title="1">{
        if r.closed </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">r.closed = true

        if r.in != nil </span><span class="cov8" title="1">{
                err = r.in.Close()
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package oss

import (
        "context"
        "time"

        "golang.org/x/time/rate"
)

const (
        BwTokenBucketSlotRx int = iota
        BwTokenBucketSlotTx
        BwTokenBucketSlots
)

type BwTokenBucket struct {
        // Byte/S
        Bandwidth int64
        Limiter   *rate.Limiter
}

type BwTokenBuckets [BwTokenBucketSlots]*BwTokenBucket

func newBwTokenBucket(bandwidth int64) *BwTokenBucket <span class="cov0" title="0">{
        return &amp;BwTokenBucket{
                Bandwidth: bandwidth,
                Limiter:   newEmptyTokenBucket(bandwidth),
        }
}</span>

func newEmptyTokenBucket(bandwidth int64) *rate.Limiter <span class="cov0" title="0">{
        const defaultMaxBurstSize = 4 * 1024 * 1024
        maxBurstSize := (bandwidth * defaultMaxBurstSize) / (256 * 1024 * 1024)
        if maxBurstSize &lt; defaultMaxBurstSize </span><span class="cov0" title="0">{
                maxBurstSize = defaultMaxBurstSize
        }</span>
        <span class="cov0" title="0">tb := rate.NewLimiter(rate.Limit(bandwidth), int(maxBurstSize))
        tb.AllowN(time.Now(), int(maxBurstSize))
        return tb</span>
}

func (tb *BwTokenBucket) LimitBandwidth(n int) <span class="cov0" title="0">{
        tb.Limiter.WaitN(context.Background(), n)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package oss

// Ptr returns a pointer to the provided value.
func Ptr[T any](v T) *T <span class="cov8" title="1">{
        return &amp;v
}</span>

// SliceOfPtrs returns a slice of *T from the specified values.
func SliceOfPtrs[T any](vv ...T) []*T <span class="cov8" title="1">{
        slc := make([]*T, len(vv))
        for i := range vv </span><span class="cov8" title="1">{
                slc[i] = Ptr(vv[i])
        }</span>
        <span class="cov8" title="1">return slc</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package oss

import (
        "io"
        "net/http"
)

type OperationMetadata struct {
        values map[any]any
}

func (m OperationMetadata) Get(key any) any <span class="cov8" title="1">{
        return m.values[key]
}</span>

func (m OperationMetadata) Clone() OperationMetadata <span class="cov0" title="0">{
        vs := make(map[any]any, len(m.values))
        for k, v := range m.values </span><span class="cov0" title="0">{
                vs[k] = v
        }</span>

        <span class="cov0" title="0">return OperationMetadata{
                values: vs,
        }</span>
}

func (m *OperationMetadata) Set(key, value any) <span class="cov8" title="1">{
        if m.values == nil </span><span class="cov8" title="1">{
                m.values = map[any]any{}
        }</span>
        <span class="cov8" title="1">m.values[key] = value</span>
}

func (m OperationMetadata) Has(key any) bool <span class="cov0" title="0">{
        if m.values == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">_, ok := m.values[key]
        return ok</span>
}

type RequestCommon struct {
        Headers    map[string]string
        Parameters map[string]string
        Body       io.Reader
}

type RequestCommonInterface interface {
        GetCommonFileds() (map[string]string, map[string]string, io.Reader)
}

func (r *RequestCommon) GetCommonFileds() (map[string]string, map[string]string, io.Reader) <span class="cov8" title="1">{
        return r.Headers, r.Parameters, r.Body
}</span>

type ResultCommon struct {
        Status     string
        StatusCode int
        Headers    http.Header
        OpMetadata OperationMetadata
}

type ResultCommonInterface interface {
        CopyIn(status string, statusCode int, headers http.Header, meta OperationMetadata)
}

func (r *ResultCommon) CopyIn(status string, statusCode int, headers http.Header, meta OperationMetadata) <span class="cov8" title="1">{
        r.Status = status
        r.StatusCode = statusCode
        r.Headers = headers
        r.OpMetadata = meta
}</span>

type OperationInput struct {
        OpName     string
        Method     string
        Headers    map[string]string
        Parameters map[string]string
        Body       io.Reader

        Bucket *string
        Key    *string

        OpMetadata OperationMetadata
}

type OperationOutput struct {
        Input *OperationInput

        Status     string
        StatusCode int
        Headers    http.Header
        Body       io.ReadCloser

        OpMetadata OperationMetadata

        httpRequest *http.Request
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package oss

import (
        "bytes"
        "context"
        "encoding"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "reflect"
        "runtime"
        "strconv"
        "strings"
        "time"
)

func init() <span class="cov8" title="1">{
        for i := 0; i &lt; len(noEscape); i++ </span><span class="cov8" title="1">{
                noEscape[i] = (i &gt;= 'A' &amp;&amp; i &lt;= 'Z') ||
                        (i &gt;= 'a' &amp;&amp; i &lt;= 'z') ||
                        (i &gt;= '0' &amp;&amp; i &lt;= '9') ||
                        i == '-' ||
                        i == '.' ||
                        i == '_' ||
                        i == '~'
        }</span>
}

var noEscape [256]bool

func sleepWithContext(ctx context.Context, dur time.Duration) error <span class="cov8" title="1">{
        t := time.NewTimer(dur)
        defer t.Stop()

        select </span>{
        case &lt;-t.C:<span class="cov8" title="1">
                break</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getNowSec returns Unix time, the number of seconds elapsed since January 1, 1970 UTC.
// gets the current time in Unix time, in seconds.
func getNowSec() int64 <span class="cov0" title="0">{
        return time.Now().Unix()
}</span>

// getNowGMT gets the current time in GMT format.
func getNowGMT() string <span class="cov8" title="1">{
        return time.Now().UTC().Format(http.TimeFormat)
}</span>

func escapePath(path string, encodeSep bool) string <span class="cov8" title="1">{
        var buf bytes.Buffer
        for i := 0; i &lt; len(path); i++ </span><span class="cov8" title="1">{
                c := path[i]
                if noEscape[c] || (c == '/' &amp;&amp; !encodeSep) </span><span class="cov8" title="1">{
                        buf.WriteByte(c)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Fprintf(&amp;buf, "%%%02X", c)
                }</span>
        }
        <span class="cov8" title="1">return buf.String()</span>
}

func isEmptyValue(v reflect.Value) bool <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.Array, reflect.Map, reflect.Slice, reflect.String:<span class="cov8" title="1">
                return v.Len() == 0</span>
        case reflect.Bool:<span class="cov8" title="1">
                return !v.Bool()</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return v.Int() == 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                return v.Uint() == 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return v.Float() == 0</span>
        case reflect.Interface, reflect.Pointer:<span class="cov8" title="1">
                return v.IsNil()</span>
        }
        <span class="cov0" title="0">return false</span>
}

func setTimeReflectValue(dst reflect.Value, value time.Time) (err error) <span class="cov8" title="1">{
        dst0 := dst
        if dst.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                if dst.IsNil() </span><span class="cov8" title="1">{
                        dst.Set(reflect.New(dst.Type().Elem()))
                }</span>
                <span class="cov8" title="1">dst = dst.Elem()</span>
        }
        <span class="cov8" title="1">if dst.CanAddr() </span><span class="cov8" title="1">{
                pv := dst.Addr()
                if pv.CanInterface() </span><span class="cov8" title="1">{
                        if val, ok := pv.Interface().(encoding.TextUnmarshaler); ok </span><span class="cov8" title="1">{
                                return val.UnmarshalText([]byte(value.Format(time.RFC3339)))
                        }</span>
                }
        }
        <span class="cov0" title="0">return errors.New("cannot unmarshal into " + dst0.Type().String())</span>
}

func setReflectValue(dst reflect.Value, data string) (err error) <span class="cov8" title="1">{
        dst0 := dst
        src := []byte(data)

        if dst.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                if dst.IsNil() </span><span class="cov8" title="1">{
                        dst.Set(reflect.New(dst.Type().Elem()))
                }</span>
                <span class="cov8" title="1">dst = dst.Elem()</span>
        }

        <span class="cov8" title="1">switch dst.Kind() </span>{
        case reflect.Invalid:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return errors.New("cannot unmarshal into " + dst0.Type().String())</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                if len(src) == 0 </span><span class="cov0" title="0">{
                        dst.SetInt(0)
                        return nil
                }</span>
                <span class="cov8" title="1">itmp, err := strconv.ParseInt(strings.TrimSpace(string(src)), 10, dst.Type().Bits())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">dst.SetInt(itmp)</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                if len(src) == 0 </span><span class="cov0" title="0">{
                        dst.SetUint(0)
                        return nil
                }</span>
                <span class="cov0" title="0">utmp, err := strconv.ParseUint(strings.TrimSpace(string(src)), 10, dst.Type().Bits())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">dst.SetUint(utmp)</span>
        case reflect.Bool:<span class="cov8" title="1">
                if len(src) == 0 </span><span class="cov0" title="0">{
                        dst.SetBool(false)
                        return nil
                }</span>
                <span class="cov8" title="1">value, err := strconv.ParseBool(strings.TrimSpace(string(src)))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">dst.SetBool(value)</span>
        case reflect.String:<span class="cov8" title="1">
                dst.SetString(string(src))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func setMapStringReflectValue(dst reflect.Value, key any, data any) (err error) <span class="cov8" title="1">{
        dst0 := dst

        if dst.Kind() == reflect.Pointer </span><span class="cov0" title="0">{
                if dst.IsNil() </span><span class="cov0" title="0">{
                        dst.Set(reflect.New(dst.Type().Elem()))
                }</span>
                <span class="cov0" title="0">dst = dst.Elem()</span>
        }

        <span class="cov8" title="1">switch dst.Kind() </span>{
        case reflect.Invalid:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return errors.New("cannot unmarshal into " + dst0.Type().String())</span>
        case reflect.Map:<span class="cov8" title="1">
                if dst.IsNil() </span><span class="cov8" title="1">{
                        dst.Set(reflect.MakeMap(dst.Type()))
                }</span>
                <span class="cov8" title="1">mapValue := reflect.ValueOf(data)
                mapKey := reflect.ValueOf(key)
                dst.SetMapIndex(mapKey, mapValue)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func defaultUserAgent() string <span class="cov8" title="1">{
        return fmt.Sprintf("aliyun-sdk-go/%s (%s/%s/%s;%s)", Version(), runtime.GOOS,
                "-", runtime.GOARCH, runtime.Version())
}</span>

func isContextError(ctx context.Context, perr *error) bool <span class="cov8" title="1">{
        if ctxErr := ctx.Err(); ctxErr != nil </span><span class="cov0" title="0">{
                if *perr == nil </span><span class="cov0" title="0">{
                        *perr = ctxErr
                }</span>
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func copySeekableBody(dst io.Writer, src io.ReadSeeker) (int64, error) <span class="cov8" title="1">{
        curPos, err := src.Seek(0, io.SeekCurrent)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">n, err := io.Copy(dst, src)
        if err != nil </span><span class="cov0" title="0">{
                return n, err
        }</span>

        <span class="cov8" title="1">_, err = src.Seek(curPos, io.SeekStart)
        if err != nil </span><span class="cov0" title="0">{
                return n, err
        }</span>

        <span class="cov8" title="1">return n, nil</span>
}

func ParseOffsetAndSizeFromHeaders(headers http.Header) (offset, size int64) <span class="cov0" title="0">{
        return parseOffsetAndSizeFromHeaders(headers)
}</span>

func parseOffsetAndSizeFromHeaders(headers http.Header) (offset, size int64) <span class="cov8" title="1">{
        size = -1
        var contentLength = headers.Get("Content-Length")
        if len(contentLength) != 0 </span><span class="cov8" title="1">{
                var err error
                if size, err = strconv.ParseInt(contentLength, 10, 64); err != nil </span><span class="cov8" title="1">{
                        return 0, -1
                }</span>
        }

        <span class="cov8" title="1">var contentRange = headers.Get("Content-Range")
        if len(contentRange) == 0 </span><span class="cov8" title="1">{
                return 0, size
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(contentRange, "bytes ") </span><span class="cov8" title="1">{
                return 0, -1
        }</span>

        // start offset
        <span class="cov8" title="1">dash := strings.IndexRune(contentRange, '-')
        if dash &lt; 0 </span><span class="cov0" title="0">{
                return 0, -1
        }</span>
        <span class="cov8" title="1">ret, err := strconv.ParseInt(contentRange[6:dash], 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0, -1
        }</span>
        <span class="cov8" title="1">offset = ret

        // total size
        slash := strings.IndexRune(contentRange, '/')
        if slash &lt; 0 </span><span class="cov8" title="1">{
                return 0, -1
        }</span>
        <span class="cov8" title="1">ret, err = strconv.ParseInt(contentRange[slash+1:], 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0, -1
        }</span>
        <span class="cov8" title="1">size = ret

        return offset, size</span>
}

func minInt64(a, b int64) int64 <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span> else<span class="cov8" title="1"> {
                return b
        }</span>
}

func maxInt64(a, b int64) int64 <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span> else<span class="cov8" title="1"> {
                return b
        }</span>
}

// ParseRange parses a ContentRange from a ContentRange: header.
// It only accepts bytes 22-33/42 and bytes 22-33/* format.
func ParseContentRange(s string) (from int64, to int64, total int64, err error) <span class="cov8" title="1">{
        if !strings.HasPrefix(s, "bytes ") </span><span class="cov8" title="1">{
                return from, to, total, errors.New("invalid content range")
        }</span>

        <span class="cov8" title="1">slash := strings.IndexRune(s, '/')
        if slash &lt; 0 </span><span class="cov0" title="0">{
                return from, to, total, errors.New("invalid content range")
        }</span>

        <span class="cov8" title="1">dash := strings.IndexRune(s, '-')
        if dash &lt; 0 </span><span class="cov8" title="1">{
                return from, to, total, errors.New("invalid content range")
        }</span>

        <span class="cov8" title="1">if slash &lt; dash </span><span class="cov0" title="0">{
                return from, to, total, errors.New("invalid content range")
        }</span>

        // from
        <span class="cov8" title="1">ret, err := strconv.ParseInt(s[6:dash], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return from, to, total, errors.New("invalid content range")
        }</span>
        <span class="cov8" title="1">from = ret

        // to
        ret, err = strconv.ParseInt(s[dash+1:slash], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return from, to, total, errors.New("invalid content range")
        }</span>
        <span class="cov8" title="1">to = ret

        // total
        last := s[slash+1:]
        if last == "*" </span><span class="cov8" title="1">{
                total = -1
        }</span> else<span class="cov8" title="1"> {
                ret, err = strconv.ParseInt(s[slash+1:], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return from, to, total, errors.New("invalid content range")
                }</span>
                <span class="cov8" title="1">total = ret</span>
        }

        <span class="cov8" title="1">return from, to, total, nil</span>
}

// ParseRange parses a HTTPRange from a Range: header.
// It only accepts single ranges.
func ParseRange(s string) (r *HTTPRange, err error) <span class="cov8" title="1">{
        const preamble = "bytes="
        if !strings.HasPrefix(s, preamble) </span><span class="cov8" title="1">{
                return nil, errors.New("range: header invalid: doesn't start with " + preamble)
        }</span>
        <span class="cov8" title="1">s = s[len(preamble):]
        if strings.ContainsRune(s, ',') </span><span class="cov0" title="0">{
                return nil, errors.New("range: header invalid: contains multiple ranges which isn't supported")
        }</span>
        <span class="cov8" title="1">dash := strings.IndexRune(s, '-')
        if dash &lt; 0 </span><span class="cov0" title="0">{
                return nil, errors.New("range: header invalid: contains no '-'")
        }</span>
        <span class="cov8" title="1">start, end := strings.TrimSpace(s[:dash]), strings.TrimSpace(s[dash+1:])
        o := HTTPRange{Offset: 0, Count: 0}
        if start != "" </span><span class="cov8" title="1">{
                o.Offset, err = strconv.ParseInt(start, 10, 64)
                if err != nil || o.Offset &lt; 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("range: header invalid: bad start")
                }</span>
        }
        <span class="cov8" title="1">if end != "" </span><span class="cov8" title="1">{
                e, err := strconv.ParseInt(end, 10, 64)
                if err != nil || e &lt; 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("range: header invalid: bad end")
                }</span>
                <span class="cov8" title="1">o.Count = e - o.Offset + 1</span>
        }
        <span class="cov8" title="1">return &amp;o, nil</span>
}

// FileExists returns whether the given file exists or not
func FileExists(filename string) bool <span class="cov8" title="1">{
        info, err := os.Stat(filename)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return !info.IsDir()</span>
}

// DirExists returns whether the given directory exists or not
func DirExists(dir string) bool <span class="cov8" title="1">{
        info, err := os.Stat(dir)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return info.IsDir()</span>
}

// EmptyFile changes the size of the named file to zero.
func EmptyFile(filename string) bool <span class="cov0" title="0">{
        err := os.Truncate(filename, 0)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package oss

import (
        "io"
        "reflect"
        "time"
)

func copyRequest(dst, src interface{}) <span class="cov8" title="1">{
        dstval := reflect.ValueOf(dst)
        if !dstval.IsValid() </span><span class="cov0" title="0">{
                panic("Copy dst cannot be nil")</span>
        }

        <span class="cov8" title="1">rcopy(dstval, reflect.ValueOf(src), true)</span>
}

func copyOfRequest(src interface{}) (dst interface{}) <span class="cov0" title="0">{
        dsti := reflect.New(reflect.TypeOf(src).Elem())
        dst = dsti.Interface()
        rcopy(dsti, reflect.ValueOf(src), true)
        return
}</span>

func rcopy(dst, src reflect.Value, root bool) <span class="cov8" title="1">{
        if !src.IsValid() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">switch src.Kind() </span>{
        case reflect.Ptr:<span class="cov8" title="1">
                if _, ok := src.Interface().(io.Reader); ok </span><span class="cov0" title="0">{
                        if dst.Kind() == reflect.Ptr &amp;&amp; dst.Elem().CanSet() </span><span class="cov0" title="0">{
                                dst.Elem().Set(src)
                        }</span> else<span class="cov0" title="0"> if dst.CanSet() </span><span class="cov0" title="0">{
                                dst.Set(src)
                        }</span>
                } else<span class="cov8" title="1"> {
                        e := src.Type().Elem()
                        if dst.CanSet() &amp;&amp; !src.IsNil() </span><span class="cov8" title="1">{
                                if _, ok := src.Interface().(*time.Time); !ok </span><span class="cov8" title="1">{
                                        if dst.Kind() == reflect.String </span><span class="cov0" title="0">{
                                                dst.SetString(e.String())
                                        }</span> else<span class="cov8" title="1"> {
                                                dst.Set(reflect.New(e))
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        tempValue := reflect.New(e)
                                        tempValue.Elem().Set(src.Elem())
                                        dst.Set(tempValue)
                                }</span>
                        }
                        <span class="cov8" title="1">if dst.Kind() != reflect.String &amp;&amp; src.Elem().IsValid() </span><span class="cov8" title="1">{
                                rcopy(dst.Elem(), src.Elem(), root)
                        }</span>
                }
        case reflect.Struct:<span class="cov8" title="1">
                t := dst.Type()
                for i := 0; i &lt; t.NumField(); i++ </span><span class="cov8" title="1">{
                        name := t.Field(i).Name
                        srcVal := src.FieldByName(name)
                        dstVal := dst.FieldByName(name)
                        if srcVal.IsValid() &amp;&amp; dstVal.CanSet() </span><span class="cov8" title="1">{
                                rcopy(dstVal, srcVal, false)
                        }</span>
                }
        case reflect.Slice:<span class="cov0" title="0">
                if src.IsNil() </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">s := reflect.MakeSlice(src.Type(), src.Len(), src.Cap())
                dst.Set(s)
                for i := 0; i &lt; src.Len(); i++ </span><span class="cov0" title="0">{
                        rcopy(dst.Index(i), src.Index(i), false)
                }</span>
        case reflect.Map:<span class="cov8" title="1">
                if src.IsNil() </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">s := reflect.MakeMap(src.Type())
                dst.Set(s)
                for _, k := range src.MapKeys() </span><span class="cov8" title="1">{
                        v := src.MapIndex(k)
                        v2 := reflect.New(v.Type()).Elem()
                        rcopy(v2, v, false)
                        dst.SetMapIndex(k, v2)
                }</span>
        default:<span class="cov8" title="1">
                if src.Type().AssignableTo(dst.Type()) </span><span class="cov8" title="1">{
                        dst.Set(src)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package oss

import (
        "hash"
        "hash/crc64"
)

// hashCRC64 represents the partial evaluation of a checksum.
type hashCRC64 struct {
        init uint64
        crc  uint64
        tab  *crc64.Table
}

// NewCRC creates a new hash.Hash64 computing the CRC64 checksum
// using the polynomial represented by the Table.
func NewCRC64(init uint64) hash.Hash64 <span class="cov8" title="1">{
        return &amp;hashCRC64{
                init: init,
                crc:  init,
                tab:  crc64.MakeTable(crc64.ECMA),
        }
}</span>

// Size returns the number of bytes sum will return.
func (d *hashCRC64) Size() int <span class="cov0" title="0">{
        return crc64.Size
}</span>

// BlockSize returns the hash's underlying block size.
// The Write method must be able to accept any amount
// of data, but it may operate more efficiently if all writes
// are a multiple of the block size.
func (d *hashCRC64) BlockSize() int <span class="cov0" title="0">{
        return 1
}</span>

// Reset resets the hash to its initial state.
func (d *hashCRC64) Reset() <span class="cov8" title="1">{
        d.crc = d.init
}</span>

// Write (via the embedded io.Writer interface) adds more data to the running hash.
// It never returns an error.
func (d *hashCRC64) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        d.crc = crc64.Update(d.crc, d.tab, p)
        return len(p), nil
}</span>

// Sum64 returns CRC64 value.
func (d *hashCRC64) Sum64() uint64 <span class="cov8" title="1">{
        return d.crc
}</span>

// Sum returns hash value.
func (d *hashCRC64) Sum(in []byte) []byte <span class="cov0" title="0">{
        s := d.Sum64()
        return append(in, byte(s&gt;&gt;56), byte(s&gt;&gt;48), byte(s&gt;&gt;40), byte(s&gt;&gt;32), byte(s&gt;&gt;24), byte(s&gt;&gt;16), byte(s&gt;&gt;8), byte(s))
}</span>

// gf2Dim dimension of GF(2) vectors (length of CRC)
const gf2Dim int = 64

func gf2MatrixTimes(mat []uint64, vec uint64) uint64 <span class="cov8" title="1">{
        var sum uint64
        for i := 0; vec != 0; i++ </span><span class="cov8" title="1">{
                if vec&amp;1 != 0 </span><span class="cov8" title="1">{
                        sum ^= mat[i]
                }</span>

                <span class="cov8" title="1">vec &gt;&gt;= 1</span>
        }
        <span class="cov8" title="1">return sum</span>
}

func gf2MatrixSquare(square []uint64, mat []uint64) <span class="cov8" title="1">{
        for n := 0; n &lt; gf2Dim; n++ </span><span class="cov8" title="1">{
                square[n] = gf2MatrixTimes(mat, mat[n])
        }</span>
}

// CRC64Combine combines CRC64
func CRC64Combine(crc1 uint64, crc2 uint64, len2 uint64) uint64 <span class="cov8" title="1">{
        var even [gf2Dim]uint64 // Even-power-of-two zeros operator
        var odd [gf2Dim]uint64  // Odd-power-of-two zeros operator

        // Degenerate case
        if len2 == 0 </span><span class="cov0" title="0">{
                return crc1
        }</span>

        // Put operator for one zero bit in odd
        <span class="cov8" title="1">odd[0] = crc64.ECMA // CRC64 polynomial
        var row uint64 = 1
        for n := 1; n &lt; gf2Dim; n++ </span><span class="cov8" title="1">{
                odd[n] = row
                row &lt;&lt;= 1
        }</span>

        // Put operator for two zero bits in even
        <span class="cov8" title="1">gf2MatrixSquare(even[:], odd[:])

        // Put operator for four zero bits in odd
        gf2MatrixSquare(odd[:], even[:])

        // Apply len2 zeros to crc1, first square will put the operator for one zero byte, eight zero bits, in even
        for </span><span class="cov8" title="1">{
                // Apply zeros operator for this bit of len2
                gf2MatrixSquare(even[:], odd[:])

                if len2&amp;1 != 0 </span><span class="cov8" title="1">{
                        crc1 = gf2MatrixTimes(even[:], crc1)
                }</span>

                <span class="cov8" title="1">len2 &gt;&gt;= 1

                // If no more bits set, then done
                if len2 == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Another iteration of the loop with odd and even swapped
                <span class="cov8" title="1">gf2MatrixSquare(odd[:], even[:])
                if len2&amp;1 != 0 </span><span class="cov8" title="1">{
                        crc1 = gf2MatrixTimes(odd[:], crc1)
                }</span>
                <span class="cov8" title="1">len2 &gt;&gt;= 1

                // If no more bits set, then done
                if len2 == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        // Return combined CRC
        <span class="cov8" title="1">crc1 ^= crc2
        return crc1</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package oss

import (
        "mime"
        "path"
        "strings"
)

var extToMimeType = map[string]string{
        ".xlsx":          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        ".xltx":          "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
        ".potx":          "application/vnd.openxmlformats-officedocument.presentationml.template",
        ".ppsx":          "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
        ".pptx":          "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        ".sldx":          "application/vnd.openxmlformats-officedocument.presentationml.slide",
        ".docx":          "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        ".dotx":          "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
        ".xlam":          "application/vnd.ms-excel.addin.macroEnabled.12",
        ".xlsb":          "application/vnd.ms-excel.sheet.binary.macroEnabled.12",
        ".apk":           "application/vnd.android.package-archive",
        ".hqx":           "application/mac-binhex40",
        ".cpt":           "application/mac-compactpro",
        ".doc":           "application/msword",
        ".ogg":           "application/ogg",
        ".pdf":           "application/pdf",
        ".rtf":           "text/rtf",
        ".mif":           "application/vnd.mif",
        ".xls":           "application/vnd.ms-excel",
        ".ppt":           "application/vnd.ms-powerpoint",
        ".odc":           "application/vnd.oasis.opendocument.chart",
        ".odb":           "application/vnd.oasis.opendocument.database",
        ".odf":           "application/vnd.oasis.opendocument.formula",
        ".odg":           "application/vnd.oasis.opendocument.graphics",
        ".otg":           "application/vnd.oasis.opendocument.graphics-template",
        ".odi":           "application/vnd.oasis.opendocument.image",
        ".odp":           "application/vnd.oasis.opendocument.presentation",
        ".otp":           "application/vnd.oasis.opendocument.presentation-template",
        ".ods":           "application/vnd.oasis.opendocument.spreadsheet",
        ".ots":           "application/vnd.oasis.opendocument.spreadsheet-template",
        ".odt":           "application/vnd.oasis.opendocument.text",
        ".odm":           "application/vnd.oasis.opendocument.text-master",
        ".ott":           "application/vnd.oasis.opendocument.text-template",
        ".oth":           "application/vnd.oasis.opendocument.text-web",
        ".sxw":           "application/vnd.sun.xml.writer",
        ".stw":           "application/vnd.sun.xml.writer.template",
        ".sxc":           "application/vnd.sun.xml.calc",
        ".stc":           "application/vnd.sun.xml.calc.template",
        ".sxd":           "application/vnd.sun.xml.draw",
        ".std":           "application/vnd.sun.xml.draw.template",
        ".sxi":           "application/vnd.sun.xml.impress",
        ".sti":           "application/vnd.sun.xml.impress.template",
        ".sxg":           "application/vnd.sun.xml.writer.global",
        ".sxm":           "application/vnd.sun.xml.math",
        ".sis":           "application/vnd.symbian.install",
        ".wbxml":         "application/vnd.wap.wbxml",
        ".wmlc":          "application/vnd.wap.wmlc",
        ".wmlsc":         "application/vnd.wap.wmlscriptc",
        ".bcpio":         "application/x-bcpio",
        ".torrent":       "application/x-bittorrent",
        ".bz2":           "application/x-bzip2",
        ".vcd":           "application/x-cdlink",
        ".pgn":           "application/x-chess-pgn",
        ".cpio":          "application/x-cpio",
        ".csh":           "application/x-csh",
        ".dvi":           "application/x-dvi",
        ".spl":           "application/x-futuresplash",
        ".gtar":          "application/x-gtar",
        ".hdf":           "application/x-hdf",
        ".jar":           "application/x-java-archive",
        ".jnlp":          "application/x-java-jnlp-file",
        ".js":            "application/x-javascript",
        ".ksp":           "application/x-kspread",
        ".chrt":          "application/x-kchart",
        ".kil":           "application/x-killustrator",
        ".latex":         "application/x-latex",
        ".rpm":           "application/x-rpm",
        ".sh":            "application/x-sh",
        ".shar":          "application/x-shar",
        ".swf":           "application/x-shockwave-flash",
        ".sit":           "application/x-stuffit",
        ".sv4cpio":       "application/x-sv4cpio",
        ".sv4crc":        "application/x-sv4crc",
        ".tar":           "application/x-tar",
        ".tcl":           "application/x-tcl",
        ".tex":           "application/x-tex",
        ".man":           "application/x-troff-man",
        ".me":            "application/x-troff-me",
        ".ms":            "application/x-troff-ms",
        ".ustar":         "application/x-ustar",
        ".src":           "application/x-wais-source",
        ".zip":           "application/zip",
        ".m3u":           "audio/x-mpegurl",
        ".ra":            "audio/x-pn-realaudio",
        ".wav":           "audio/x-wav",
        ".wma":           "audio/x-ms-wma",
        ".wax":           "audio/x-ms-wax",
        ".pdb":           "chemical/x-pdb",
        ".xyz":           "chemical/x-xyz",
        ".bmp":           "image/bmp",
        ".gif":           "image/gif",
        ".ief":           "image/ief",
        ".png":           "image/png",
        ".wbmp":          "image/vnd.wap.wbmp",
        ".ras":           "image/x-cmu-raster",
        ".pnm":           "image/x-portable-anymap",
        ".pbm":           "image/x-portable-bitmap",
        ".pgm":           "image/x-portable-graymap",
        ".ppm":           "image/x-portable-pixmap",
        ".rgb":           "image/x-rgb",
        ".xbm":           "image/x-xbitmap",
        ".xpm":           "image/x-xpixmap",
        ".xwd":           "image/x-xwindowdump",
        ".css":           "text/css",
        ".rtx":           "text/richtext",
        ".tsv":           "text/tab-separated-values",
        ".jad":           "text/vnd.sun.j2me.app-descriptor",
        ".wml":           "text/vnd.wap.wml",
        ".wmls":          "text/vnd.wap.wmlscript",
        ".etx":           "text/x-setext",
        ".mxu":           "video/vnd.mpegurl",
        ".flv":           "video/x-flv",
        ".wm":            "video/x-ms-wm",
        ".wmv":           "video/x-ms-wmv",
        ".wmx":           "video/x-ms-wmx",
        ".wvx":           "video/x-ms-wvx",
        ".avi":           "video/x-msvideo",
        ".movie":         "video/x-sgi-movie",
        ".ice":           "x-conference/x-cooltalk",
        ".3gp":           "video/3gpp",
        ".ai":            "application/postscript",
        ".aif":           "audio/x-aiff",
        ".aifc":          "audio/x-aiff",
        ".aiff":          "audio/x-aiff",
        ".asc":           "text/plain",
        ".atom":          "application/atom+xml",
        ".au":            "audio/basic",
        ".bin":           "application/octet-stream",
        ".cdf":           "application/x-netcdf",
        ".cgm":           "image/cgm",
        ".class":         "application/octet-stream",
        ".dcr":           "application/x-director",
        ".dif":           "video/x-dv",
        ".dir":           "application/x-director",
        ".djv":           "image/vnd.djvu",
        ".djvu":          "image/vnd.djvu",
        ".dll":           "application/octet-stream",
        ".dmg":           "application/octet-stream",
        ".dms":           "application/octet-stream",
        ".dtd":           "application/xml-dtd",
        ".dv":            "video/x-dv",
        ".dxr":           "application/x-director",
        ".eps":           "application/postscript",
        ".exe":           "application/octet-stream",
        ".ez":            "application/andrew-inset",
        ".gram":          "application/srgs",
        ".grxml":         "application/srgs+xml",
        ".gz":            "application/x-gzip",
        ".htm":           "text/html",
        ".html":          "text/html",
        ".ico":           "image/x-icon",
        ".ics":           "text/calendar",
        ".ifb":           "text/calendar",
        ".iges":          "model/iges",
        ".igs":           "model/iges",
        ".jp2":           "image/jp2",
        ".jpe":           "image/jpeg",
        ".jpeg":          "image/jpeg",
        ".jpg":           "image/jpeg",
        ".kar":           "audio/midi",
        ".lha":           "application/octet-stream",
        ".lzh":           "application/octet-stream",
        ".m4a":           "audio/mp4a-latm",
        ".m4p":           "audio/mp4a-latm",
        ".m4u":           "video/vnd.mpegurl",
        ".m4v":           "video/x-m4v",
        ".mac":           "image/x-macpaint",
        ".mathml":        "application/mathml+xml",
        ".mesh":          "model/mesh",
        ".mid":           "audio/midi",
        ".midi":          "audio/midi",
        ".mov":           "video/quicktime",
        ".mp2":           "audio/mpeg",
        ".mp3":           "audio/mpeg",
        ".mp4":           "video/mp4",
        ".mpe":           "video/mpeg",
        ".mpeg":          "video/mpeg",
        ".mpg":           "video/mpeg",
        ".mpga":          "audio/mpeg",
        ".msh":           "model/mesh",
        ".nc":            "application/x-netcdf",
        ".oda":           "application/oda",
        ".ogv":           "video/ogv",
        ".pct":           "image/pict",
        ".pic":           "image/pict",
        ".pict":          "image/pict",
        ".pnt":           "image/x-macpaint",
        ".pntg":          "image/x-macpaint",
        ".ps":            "application/postscript",
        ".qt":            "video/quicktime",
        ".qti":           "image/x-quicktime",
        ".qtif":          "image/x-quicktime",
        ".ram":           "audio/x-pn-realaudio",
        ".rdf":           "application/rdf+xml",
        ".rm":            "application/vnd.rn-realmedia",
        ".roff":          "application/x-troff",
        ".sgm":           "text/sgml",
        ".sgml":          "text/sgml",
        ".silo":          "model/mesh",
        ".skd":           "application/x-koan",
        ".skm":           "application/x-koan",
        ".skp":           "application/x-koan",
        ".skt":           "application/x-koan",
        ".smi":           "application/smil",
        ".smil":          "application/smil",
        ".snd":           "audio/basic",
        ".so":            "application/octet-stream",
        ".svg":           "image/svg+xml",
        ".t":             "application/x-troff",
        ".texi":          "application/x-texinfo",
        ".texinfo":       "application/x-texinfo",
        ".tif":           "image/tiff",
        ".tiff":          "image/tiff",
        ".tr":            "application/x-troff",
        ".txt":           "text/plain",
        ".vrml":          "model/vrml",
        ".vxml":          "application/voicexml+xml",
        ".webm":          "video/webm",
        ".wrl":           "model/vrml",
        ".xht":           "application/xhtml+xml",
        ".xhtml":         "application/xhtml+xml",
        ".xml":           "application/xml",
        ".xsl":           "application/xml",
        ".xslt":          "application/xslt+xml",
        ".xul":           "application/vnd.mozilla.xul+xml",
        ".webp":          "image/webp",
        ".323":           "text/h323",
        ".aab":           "application/x-authoware-bin",
        ".aam":           "application/x-authoware-map",
        ".aas":           "application/x-authoware-seg",
        ".acx":           "application/internet-property-stream",
        ".als":           "audio/X-Alpha5",
        ".amc":           "application/x-mpeg",
        ".ani":           "application/octet-stream",
        ".asd":           "application/astound",
        ".asf":           "video/x-ms-asf",
        ".asn":           "application/astound",
        ".asp":           "application/x-asap",
        ".asr":           "video/x-ms-asf",
        ".asx":           "video/x-ms-asf",
        ".avb":           "application/octet-stream",
        ".awb":           "audio/amr-wb",
        ".axs":           "application/olescript",
        ".bas":           "text/plain",
        ".bin ":          "application/octet-stream",
        ".bld":           "application/bld",
        ".bld2":          "application/bld2",
        ".bpk":           "application/octet-stream",
        ".c":             "text/plain",
        ".cal":           "image/x-cals",
        ".cat":           "application/vnd.ms-pkiseccat",
        ".ccn":           "application/x-cnc",
        ".cco":           "application/x-cocoa",
        ".cer":           "application/x-x509-ca-cert",
        ".cgi":           "magnus-internal/cgi",
        ".chat":          "application/x-chat",
        ".clp":           "application/x-msclip",
        ".cmx":           "image/x-cmx",
        ".co":            "application/x-cult3d-object",
        ".cod":           "image/cis-cod",
        ".conf":          "text/plain",
        ".cpp":           "text/plain",
        ".crd":           "application/x-mscardfile",
        ".crl":           "application/pkix-crl",
        ".crt":           "application/x-x509-ca-cert",
        ".csm":           "chemical/x-csml",
        ".csml":          "chemical/x-csml",
        ".cur":           "application/octet-stream",
        ".dcm":           "x-lml/x-evm",
        ".dcx":           "image/x-dcx",
        ".der":           "application/x-x509-ca-cert",
        ".dhtml":         "text/html",
        ".dot":           "application/msword",
        ".dwf":           "drawing/x-dwf",
        ".dwg":           "application/x-autocad",
        ".dxf":           "application/x-autocad",
        ".ebk":           "application/x-expandedbook",
        ".emb":           "chemical/x-embl-dl-nucleotide",
        ".embl":          "chemical/x-embl-dl-nucleotide",
        ".epub":          "application/epub+zip",
        ".eri":           "image/x-eri",
        ".es":            "audio/echospeech",
        ".esl":           "audio/echospeech",
        ".etc":           "application/x-earthtime",
        ".evm":           "x-lml/x-evm",
        ".evy":           "application/envoy",
        ".fh4":           "image/x-freehand",
        ".fh5":           "image/x-freehand",
        ".fhc":           "image/x-freehand",
        ".fif":           "application/fractals",
        ".flr":           "x-world/x-vrml",
        ".fm":            "application/x-maker",
        ".fpx":           "image/x-fpx",
        ".fvi":           "video/isivideo",
        ".gau":           "chemical/x-gaussian-input",
        ".gca":           "application/x-gca-compressed",
        ".gdb":           "x-lml/x-gdb",
        ".gps":           "application/x-gps",
        ".h":             "text/plain",
        ".hdm":           "text/x-hdml",
        ".hdml":          "text/x-hdml",
        ".hlp":           "application/winhlp",
        ".hta":           "application/hta",
        ".htc":           "text/x-component",
        ".hts":           "text/html",
        ".htt":           "text/webviewhtml",
        ".ifm":           "image/gif",
        ".ifs":           "image/ifs",
        ".iii":           "application/x-iphone",
        ".imy":           "audio/melody",
        ".ins":           "application/x-internet-signup",
        ".ips":           "application/x-ipscript",
        ".ipx":           "application/x-ipix",
        ".isp":           "application/x-internet-signup",
        ".it":            "audio/x-mod",
        ".itz":           "audio/x-mod",
        ".ivr":           "i-world/i-vrml",
        ".j2k":           "image/j2k",
        ".jam":           "application/x-jam",
        ".java":          "text/plain",
        ".jfif":          "image/pipeg",
        ".jpz":           "image/jpeg",
        ".jwc":           "application/jwc",
        ".kjx":           "application/x-kjx",
        ".lak":           "x-lml/x-lak",
        ".lcc":           "application/fastman",
        ".lcl":           "application/x-digitalloca",
        ".lcr":           "application/x-digitalloca",
        ".lgh":           "application/lgh",
        ".lml":           "x-lml/x-lml",
        ".lmlpack":       "x-lml/x-lmlpack",
        ".log":           "text/plain",
        ".lsf":           "video/x-la-asf",
        ".lsx":           "video/x-la-asf",
        ".m13":           "application/x-msmediaview",
        ".m14":           "application/x-msmediaview",
        ".m15":           "audio/x-mod",
        ".m3url":         "audio/x-mpegurl",
        ".m4b":           "audio/mp4a-latm",
        ".ma1":           "audio/ma1",
        ".ma2":           "audio/ma2",
        ".ma3":           "audio/ma3",
        ".ma5":           "audio/ma5",
        ".map":           "magnus-internal/imagemap",
        ".mbd":           "application/mbedlet",
        ".mct":           "application/x-mascot",
        ".mdb":           "application/x-msaccess",
        ".mdz":           "audio/x-mod",
        ".mel":           "text/x-vmel",
        ".mht":           "message/rfc822",
        ".mhtml":         "message/rfc822",
        ".mi":            "application/x-mif",
        ".mil":           "image/x-cals",
        ".mio":           "audio/x-mio",
        ".mmf":           "application/x-skt-lbs",
        ".mng":           "video/x-mng",
        ".mny":           "application/x-msmoney",
        ".moc":           "application/x-mocha",
        ".mocha":         "application/x-mocha",
        ".mod":           "audio/x-mod",
        ".mof":           "application/x-yumekara",
        ".mol":           "chemical/x-mdl-molfile",
        ".mop":           "chemical/x-mopac-input",
        ".mpa":           "video/mpeg",
        ".mpc":           "application/vnd.mpohun.certificate",
        ".mpg4":          "video/mp4",
        ".mpn":           "application/vnd.mophun.application",
        ".mpp":           "application/vnd.ms-project",
        ".mps":           "application/x-mapserver",
        ".mpv2":          "video/mpeg",
        ".mrl":           "text/x-mrml",
        ".mrm":           "application/x-mrm",
        ".msg":           "application/vnd.ms-outlook",
        ".mts":           "application/metastream",
        ".mtx":           "application/metastream",
        ".mtz":           "application/metastream",
        ".mvb":           "application/x-msmediaview",
        ".mzv":           "application/metastream",
        ".nar":           "application/zip",
        ".nbmp":          "image/nbmp",
        ".ndb":           "x-lml/x-ndb",
        ".ndwn":          "application/ndwn",
        ".nif":           "application/x-nif",
        ".nmz":           "application/x-scream",
        ".nokia-op-logo": "image/vnd.nok-oplogo-color",
        ".npx":           "application/x-netfpx",
        ".nsnd":          "audio/nsnd",
        ".nva":           "application/x-neva1",
        ".nws":           "message/rfc822",
        ".oom":           "application/x-AtlasMate-Plugin",
        ".p10":           "application/pkcs10",
        ".p12":           "application/x-pkcs12",
        ".p7b":           "application/x-pkcs7-certificates",
        ".p7c":           "application/x-pkcs7-mime",
        ".p7m":           "application/x-pkcs7-mime",
        ".p7r":           "application/x-pkcs7-certreqresp",
        ".p7s":           "application/x-pkcs7-signature",
        ".pac":           "audio/x-pac",
        ".pae":           "audio/x-epac",
        ".pan":           "application/x-pan",
        ".pcx":           "image/x-pcx",
        ".pda":           "image/x-pda",
        ".pfr":           "application/font-tdpfr",
        ".pfx":           "application/x-pkcs12",
        ".pko":           "application/ynd.ms-pkipko",
        ".pm":            "application/x-perl",
        ".pma":           "application/x-perfmon",
        ".pmc":           "application/x-perfmon",
        ".pmd":           "application/x-pmd",
        ".pml":           "application/x-perfmon",
        ".pmr":           "application/x-perfmon",
        ".pmw":           "application/x-perfmon",
        ".pnz":           "image/png",
        ".pot,":          "application/vnd.ms-powerpoint",
        ".pps":           "application/vnd.ms-powerpoint",
        ".pqf":           "application/x-cprplayer",
        ".pqi":           "application/cprplayer",
        ".prc":           "application/x-prc",
        ".prf":           "application/pics-rules",
        ".prop":          "text/plain",
        ".proxy":         "application/x-ns-proxy-autoconfig",
        ".ptlk":          "application/listenup",
        ".pub":           "application/x-mspublisher",
        ".pvx":           "video/x-pv-pvx",
        ".qcp":           "audio/vnd.qcelp",
        ".r3t":           "text/vnd.rn-realtext3d",
        ".rar":           "application/octet-stream",
        ".rc":            "text/plain",
        ".rf":            "image/vnd.rn-realflash",
        ".rlf":           "application/x-richlink",
        ".rmf":           "audio/x-rmf",
        ".rmi":           "audio/mid",
        ".rmm":           "audio/x-pn-realaudio",
        ".rmvb":          "audio/x-pn-realaudio",
        ".rnx":           "application/vnd.rn-realplayer",
        ".rp":            "image/vnd.rn-realpix",
        ".rt":            "text/vnd.rn-realtext",
        ".rte":           "x-lml/x-gps",
        ".rtg":           "application/metastream",
        ".rv":            "video/vnd.rn-realvideo",
        ".rwc":           "application/x-rogerwilco",
        ".s3m":           "audio/x-mod",
        ".s3z":           "audio/x-mod",
        ".sca":           "application/x-supercard",
        ".scd":           "application/x-msschedule",
        ".sct":           "text/scriptlet",
        ".sdf":           "application/e-score",
        ".sea":           "application/x-stuffit",
        ".setpay":        "application/set-payment-initiation",
        ".setreg":        "application/set-registration-initiation",
        ".shtml":         "text/html",
        ".shtm":          "text/html",
        ".shw":           "application/presentations",
        ".si6":           "image/si6",
        ".si7":           "image/vnd.stiwap.sis",
        ".si9":           "image/vnd.lgtwap.sis",
        ".slc":           "application/x-salsa",
        ".smd":           "audio/x-smd",
        ".smp":           "application/studiom",
        ".smz":           "audio/x-smd",
        ".spc":           "application/x-pkcs7-certificates",
        ".spr":           "application/x-sprite",
        ".sprite":        "application/x-sprite",
        ".sdp":           "application/sdp",
        ".spt":           "application/x-spt",
        ".sst":           "application/vnd.ms-pkicertstore",
        ".stk":           "application/hyperstudio",
        ".stl":           "application/vnd.ms-pkistl",
        ".stm":           "text/html",
        ".svf":           "image/vnd",
        ".svh":           "image/svh",
        ".svr":           "x-world/x-svr",
        ".swfl":          "application/x-shockwave-flash",
        ".tad":           "application/octet-stream",
        ".talk":          "text/x-speech",
        ".taz":           "application/x-tar",
        ".tbp":           "application/x-timbuktu",
        ".tbt":           "application/x-timbuktu",
        ".tgz":           "application/x-compressed",
        ".thm":           "application/vnd.eri.thm",
        ".tki":           "application/x-tkined",
        ".tkined":        "application/x-tkined",
        ".toc":           "application/toc",
        ".toy":           "image/toy",
        ".trk":           "x-lml/x-gps",
        ".trm":           "application/x-msterminal",
        ".tsi":           "audio/tsplayer",
        ".tsp":           "application/dsptype",
        ".ttf":           "application/octet-stream",
        ".ttz":           "application/t-time",
        ".uls":           "text/iuls",
        ".ult":           "audio/x-mod",
        ".uu":            "application/x-uuencode",
        ".uue":           "application/x-uuencode",
        ".vcf":           "text/x-vcard",
        ".vdo":           "video/vdo",
        ".vib":           "audio/vib",
        ".viv":           "video/vivo",
        ".vivo":          "video/vivo",
        ".vmd":           "application/vocaltec-media-desc",
        ".vmf":           "application/vocaltec-media-file",
        ".vmi":           "application/x-dreamcast-vms-info",
        ".vms":           "application/x-dreamcast-vms",
        ".vox":           "audio/voxware",
        ".vqe":           "audio/x-twinvq-plugin",
        ".vqf":           "audio/x-twinvq",
        ".vql":           "audio/x-twinvq",
        ".vre":           "x-world/x-vream",
        ".vrt":           "x-world/x-vrt",
        ".vrw":           "x-world/x-vream",
        ".vts":           "workbook/formulaone",
        ".wcm":           "application/vnd.ms-works",
        ".wdb":           "application/vnd.ms-works",
        ".web":           "application/vnd.xara",
        ".wi":            "image/wavelet",
        ".wis":           "application/x-InstallShield",
        ".wks":           "application/vnd.ms-works",
        ".wmd":           "application/x-ms-wmd",
        ".wmf":           "application/x-msmetafile",
        ".wmlscript":     "text/vnd.wap.wmlscript",
        ".wmz":           "application/x-ms-wmz",
        ".wpng":          "image/x-up-wpng",
        ".wps":           "application/vnd.ms-works",
        ".wpt":           "x-lml/x-gps",
        ".wri":           "application/x-mswrite",
        ".wrz":           "x-world/x-vrml",
        ".ws":            "text/vnd.wap.wmlscript",
        ".wsc":           "application/vnd.wap.wmlscriptc",
        ".wv":            "video/wavelet",
        ".wxl":           "application/x-wxl",
        ".x-gzip":        "application/x-gzip",
        ".xaf":           "x-world/x-vrml",
        ".xar":           "application/vnd.xara",
        ".xdm":           "application/x-xdma",
        ".xdma":          "application/x-xdma",
        ".xdw":           "application/vnd.fujixerox.docuworks",
        ".xhtm":          "application/xhtml+xml",
        ".xla":           "application/vnd.ms-excel",
        ".xlc":           "application/vnd.ms-excel",
        ".xll":           "application/x-excel",
        ".xlm":           "application/vnd.ms-excel",
        ".xlt":           "application/vnd.ms-excel",
        ".xlw":           "application/vnd.ms-excel",
        ".xm":            "audio/x-mod",
        ".xmz":           "audio/x-mod",
        ".xof":           "x-world/x-vrml",
        ".xpi":           "application/x-xpinstall",
        ".xsit":          "text/xml",
        ".yz1":           "application/x-yz1",
        ".z":             "application/x-compress",
        ".zac":           "application/x-zaurus-zac",
        ".json":          "application/json",
}

// TypeByExtension returns the MIME type associated with the file extension ext.
// gets the file's MIME type for HTTP header Content-Type
func TypeByExtension(filePath string) string <span class="cov8" title="1">{
        ext := path.Ext(filePath)
        typ := mime.TypeByExtension(ext)
        if typ == "" </span><span class="cov8" title="1">{
                typ = extToMimeType[strings.ToLower(ext)]
        }</span> else<span class="cov8" title="1"> {
                if strings.HasPrefix(typ, "text/") &amp;&amp; strings.Contains(typ, "charset=") </span><span class="cov8" title="1">{
                        typ = removeCharsetInMimeType(typ)
                }</span>
        }
        <span class="cov8" title="1">return typ</span>
}

// Remove charset from mime type
func removeCharsetInMimeType(typ string) (str string) <span class="cov8" title="1">{
        temArr := strings.Split(typ, ";")
        var builder strings.Builder
        for i, s := range temArr </span><span class="cov8" title="1">{
                tmpStr := strings.Trim(s, " ")
                if strings.Contains(tmpStr, "charset=") </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        builder.WriteString(s)
                }</span> else<span class="cov0" title="0"> {
                        builder.WriteString("; " + s)
                }</span>
        }
        <span class="cov8" title="1">return builder.String()</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package oss

import (
        "context"
        "fmt"
        "sync"
)

type byteSlicePool interface {
        Get(context.Context) (*[]byte, error)
        Put(*[]byte)
        ModifyCapacity(int)
        SliceSize() int64
        Close()
}

type maxSlicePool struct {
        allocator sliceAllocator

        slices         chan *[]byte
        allocations    chan struct{}
        capacityChange chan struct{}

        max       int
        sliceSize int64

        mtx sync.RWMutex
}

func newMaxSlicePool(sliceSize int64) *maxSlicePool <span class="cov8" title="1">{
        p := &amp;maxSlicePool{sliceSize: sliceSize}
        p.allocator = p.newSlice

        return p
}</span>

var errZeroCapacity = fmt.Errorf("get called on zero capacity pool")

func (p *maxSlicePool) Get(ctx context.Context) (*[]byte, error) <span class="cov8" title="1">{
        // check if context is canceled before attempting to get a slice
        // this ensures priority is given to the cancel case first
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">p.mtx.RLock()

        for </span><span class="cov8" title="1">{
                select </span>{
                case bs, ok := &lt;-p.slices:<span class="cov8" title="1">
                        p.mtx.RUnlock()
                        if !ok </span><span class="cov0" title="0">{
                                // attempt to get on a zero capacity pool
                                return nil, errZeroCapacity
                        }</span>
                        <span class="cov8" title="1">return bs, nil</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        p.mtx.RUnlock()
                        return nil, ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                        // pass
                }

                <span class="cov8" title="1">select </span>{
                case _, ok := &lt;-p.allocations:<span class="cov8" title="1">
                        p.mtx.RUnlock()
                        if !ok </span><span class="cov0" title="0">{
                                // attempt to get on a zero capacity pool
                                return nil, errZeroCapacity
                        }</span>
                        <span class="cov8" title="1">return p.allocator(), nil</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        p.mtx.RUnlock()
                        return nil, ctx.Err()</span>
                default:<span class="cov8" title="1">
                        // In the event that there are no slices or allocations available
                        // This prevents some deadlock situations that can occur around sync.RWMutex
                        // When a lock request occurs on ModifyCapacity, no new readers are allowed to acquire a read lock.
                        // By releasing the read lock here and waiting for a notification, we prevent a deadlock situation where
                        // Get could hold the read lock indefinitely waiting for capacity, ModifyCapacity is waiting for a write lock,
                        // and a Put is blocked trying to get a read-lock which is blocked by ModifyCapacity.

                        // Short-circuit if the pool capacity is zero.
                        if p.max == 0 </span><span class="cov0" title="0">{
                                p.mtx.RUnlock()
                                return nil, errZeroCapacity
                        }</span>

                        // Since we will be releasing the read-lock we need to take the reference to the channel.
                        // Since channels are references we will still get notified if slices are added, or if
                        // the channel is closed due to a capacity modification. This specifically avoids a data race condition
                        // where ModifyCapacity both closes a channel and initializes a new one while we don't have a read-lock.
                        <span class="cov8" title="1">c := p.capacityChange

                        p.mtx.RUnlock()

                        select </span>{
                        case _ = &lt;-c:<span class="cov8" title="1">
                                p.mtx.RLock()</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return nil, ctx.Err()</span>
                        }
                }
        }
}

func (p *maxSlicePool) Put(bs *[]byte) <span class="cov8" title="1">{
        p.mtx.RLock()
        defer p.mtx.RUnlock()

        if p.max == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">select </span>{
        case p.slices &lt;- bs:<span class="cov8" title="1">
                p.notifyCapacity()</span>
        default:<span class="cov0" title="0"></span>
                // If the new channel when attempting to add the slice then we drop the slice.
                // The logic here is to prevent a deadlock situation if channel is already at max capacity.
                // Allows us to reap allocations that are returned and are no longer needed.
        }
}

func (p *maxSlicePool) ModifyCapacity(delta int) <span class="cov8" title="1">{
        if delta == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">p.mtx.Lock()
        defer p.mtx.Unlock()

        p.max += delta

        if p.max == 0 </span><span class="cov0" title="0">{
                p.empty()
                return
        }</span>

        <span class="cov8" title="1">if p.capacityChange != nil </span><span class="cov0" title="0">{
                close(p.capacityChange)
        }</span>
        <span class="cov8" title="1">p.capacityChange = make(chan struct{}, p.max)

        origAllocations := p.allocations
        p.allocations = make(chan struct{}, p.max)

        newAllocs := len(origAllocations) + delta
        for i := 0; i &lt; newAllocs; i++ </span><span class="cov8" title="1">{
                p.allocations &lt;- struct{}{}
        }</span>

        <span class="cov8" title="1">if origAllocations != nil </span><span class="cov0" title="0">{
                close(origAllocations)
        }</span>

        <span class="cov8" title="1">origSlices := p.slices
        p.slices = make(chan *[]byte, p.max)
        if origSlices == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">close(origSlices)
        for bs := range origSlices </span><span class="cov0" title="0">{
                select </span>{
                case p.slices &lt;- bs:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                        // If the new channel blocks while adding slices from the old channel
                        // then we drop the slice. The logic here is to prevent a deadlock situation
                        // if the new channel has a smaller capacity then the old.
                }
        }
}

func (p *maxSlicePool) notifyCapacity() <span class="cov8" title="1">{
        select </span>{
        case p.capacityChange &lt;- struct{}{}:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
                // This *shouldn't* happen as the channel is both buffered to the max pool capacity size and is resized
                // on capacity modifications. This is just a safety to ensure that a blocking situation can't occur.
        }
}

func (p *maxSlicePool) SliceSize() int64 <span class="cov0" title="0">{
        return p.sliceSize
}</span>

func (p *maxSlicePool) Close() <span class="cov8" title="1">{
        p.mtx.Lock()
        defer p.mtx.Unlock()
        p.empty()
}</span>

func (p *maxSlicePool) empty() <span class="cov8" title="1">{
        p.max = 0

        if p.capacityChange != nil </span><span class="cov8" title="1">{
                close(p.capacityChange)
                p.capacityChange = nil
        }</span>

        <span class="cov8" title="1">if p.allocations != nil </span><span class="cov8" title="1">{
                close(p.allocations)
                for range p.allocations </span>{<span class="cov0" title="0">
                        // drain channel
                }</span>
                <span class="cov8" title="1">p.allocations = nil</span>
        }

        <span class="cov8" title="1">if p.slices != nil </span><span class="cov8" title="1">{
                close(p.slices)
                for range p.slices </span>{<span class="cov8" title="1">
                        // drain channel
                }</span>
                <span class="cov8" title="1">p.slices = nil</span>
        }
}

func (p *maxSlicePool) newSlice() *[]byte <span class="cov8" title="1">{
        bs := make([]byte, p.sliceSize)
        return &amp;bs
}</span>

type returnCapacityPoolCloser struct {
        byteSlicePool
        returnCapacity int
}

func (n *returnCapacityPoolCloser) ModifyCapacity(delta int) <span class="cov0" title="0">{
        if delta &gt; 0 </span><span class="cov0" title="0">{
                n.returnCapacity = -1 * delta
        }</span>
        <span class="cov0" title="0">n.byteSlicePool.ModifyCapacity(delta)</span>
}

func (n *returnCapacityPoolCloser) Close() <span class="cov0" title="0">{
        if n.returnCapacity &lt; 0 </span><span class="cov0" title="0">{
                n.byteSlicePool.ModifyCapacity(n.returnCapacity)
        }</span>
}

type sliceAllocator func() *[]byte

var newByteSlicePool = func(sliceSize int64) byteSlicePool <span class="cov8" title="1">{
        return newMaxSlicePool(sliceSize)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package oss

import (
        "net/url"
)

func isValidEndpoint(endpoint *url.URL) bool <span class="cov8" title="1">{
        return (endpoint != nil)
}</span>

func isValidBucketName(bucketName *string) bool <span class="cov8" title="1">{
        if bucketName == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">nameLen := len(*bucketName)
        if nameLen &lt; 3 || nameLen &gt; 63 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if (*bucketName)[0] == '-' || (*bucketName)[nameLen-1] == '-' </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for _, v := range *bucketName </span><span class="cov8" title="1">{
                if !(('a' &lt;= v &amp;&amp; v &lt;= 'z') || ('0' &lt;= v &amp;&amp; v &lt;= '9') || v == '-') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func isValidObjectName(objectName *string) bool <span class="cov8" title="1">{
        if objectName == nil || len(*objectName) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func isValidRange(r *string) bool <span class="cov8" title="1">{
        if _, err := ParseRange(*r); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

var supportedMethod = map[string]struct{}{
        "GET":    {},
        "PUT":    {},
        "HEAD":   {},
        "POST":   {},
        "DELETE": {},
        "OPTION": {},
}

func isValidMethod(method string) bool <span class="cov8" title="1">{
        if _, ok := supportedMethod[method]; ok </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package oss

import (
        "bytes"
        "fmt"
        "sync"
)

const (
        major = "3"
        minor = "0"
        patch = "0"
        tag   = "-devpreview"

        SdkName = "aliyun-oss-go-sdk"
)

var once sync.Once
var version string

func Version() string <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                ver := fmt.Sprintf("%s.%s.%s", major, minor, patch)
                verBuilder := bytes.NewBufferString(ver)
                if tag != "" &amp;&amp; tag != "-" </span><span class="cov8" title="1">{
                        _, err := verBuilder.WriteString(tag)
                        if err != nil </span><span class="cov0" title="0">{
                                verBuilder = bytes.NewBufferString(ver)
                        }</span>
                }
                <span class="cov8" title="1">version = verBuilder.String()</span>
        })
        <span class="cov8" title="1">return version</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package oss

import (
        "encoding/xml"
        "errors"
        "fmt"
        "io"
        "strings"
        "unicode"
        "unicode/utf8"
)

type XmlDecoderLite struct {
        reader          io.Reader
        attributePrefix string
        useRawToken     bool
}

func NewXmlDecoderLite(r io.Reader) *XmlDecoderLite <span class="cov8" title="1">{
        return &amp;XmlDecoderLite{
                reader:          r,
                attributePrefix: "+@",
                useRawToken:     true,
        }
}</span>

func (dec *XmlDecoderLite) Decode(root *XmlNode) error <span class="cov8" title="1">{
        return dec.decodeXML(root)
}</span>

type XmlNode struct {
        Children []*XmlChildren
        Data     []string
}

type XmlChildren struct {
        K string
        V []*XmlNode
}

func (n *XmlNode) addChild(s string, c *XmlNode) <span class="cov8" title="1">{
        if n.Children == nil </span><span class="cov8" title="1">{
                n.Children = make([]*XmlChildren, 0)
        }</span>
        <span class="cov8" title="1">for _, childEntry := range n.Children </span><span class="cov8" title="1">{
                if childEntry.K == s </span><span class="cov8" title="1">{
                        childEntry.V = append(childEntry.V, c)
                        return
                }</span>
        }
        <span class="cov8" title="1">n.Children = append(n.Children, &amp;XmlChildren{K: s, V: []*XmlNode{c}})</span>
}

func (n *XmlNode) value() any <span class="cov8" title="1">{
        if len(n.Children) &gt; 0 </span><span class="cov8" title="1">{
                return n.GetMap()
        }</span>
        <span class="cov8" title="1">if n.Data != nil </span><span class="cov8" title="1">{
                return n.Data[0]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (n *XmlNode) GetMap() map[string]any <span class="cov8" title="1">{
        node := map[string]any{}
        for _, kv := range n.Children </span><span class="cov8" title="1">{
                label := kv.K
                children := kv.V
                if len(children) &gt; 1 </span><span class="cov8" title="1">{
                        vals := make([]any, 0)
                        for _, child := range children </span><span class="cov8" title="1">{
                                vals = append(vals, child.value())
                        }</span>
                        <span class="cov8" title="1">node[label] = vals</span>
                } else<span class="cov8" title="1"> {
                        node[label] = children[0].value()
                }</span>
        }
        <span class="cov8" title="1">return node</span>
}

type element struct {
        parent *element
        n      *XmlNode
        label  string
}

func (dec *XmlDecoderLite) decodeXML(root *XmlNode) error <span class="cov8" title="1">{
        xmlDec := xml.NewDecoder(dec.reader)

        started := false

        // Create first element from the root node
        elem := &amp;element{
                parent: nil,
                n:      root,
        }

        getToken := func() (xml.Token, error) </span><span class="cov8" title="1">{
                if dec.useRawToken </span><span class="cov8" title="1">{
                        return xmlDec.RawToken()
                }</span>
                <span class="cov0" title="0">return xmlDec.Token()</span>
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                t, e := getToken()
                if e != nil &amp;&amp; !errors.Is(e, io.EOF) </span><span class="cov0" title="0">{
                        return e
                }</span>
                <span class="cov8" title="1">if t == nil </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">switch se := t.(type) </span>{
                case xml.StartElement:<span class="cov8" title="1">
                        elem = &amp;element{
                                parent: elem,
                                n:      &amp;XmlNode{},
                                label:  se.Name.Local,
                        }

                        for _, a := range se.Attr </span><span class="cov8" title="1">{
                                elem.n.addChild(dec.attributePrefix+a.Name.Local, &amp;XmlNode{Data: []string{a.Value}})
                        }</span>
                case xml.CharData:<span class="cov8" title="1">
                        newBit := trimNonGraphic(string(se))
                        if !started &amp;&amp; len(newBit) &gt; 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid XML: Encountered chardata [%v] outside of XML node", newBit)
                        }</span>

                        <span class="cov8" title="1">if len(newBit) &gt; 0 </span><span class="cov8" title="1">{
                                elem.n.Data = append(elem.n.Data, newBit)
                        }</span>
                case xml.EndElement:<span class="cov8" title="1">
                        if elem.parent != nil </span><span class="cov8" title="1">{
                                elem.parent.n.addChild(elem.label, elem.n)
                        }</span>
                        <span class="cov8" title="1">elem = elem.parent</span>
                }
                <span class="cov8" title="1">started = true</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func trimNonGraphic(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return s
        }</span>

        <span class="cov8" title="1">var first *int
        var last int
        for i, r := range []rune(s) </span><span class="cov8" title="1">{
                if !unicode.IsGraphic(r) || unicode.IsSpace(r) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if first == nil </span><span class="cov8" title="1">{
                        f := i
                        first = &amp;f
                        last = i
                }</span> else<span class="cov8" title="1"> {
                        last = i
                }</span>
        }

        <span class="cov8" title="1">if first == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return string([]rune(s)[*first : last+1])</span>
}

var (
        escQuot = []byte("&amp;#34;") // shorter than "&amp;quot;"
        escApos = []byte("&amp;#39;") // shorter than "&amp;apos;"
        escAmp  = []byte("&amp;amp;")
        escLT   = []byte("&amp;lt;")
        escGT   = []byte("&amp;gt;")
        escTab  = []byte("&amp;#x9;")
        escNL   = []byte("&amp;#xA;")
        escCR   = []byte("&amp;#xD;")
        escFFFD = []byte("\uFFFD") // Unicode replacement character
)

// escapeXml EscapeString writes to p the properly escaped XML equivalent
// of the plain text data s.
func escapeXml(s string) string <span class="cov8" title="1">{
        var p strings.Builder
        var esc []byte
        hextable := "0123456789ABCDEF"
        escPattern := []byte("&amp;#x00;")
        last := 0
        for i := 0; i &lt; len(s); </span><span class="cov8" title="1">{
                r, width := utf8.DecodeRuneInString(s[i:])
                i += width
                switch r </span>{
                case '"':<span class="cov0" title="0">
                        esc = escQuot</span>
                case '\'':<span class="cov0" title="0">
                        esc = escApos</span>
                case '&amp;':<span class="cov0" title="0">
                        esc = escAmp</span>
                case '&lt;':<span class="cov0" title="0">
                        esc = escLT</span>
                case '&gt;':<span class="cov0" title="0">
                        esc = escGT</span>
                case '\t':<span class="cov8" title="1">
                        esc = escTab</span>
                case '\n':<span class="cov8" title="1">
                        esc = escNL</span>
                case '\r':<span class="cov8" title="1">
                        esc = escCR</span>
                default:<span class="cov8" title="1">
                        if !isInCharacterRange(r) || (r == 0xFFFD &amp;&amp; width == 1) </span><span class="cov8" title="1">{
                                if r &gt;= 0x00 &amp;&amp; r &lt; 0x20 </span><span class="cov8" title="1">{
                                        escPattern[3] = hextable[r&gt;&gt;4]
                                        escPattern[4] = hextable[r&amp;0x0f]
                                        esc = escPattern
                                }</span> else<span class="cov0" title="0"> {
                                        esc = escFFFD
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">p.WriteString(s[last : i-width])
                p.Write(esc)
                last = i</span>
        }
        <span class="cov8" title="1">p.WriteString(s[last:])
        return p.String()</span>
}

// Decide whether the given rune is in the XML Character Range, per
// the Char production of https://www.xml.com/axml/testaxml.htm,
// Section 2.2 Characters.
func isInCharacterRange(r rune) (inrange bool) <span class="cov8" title="1">{
        return r == 0x09 ||
                r == 0x0A ||
                r == 0x0D ||
                r &gt;= 0x20 &amp;&amp; r &lt;= 0xD7FF ||
                r &gt;= 0xE000 &amp;&amp; r &lt;= 0xFFFD ||
                r &gt;= 0x10000 &amp;&amp; r &lt;= 0x10FFFF
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
